<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: entt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EnTT
   &#160;<span id="projectnumber">3.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">entt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>EnTT</code> default namespace.  
<a href="namespaceentt.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1std__sort.html">std_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object to wrap <code>std::sort</code> in a class type.  <a href="structentt_1_1std__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1insertion__sort.html">insertion_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing insertion sort.  <a href="structentt_1_1insertion__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1radix__sort.html">radix_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing LSD radix sort.  <a href="structentt_1_1radix__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__any.html">basic_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SBO friendly, type-safe container for single values of any type.  <a href="classentt_1_1basic__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1family.html">family</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic identifier generator.  <a href="classentt_1_1family.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero overhead unique identifier.  <a href="classentt_1_1basic__hashed__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1identifier.html">identifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types identifiers.  <a href="classentt_1_1identifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1monostate.html">monostate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal implementation of the monostate pattern.  <a href="structentt_1_1monostate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__seq.html">type_seq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type sequential identifier.  <a href="structentt_1_1type__seq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__hash.html">type_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type hash.  <a href="structentt_1_1type__hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__name.html">type_name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type name.  <a href="structentt_1_1type__name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1type__info.html">type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation specific information about a type.  <a href="classentt_1_1type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1choice__t.html">choice_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate overloaded functions.  <a href="structentt_1_1choice__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1choice__t_3_010_01_4.html">choice_t&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate overloaded functions.  <a href="structentt_1_1choice__t_3_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__identity.html">type_identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity type trait.  <a href="structentt_1_1type__identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1size__of.html">size_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-only <code>sizeof</code> wrapper that returns 0 where <code>sizeof</code> complains.  <a href="structentt_1_1size__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1size__of_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html">size_of&lt; Type, std::void_t&lt; decltype(sizeof(Type))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-only <code>sizeof</code> wrapper that returns 0 where <code>sizeof</code> complains.  <a href="structentt_1_1size__of_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list.html">type_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to use to push around lists of types, nothing more.  <a href="structentt_1_1type__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element.html">type_list_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element_3_01Index_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html">type_list_element&lt; Index, type_list&lt; Type, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1type__list__element_3_01Index_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element_3_010u_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html">type_list_element&lt; 0u, type_list&lt; Type, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1type__list__element_3_010u_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__cat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_4.html">type_list_cat&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html">type_list_cat&lt; type_list&lt; Type... &gt;, type_list&lt; Other... &gt;, List... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_01_4.html">type_list_cat&lt; type_list&lt; Type... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__unique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique_3_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html">type_list_unique&lt; type_list&lt; Type, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates types from a type list.  <a href="structentt_1_1type__list__unique_3_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique_3_01type__list_3_4_01_4.html">type_list_unique&lt; type_list&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates types from a type list.  <a href="structentt_1_1type__list__unique_3_01type__list_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a type list contains a given type, false otherwise.  <a href="structentt_1_1type__list__contains.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__contains_3_01type__list_3_01Type_8_8_8_01_4_00_01Other_01_4.html">type_list_contains&lt; type_list&lt; Type... &gt;, Other &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a type list contains a given type, false otherwise.  <a href="structentt_1_1type__list__contains_3_01type__list_3_01Type_8_8_8_01_4_00_01Other_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__diff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__diff_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_01_4.html">type_list_diff&lt; type_list&lt; Type... &gt;, type_list&lt; Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference between two type lists.  <a href="structentt_1_1type__list__diff_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list.html">value_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to use to push around lists of constant values, nothing more.  <a href="structentt_1_1value__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element.html">value_list_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1value__list__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element_3_01Index_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html">value_list_element&lt; Index, value_list&lt; Value, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the values of a value list.  <a href="structentt_1_1value__list__element_3_01Index_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element_3_010u_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html">value_list_element&lt; 0u, value_list&lt; Value, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1value__list__element_3_010u_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1value__list__cat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_4.html">value_list_cat&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_00_01value__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html">value_list_cat&lt; value_list&lt; Value... &gt;, value_list&lt; Other... &gt;, List... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_00_01value__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_01_4.html">value_list_cat&lt; value_list&lt; Value... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is equality comparable, false otherwise.  <a href="structentt_1_1is__equality__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable.html">is_applicable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.  <a href="structentt_1_1is__applicable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable_3_01Func_00_01Tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable&lt; Func, Tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.  <a href="structentt_1_1is__applicable_3_01Func_00_01Tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable_3_01Func_00_01const_01Tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable&lt; Func, const Tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.  <a href="structentt_1_1is__applicable_3_01Func_00_01const_01Tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable_r, but with tuples for arguments.  <a href="structentt_1_1is__applicable__r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable__r_3_01Ret_00_01Func_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable_r&lt; Ret, Func, std::tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable_r, but with tuples for arguments.  <a href="structentt_1_1is__applicable__r_3_01Ret_00_01Func_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__complete.html">is_complete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is complete, false otherwise.  <a href="structentt_1_1is__complete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__complete_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html">is_complete&lt; Type, std::void_t&lt; decltype(sizeof(Type))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is complete, false otherwise.  <a href="structentt_1_1is__complete_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is an iterator, false otherwise.  <a href="structentt_1_1is__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__iterator_3_01Type_00_01std_1_1void__t_3_01typename_01std_1_1iterator__traits_3a2eb7dcc84dd5d3a13fb4848a9e1994c.html">is_iterator&lt; Type, std::void_t&lt; typename std::iterator_traits&lt; Type &gt;::iterator_category &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is an iterator, false otherwise.  <a href="structentt_1_1is__iterator_3_01Type_00_01std_1_1void__t_3_01typename_01std_1_1iterator__traits_3a2eb7dcc84dd5d3a13fb4848a9e1994c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__iterator__type.html">is_iterator_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is of the required iterator type, false otherwise.  <a href="structentt_1_1is__iterator__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__iterator__type_3_01Type_00_01It_00_01std_1_1enable__if__t_3_01is__iterator__v_1c6d668122d93a8a6f6186aab47dc295.html">is_iterator_type&lt; Type, It, std::enable_if_t&lt; is_iterator_v&lt; Type &gt; &amp;&amp;std::is_same_v&lt; Type, It &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is of the required iterator type, false otherwise.  <a href="structentt_1_1is__iterator__type_3_01Type_00_01It_00_01std_1_1enable__if__t_3_01is__iterator__v_1c6d668122d93a8a6f6186aab47dc295.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__iterator__type_3_01Type_00_01It_00_01std_1_1enable__if__t_3_9std_1_1is__same__d827a14c04f195b53a7b353d4f3d2a15.html">is_iterator_type&lt; Type, It, std::enable_if_t&lt;!std::is_same_v&lt; Type, It &gt;, std::void_t&lt; typename It::iterator_type &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is of the required iterator type, false otherwise.  <a href="structentt_1_1is__iterator__type_3_01Type_00_01It_00_01std_1_1enable__if__t_3_9std_1_1is__same__d827a14c04f195b53a7b353d4f3d2a15.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1constness__as.html">constness_as</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transcribes the constness of a type to another type.  <a href="structentt_1_1constness__as.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1constness__as_3_01To_00_01const_01From_01_4.html">constness_as&lt; To, const From &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transcribes the constness of a type to another type.  <a href="structentt_1_1constness__as_3_01To_00_01const_01From_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1member__class.html">member_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the class of a non-static member object or function.  <a href="classentt_1_1member__class.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity function object (waiting for C++20).  <a href="structentt_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1overloaded.html">overloaded</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for visitors.  <a href="structentt_1_1overloaded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1y__combinator.html">y_combinator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of a y-combinator.  <a href="structentt_1_1y__combinator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__component__traits.html">basic_component_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commonly used default traits for all types.  <a href="structentt_1_1basic__component__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1component__traits.html">component_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common way to access various properties of components.  <a href="structentt_1_1component__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1entt__traits.html">entt_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity traits.  <a href="classentt_1_1entt__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1null__t.html">null_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null object for all entity identifiers. <br  />
  <a href="structentt_1_1null__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tombstone object for all entity identifiers. <br  />
  <a href="structentt_1_1tombstone__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic sparse set implementation.  <a href="classentt_1_1basic__sparse__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__storage.html">basic_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structentt_1_1Storage.html" title="Basic poly storage implementation.">Storage</a> implementation dispatcher.  <a href="structentt_1_1basic__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast and reliable entity-component system.  <a href="classentt_1_1basic__registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__view.html">basic_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View implementation dispatcher.  <a href="structentt_1_1basic__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime view.  <a href="classentt_1_1basic__runtime__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group.html">basic_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group.  <a href="classentt_1_1basic__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__observer.html">basic_observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observer.  <a href="classentt_1_1basic__observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__organizer.html">basic_organizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for creating a static task graph.  <a href="classentt_1_1basic__organizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__handle.html">basic_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning handle to an entity.  <a href="structentt_1_1basic__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__snapshot.html">basic_snapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to create snapshots from a registry.  <a href="classentt_1_1basic__snapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__snapshot__loader.html">basic_snapshot_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to restore a snapshot as a whole.  <a href="classentt_1_1basic__snapshot__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__continuous__loader.html">basic_continuous_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for <em>continuous loading</em>.  <a href="classentt_1_1basic__continuous__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01get__t_3_01Get_8_8_8_01_4_01_4.html">basic_group&lt; Entity, exclude_t&lt; Exclude... &gt;, get_t&lt; Get... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning group.  <a href="classentt_1_1basic__group_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01get__t_3_01Get_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01get__t_3_01Get_1aada3a14110654dc27700c17c9c2396.html">basic_group&lt; Entity, exclude_t&lt; Exclude... &gt;, get_t&lt; Get... &gt;, Owned... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning group.  <a href="classentt_1_1basic__group_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01get__t_3_01Get_1aada3a14110654dc27700c17c9c2396.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__view.html">as_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a registry to a view.  <a href="structentt_1_1as__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__group.html">as_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a registry to a group.  <a href="structentt_1_1as__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1matcher.html">matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grouping matcher.  <a href="structentt_1_1matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector.html">basic_collector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector_3_4.html">basic_collector&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector_3_01matcher_3_01type__list_3_01Reject_8_8_8_01_4_00_01type__list_98a79514dcad34a82f321f0796064ffb.html">basic_collector&lt; matcher&lt; type_list&lt; Reject... &gt;, type_list&lt; Require... &gt;, Rule... &gt;, Other... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector_3_01matcher_3_01type__list_3_01Reject_8_8_8_01_4_00_01type__list_98a79514dcad34a82f321f0796064ffb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1Storage.html">Storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic poly storage implementation.  <a href="structentt_1_1Storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1poly__storage__traits.html">poly_storage_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the poly storage type associate with a given entity type.  <a href="structentt_1_1poly__storage__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage__impl.html">basic_storage_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic storage implementation.  <a href="classentt_1_1basic__storage__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage__impl_3_01Entity_00_01Type_00_01Allocator_00_01std_1_1enable__if__t_7fdeb5322c9adc1b6d9330e5790be0ac.html">basic_storage_impl&lt; Entity, Type, Allocator, std::enable_if_t&lt; component_traits&lt; Type &gt;::ignore_if_empty::value &amp;&amp;std::is_empty_v&lt; Type &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classentt_1_1basic__storage__impl_3_01Entity_00_01Type_00_01Allocator_00_01std_1_1enable__if__t_7fdeb5322c9adc1b6d9330e5790be0ac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1storage__adapter__mixin.html">storage_adapter_mixin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin type to use to wrap basic storage classes.  <a href="structentt_1_1storage__adapter__mixin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh__storage__mixin.html">sigh_storage_mixin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin type to use to add signal support to storage types.  <a href="classentt_1_1sigh__storage__mixin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1storage__traits.html">storage_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a common way to access certain properties of storage types.  <a href="structentt_1_1storage__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1exclude__t.html">exclude_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for exclusion lists.  <a href="structentt_1_1exclude__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1get__t.html">get_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for lists of observed components.  <a href="structentt_1_1get__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1stable__storage__policy.html">stable_storage_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable storage policy, aimed at pointer stability.  <a href="structentt_1_1stable__storage__policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1packed__storage__policy.html">packed_storage_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packed storage policy, aimed at faster linear iteration.  <a href="structentt_1_1packed__storage__policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view__impl.html">basic_view_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View implementation.  <a href="classentt_1_1basic__view__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view__impl_3_01Policy_00_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01Component_8_8_8_01_4.html">basic_view_impl&lt; Policy, Entity, exclude_t&lt; Exclude... &gt;, Component... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi component view.  <a href="classentt_1_1basic__view__impl_3_01Policy_00_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01Component_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view__impl_3_01packed__storage__policy_00_01Entity_00_01exclude__t_3_4_00_01Component_01_4.html">basic_view_impl&lt; packed_storage_policy, Entity, exclude_t&lt;&gt;, Component &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single component view specialization.  <a href="classentt_1_1basic__view__impl_3_01packed__storage__policy_00_01Entity_00_01exclude__t_3_4_00_01Component_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__view_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01Component_8_8_8_01_4.html">basic_view&lt; Entity, exclude_t&lt; Exclude... &gt;, Component... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View implementation dispatcher.  <a href="structentt_1_1basic__view_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01Component_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1service__locator.html">service_locator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Service locator, nothing more.  <a href="structentt_1_1service__locator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1adl__meta__pointer__like.html">adl_meta_pointer_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fake ADL based lookup function for meta pointer-like types.  <a href="structentt_1_1adl__meta__pointer__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__container__traits.html">meta_container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container traits.  <a href="structentt_1_1meta__container__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__container.html">basic_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic STL-compatible container traits.  <a href="structentt_1_1basic__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__associative__container.html">basic_associative_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic STL-compatible associative container traits.  <a href="structentt_1_1basic__associative__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__dynamic__container.html">basic_dynamic_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic STL-compatible dynamic container traits.  <a href="structentt_1_1basic__dynamic__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__dynamic__associative__container.html">basic_dynamic_associative_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic STL-compatible dynamic associative container traits.  <a href="structentt_1_1basic__dynamic__associative__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__sequence__container.html">basic_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic STL-compatible sequence container traits.  <a href="structentt_1_1basic__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1dynamic__associative__key__only__container.html">dynamic_associative_key_only_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-compatible dynamic associative key-only container traits.  <a href="structentt_1_1dynamic__associative__key__only__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1dynamic__associative__key__value__container.html">dynamic_associative_key_value_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-compatible dynamic key-value associative container traits.  <a href="structentt_1_1dynamic__associative__key__value__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1dynamic__sequence__container.html">dynamic_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-compatible dynamic sequence container traits.  <a href="structentt_1_1dynamic__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1fixed__sequence__container.html">fixed_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-compatible fixed sequence container traits.  <a href="structentt_1_1fixed__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits_3_01std_1_1vector_3_01Type_00_01Args_8_8_8_01_4_01_4.html">meta_sequence_container_traits&lt; std::vector&lt; Type, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta sequence container traits for <code>std::vector</code>s of any type.  <a href="structentt_1_1meta__sequence__container__traits_3_01std_1_1vector_3_01Type_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits_3_01std_1_1array_3_01Type_00_01N_01_4_01_4.html">meta_sequence_container_traits&lt; std::array&lt; Type, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta sequence container traits for <code>std::array</code>s of any type.  <a href="structentt_1_1meta__sequence__container__traits_3_01std_1_1array_3_01Type_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1map_3_01Key_00_01Value_00_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::map&lt; Key, Value, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::map</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1map_3_01Key_00_01Value_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__map_3_01Key_00_01Value_00_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::unordered_map&lt; Key, Value, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::unordered_map</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__map_3_01Key_00_01Value_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1set_3_01Key_00_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::set&lt; Key, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::set</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1set_3_01Key_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__set_3_01Key_00_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::unordered_set&lt; Key, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::unordered_set</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__set_3_01Key_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__ctx.html">meta_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque container for a meta context.  <a href="structentt_1_1meta__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__factory.html">meta_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta factory to be used for reflection purposes.  <a href="structentt_1_1meta__factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__factory_3_01Type_00_01Spec_8_8_8_01_4.html">meta_factory&lt; Type, Spec... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended meta factory to be used for reflection purposes.  <a href="structentt_1_1meta__factory_3_01Type_00_01Spec_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__factory_3_01Type_01_4.html">meta_factory&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic meta factory to be used for reflection purposes.  <a href="structentt_1_1meta__factory_3_01Type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__sequence__container.html">meta_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy object for sequence containers.  <a href="classentt_1_1meta__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__associative__container.html">meta_associative_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy object for associative containers.  <a href="classentt_1_1meta__associative__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__any.html">meta_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for values of any type.  <a href="classentt_1_1meta__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque pointers to instances of any type.  <a href="structentt_1_1meta__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__prop.html">meta_prop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for properties of any type.  <a href="structentt_1_1meta__prop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__ctor.html">meta_ctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for constructors.  <a href="structentt_1_1meta__ctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__data.html">meta_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for data members.  <a href="structentt_1_1meta__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__func.html">meta_func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for member functions.  <a href="structentt_1_1meta__func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__type.html">meta_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for types.  <a href="classentt_1_1meta__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01Type_01_5_01_4.html">is_meta_pointer_like&lt; Type * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes plain pointers pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01Type_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01Type_07_5_08_0fN_0e_4.html">is_meta_pointer_like&lt; Type(*)[N]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization used to reject pointers to arrays.  <a href="structentt_1_1is__meta__pointer__like_3_01Type_07_5_08_0fN_0e_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01std_1_1shared__ptr_3_01Type_01_4_01_4.html">is_meta_pointer_like&lt; std::shared_ptr&lt; Type &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <code>std::shared_ptr</code>s of any type pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01std_1_1shared__ptr_3_01Type_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01std_1_1unique__ptr_3_01Type_00_01Args_8_8_8_01_4_01_4.html">is_meta_pointer_like&lt; std::unique_ptr&lt; Type, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <code>std::unique_ptr</code>s of any type pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01std_1_1unique__ptr_3_01Type_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__ref__t.html">as_ref_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as ref</em> policy.  <a href="structentt_1_1as__ref__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__cref__t.html">as_cref_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as cref</em> policy.  <a href="structentt_1_1as__cref__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__is__t.html">as_is_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as-is</em> policy.  <a href="structentt_1_1as__is__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__void__t.html">as_void_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as void</em> policy.  <a href="structentt_1_1as__void__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__range.html">meta_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterable range to use to iterate all types of meta objects.  <a href="classentt_1_1meta__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__class__template__tag.html">meta_class_template_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate class templates.  <a href="structentt_1_1meta__class__template__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__template__traits_3_01Clazz_3_01Args_8_8_8_01_4_01_4.html">meta_template_traits&lt; Clazz&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose traits class for generating meta template information.  <a href="structentt_1_1meta__template__traits_3_01Clazz_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__template__traits.html">meta_template_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta template information.  <a href="structentt_1_1meta__template__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits.html">meta_sequence_container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta sequence containers.  <a href="structentt_1_1meta__sequence__container__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits.html">meta_associative_container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta associative containers.  <a href="structentt_1_1meta__associative__container__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__key__only__meta__associative__container.html">is_key_only_meta_associative_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a meta associative container claims to wrap a key-only type, false otherwise.  <a href="structentt_1_1is__key__only__meta__associative__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__key__only__meta__associative__container_3_01Type_00_01std_1_1void__t_3_01typen08c4aa5308e52cbb686af55767e67d40.html">is_key_only_meta_associative_container&lt; Type, std::void_t&lt; typename meta_associative_container_traits&lt; Type &gt;::type::mapped_type &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a meta associative container claims to wrap a key-only type, false otherwise.  <a href="structentt_1_1is__key__only__meta__associative__container_3_01Type_00_01std_1_1void__t_3_01typen08c4aa5308e52cbb686af55767e67d40.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is a pointer-like type from the point of view of the meta system, false otherwise.  <a href="structentt_1_1is__meta__pointer__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01const_01Type_01_4.html">is_meta_pointer_like&lt; const Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization to ensure that const pointer-like types are also accepted.  <a href="structentt_1_1is__meta__pointer__like_3_01const_01Type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor.html">meta_function_descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1meta__function__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_01const_01_4.html">meta_function_descriptor&lt; Type, Ret(Class::*)(Args...) const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_01const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_4.html">meta_function_descriptor&lt; Type, Ret(Class::*)(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07Args_8_8_8_08_4.html">meta_function_descriptor&lt; Type, Ret(*)(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function helper.  <a href="classentt_1_1meta__function__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__poly.html">basic_poly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static polymorphism made simple and within everyone's reach.  <a href="classentt_1_1basic__poly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1poly__inspector.html">poly_inspector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspector class used to infer the type of the virtual table.  <a href="structentt_1_1poly__inspector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1poly__vtable.html">poly_vtable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static virtual table factory.  <a href="classentt_1_1poly__vtable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1poly__base.html">poly_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poly base class used to inject functionalities into concepts.  <a href="structentt_1_1poly__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1process.html">process</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for processes.  <a href="classentt_1_1process.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1process__adaptor.html">process_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor for lambdas and functors to turn them into processes.  <a href="structentt_1_1process__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1scheduler.html">scheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooperative scheduler for processes.  <a href="classentt_1_1scheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1resource__cache.html">resource_cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple cache for resources of a given type.  <a href="structentt_1_1resource__cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1resource__handle.html">resource_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared resource handle.  <a href="classentt_1_1resource__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1resource__loader.html">resource_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for resource loaders.  <a href="classentt_1_1resource__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to wrap a function or a member of a specified type.  <a href="structentt_1_1connect__arg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1delegate.html">delegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic delegate implementation.  <a href="classentt_1_1delegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1delegate_3_01Ret_07Args_8_8_8_08_4.html">delegate&lt; Ret(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to use to send around functions and members.  <a href="classentt_1_1delegate_3_01Ret_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1dispatcher.html">dispatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic dispatcher implementation.  <a href="classentt_1_1dispatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1emitter.html">emitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose event emitter.  <a href="classentt_1_1emitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sink.html">sink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink class.  <a href="classentt_1_1sink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh.html">sigh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmanaged signal handler.  <a href="classentt_1_1sigh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh_3_01Ret_07Args_8_8_8_08_4.html">sigh&lt; Ret(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmanaged signal handler.  <a href="classentt_1_1sigh_3_01Ret_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1connection.html">connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection class.  <a href="classentt_1_1connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1scoped__connection.html">scoped_connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scoped connection class.  <a href="structentt_1_1scoped__connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sink_3_01Ret_07Args_8_8_8_08_4.html">sink&lt; Ret(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink class.  <a href="classentt_1_1sink_3_01Ret_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a13e040e7b38a8f86d1ab2f096f37b627"><td class="memItemLeft" align="right" valign="top"><a id="a13e040e7b38a8f86d1ab2f096f37b627"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> = std::uint32_t</td></tr>
<tr class="memdesc:a13e040e7b38a8f86d1ab2f096f37b627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for type identifiers. <br /></td></tr>
<tr class="separator:a13e040e7b38a8f86d1ab2f096f37b627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4846741b8f485584c196304f588b94ad"><td class="memItemLeft" align="right" valign="top"><a id="a4846741b8f485584c196304f588b94ad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4846741b8f485584c196304f588b94ad">any</a> = <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt;&gt;</td></tr>
<tr class="memdesc:a4846741b8f485584c196304f588b94ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a4846741b8f485584c196304f588b94ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9dd22ce26cd7913a294b3fd520649b"><td class="memItemLeft" align="right" valign="top"><a id="a8f9dd22ce26cd7913a294b3fd520649b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">hashed_string</a> = <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a8f9dd22ce26cd7913a294b3fd520649b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases for common character types. <br /></td></tr>
<tr class="separator:a8f9dd22ce26cd7913a294b3fd520649b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2768719b1f5967caf5836b2656d0ed6"><td class="memItemLeft" align="right" valign="top"><a id="af2768719b1f5967caf5836b2656d0ed6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">hashed_wstring</a> = <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; wchar_t &gt;</td></tr>
<tr class="memdesc:af2768719b1f5967caf5836b2656d0ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases for common character types. <br /></td></tr>
<tr class="separator:af2768719b1f5967caf5836b2656d0ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a09f6bd6b4aebc03df720e7e69fdc6643">type_identity_t</a> = typename <a class="el" href="structentt_1_1type__identity.html">type_identity</a>&lt; Type &gt;::type</td></tr>
<tr class="memdesc:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a09f6bd6b4aebc03df720e7e69fdc6643">More...</a><br /></td></tr>
<tr class="separator:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a837a49598350009f463e37c86d322"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename &gt; </td></tr>
<tr class="memitem:a61a837a49598350009f463e37c86d322"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a61a837a49598350009f463e37c86d322">unpack_as_t</a> = Type</td></tr>
<tr class="memdesc:a61a837a49598350009f463e37c86d322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using declaration to be used to <em>repeat</em> the same type a number of times equal to the size of a given parameter pack.  <a href="namespaceentt.html#a61a837a49598350009f463e37c86d322">More...</a><br /></td></tr>
<tr class="separator:a61a837a49598350009f463e37c86d322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9fd5898acf13553bbcf14b99159f4d"><td class="memTemplParams" colspan="2">template&lt;auto Value&gt; </td></tr>
<tr class="memitem:a0d9fd5898acf13553bbcf14b99159f4d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">integral_constant</a> = std::integral_constant&lt; decltype(Value), Value &gt;</td></tr>
<tr class="memdesc:a0d9fd5898acf13553bbcf14b99159f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a static constant.  <a href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">More...</a><br /></td></tr>
<tr class="separator:a0d9fd5898acf13553bbcf14b99159f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="memTemplParams" colspan="2">template&lt;id_type Value&gt; </td></tr>
<tr class="memitem:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a9f7bb8c357f08a01ad9c8dab0ea40c1c">tag</a> = <a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">integral_constant</a>&lt; Value &gt;</td></tr>
<tr class="memdesc:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template to facilitate the creation of named values.  <a href="namespaceentt.html#a9f7bb8c357f08a01ad9c8dab0ea40c1c">More...</a><br /></td></tr>
<tr class="separator:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac839c1a03dba2436791d0056d6d0d1b6"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename List &gt; </td></tr>
<tr class="memitem:ac839c1a03dba2436791d0056d6d0d1b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac839c1a03dba2436791d0056d6d0d1b6">type_list_element_t</a> = typename <a class="el" href="structentt_1_1type__list__element.html">type_list_element</a>&lt; Index, List &gt;::type</td></tr>
<tr class="memdesc:ac839c1a03dba2436791d0056d6d0d1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#ac839c1a03dba2436791d0056d6d0d1b6">More...</a><br /></td></tr>
<tr class="separator:ac839c1a03dba2436791d0056d6d0d1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546467a3662e9a915d5d519ad565e801"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:a546467a3662e9a915d5d519ad565e801"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">type_list_cat_t</a> = typename <a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a>&lt; List... &gt;::type</td></tr>
<tr class="memdesc:a546467a3662e9a915d5d519ad565e801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">More...</a><br /></td></tr>
<tr class="separator:a546467a3662e9a915d5d519ad565e801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a277a6037279d65cd3874b46ec7166"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a75a277a6037279d65cd3874b46ec7166"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">type_list_unique_t</a> = typename <a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a>&lt; Type &gt;::type</td></tr>
<tr class="memdesc:a75a277a6037279d65cd3874b46ec7166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">More...</a><br /></td></tr>
<tr class="separator:a75a277a6037279d65cd3874b46ec7166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2992fc009cb3199b0ef9a86bed2285c"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:af2992fc009cb3199b0ef9a86bed2285c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af2992fc009cb3199b0ef9a86bed2285c">type_list_diff_t</a> = typename <a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a>&lt; List... &gt;::type</td></tr>
<tr class="memdesc:af2992fc009cb3199b0ef9a86bed2285c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#af2992fc009cb3199b0ef9a86bed2285c">More...</a><br /></td></tr>
<tr class="separator:af2992fc009cb3199b0ef9a86bed2285c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1344cc62598091397018354e6905e431"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:a1344cc62598091397018354e6905e431"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a1344cc62598091397018354e6905e431">value_list_cat_t</a> = typename <a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a>&lt; List... &gt;::type</td></tr>
<tr class="memdesc:a1344cc62598091397018354e6905e431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a1344cc62598091397018354e6905e431">More...</a><br /></td></tr>
<tr class="separator:a1344cc62598091397018354e6905e431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b051461867d3c5c97f77f10b662c26b"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a7b051461867d3c5c97f77f10b662c26b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">constness_as_t</a> = typename <a class="el" href="structentt_1_1constness__as.html">constness_as</a>&lt; To, From &gt;::type</td></tr>
<tr class="memdesc:a7b051461867d3c5c97f77f10b662c26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template to facilitate the transcription of the constness.  <a href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">More...</a><br /></td></tr>
<tr class="separator:a7b051461867d3c5c97f77f10b662c26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="memTemplParams" colspan="2">template&lt;typename Member &gt; </td></tr>
<tr class="memitem:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a49f19d031690e5ebfffd6c7a4f6bd364">member_class_t</a> = typename <a class="el" href="classentt_1_1member__class.html">member_class</a>&lt; Member &gt;::type</td></tr>
<tr class="memdesc:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a49f19d031690e5ebfffd6c7a4f6bd364">More...</a><br /></td></tr>
<tr class="separator:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27c0013e504d544508cdacc01170b68"><td class="memItemLeft" align="right" valign="top"><a id="ac27c0013e504d544508cdacc01170b68"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac27c0013e504d544508cdacc01170b68">sparse_set</a> = <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:ac27c0013e504d544508cdacc01170b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:ac27c0013e504d544508cdacc01170b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcedb8f29753130e2bf3185bca211f05"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abcedb8f29753130e2bf3185bca211f05"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abcedb8f29753130e2bf3185bca211f05">storage</a> = <a class="el" href="structentt_1_1basic__storage.html">basic_storage</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args... &gt;</td></tr>
<tr class="memdesc:abcedb8f29753130e2bf3185bca211f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#abcedb8f29753130e2bf3185bca211f05">More...</a><br /></td></tr>
<tr class="separator:abcedb8f29753130e2bf3185bca211f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292643317d1dbb13e45824f757bd1086"><td class="memItemLeft" align="right" valign="top"><a id="a292643317d1dbb13e45824f757bd1086"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a292643317d1dbb13e45824f757bd1086">registry</a> = <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a292643317d1dbb13e45824f757bd1086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a292643317d1dbb13e45824f757bd1086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dfbb2991c5a19c6e2578830f7e3eda"><td class="memItemLeft" align="right" valign="top"><a id="a48dfbb2991c5a19c6e2578830f7e3eda"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a48dfbb2991c5a19c6e2578830f7e3eda">observer</a> = <a class="el" href="classentt_1_1basic__observer.html">basic_observer</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a48dfbb2991c5a19c6e2578830f7e3eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a48dfbb2991c5a19c6e2578830f7e3eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5870a148e25a503557bdd47327c7a05a"><td class="memItemLeft" align="right" valign="top"><a id="a5870a148e25a503557bdd47327c7a05a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5870a148e25a503557bdd47327c7a05a">organizer</a> = <a class="el" href="classentt_1_1basic__organizer.html">basic_organizer</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a5870a148e25a503557bdd47327c7a05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a5870a148e25a503557bdd47327c7a05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0027b922894421f703102c374c234c"><td class="memItemLeft" align="right" valign="top"><a id="a5a0027b922894421f703102c374c234c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5a0027b922894421f703102c374c234c">handle</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a5a0027b922894421f703102c374c234c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a5a0027b922894421f703102c374c234c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ab1aae5e5786a3ebb3b9bf1c7e82bd"><td class="memItemLeft" align="right" valign="top"><a id="a54ab1aae5e5786a3ebb3b9bf1c7e82bd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a54ab1aae5e5786a3ebb3b9bf1c7e82bd">const_handle</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; const <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a54ab1aae5e5786a3ebb3b9bf1c7e82bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a54ab1aae5e5786a3ebb3b9bf1c7e82bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5809ceb50ec17713e8690c20a79490"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aaa5809ceb50ec17713e8690c20a79490"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aaa5809ceb50ec17713e8690c20a79490">handle_view</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args... &gt;</td></tr>
<tr class="memdesc:aaa5809ceb50ec17713e8690c20a79490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#aaa5809ceb50ec17713e8690c20a79490">More...</a><br /></td></tr>
<tr class="separator:aaa5809ceb50ec17713e8690c20a79490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfeed27a790ac90eb5989da8a3ea860"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aedfeed27a790ac90eb5989da8a3ea860"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aedfeed27a790ac90eb5989da8a3ea860">const_handle_view</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; const <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args... &gt;</td></tr>
<tr class="memdesc:aedfeed27a790ac90eb5989da8a3ea860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#aedfeed27a790ac90eb5989da8a3ea860">More...</a><br /></td></tr>
<tr class="separator:aedfeed27a790ac90eb5989da8a3ea860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80012f9fa628920a3507ae947704d447"><td class="memItemLeft" align="right" valign="top"><a id="a80012f9fa628920a3507ae947704d447"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a80012f9fa628920a3507ae947704d447">snapshot</a> = <a class="el" href="classentt_1_1basic__snapshot.html">basic_snapshot</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a80012f9fa628920a3507ae947704d447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a80012f9fa628920a3507ae947704d447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e50fc296c4ea68183db332950b99f5"><td class="memItemLeft" align="right" valign="top"><a id="ae7e50fc296c4ea68183db332950b99f5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae7e50fc296c4ea68183db332950b99f5">snapshot_loader</a> = <a class="el" href="classentt_1_1basic__snapshot__loader.html">basic_snapshot_loader</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:ae7e50fc296c4ea68183db332950b99f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:ae7e50fc296c4ea68183db332950b99f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b5b489846f6f2a5d143db2b4aea5d0"><td class="memItemLeft" align="right" valign="top"><a id="a37b5b489846f6f2a5d143db2b4aea5d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a37b5b489846f6f2a5d143db2b4aea5d0">continuous_loader</a> = <a class="el" href="classentt_1_1basic__continuous__loader.html">basic_continuous_loader</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a37b5b489846f6f2a5d143db2b4aea5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a37b5b489846f6f2a5d143db2b4aea5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5a93cf82f9378248fe6385376cd943"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acc5a93cf82f9378248fe6385376cd943"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a> = <a class="el" href="structentt_1_1basic__view.html">basic_view</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args... &gt;</td></tr>
<tr class="memdesc:acc5a93cf82f9378248fe6385376cd943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">More...</a><br /></td></tr>
<tr class="separator:acc5a93cf82f9378248fe6385376cd943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d470a55d982d87388e899c322e9ddc"><td class="memItemLeft" align="right" valign="top"><a id="a85d470a55d982d87388e899c322e9ddc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a85d470a55d982d87388e899c322e9ddc">runtime_view</a> = <a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a85d470a55d982d87388e899c322e9ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a85d470a55d982d87388e899c322e9ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2628e82fa8042f75d817c58fc09c7aaf"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2628e82fa8042f75d817c58fc09c7aaf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2628e82fa8042f75d817c58fc09c7aaf">group</a> = <a class="el" href="classentt_1_1basic__group.html">basic_group</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args... &gt;</td></tr>
<tr class="memdesc:a2628e82fa8042f75d817c58fc09c7aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a2628e82fa8042f75d817c58fc09c7aaf">More...</a><br /></td></tr>
<tr class="separator:a2628e82fa8042f75d817c58fc09c7aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692beabf853ee0f9dc68beab816a6b27"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Candidate &gt; </td></tr>
<tr class="memitem:a692beabf853ee0f9dc68beab816a6b27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a692beabf853ee0f9dc68beab816a6b27">meta_function_helper_t</a> = typename <a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a>&lt; Type, Candidate &gt;::type</td></tr>
<tr class="memdesc:a692beabf853ee0f9dc68beab816a6b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a692beabf853ee0f9dc68beab816a6b27">More...</a><br /></td></tr>
<tr class="separator:a692beabf853ee0f9dc68beab816a6b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3d1f1d0e83ad8f124155c9e511c2cd"><td class="memTemplParams" colspan="2">template&lt;typename Concept &gt; </td></tr>
<tr class="memitem:aad3d1f1d0e83ad8f124155c9e511c2cd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aad3d1f1d0e83ad8f124155c9e511c2cd">poly</a> = <a class="el" href="classentt_1_1basic__poly.html">basic_poly</a>&lt; Concept, sizeof(double[2])&gt;</td></tr>
<tr class="memdesc:aad3d1f1d0e83ad8f124155c9e511c2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#aad3d1f1d0e83ad8f124155c9e511c2cd">More...</a><br /></td></tr>
<tr class="separator:aad3d1f1d0e83ad8f124155c9e511c2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0b54e231d069e8a231e14b223388808a"><td class="memItemLeft" align="right" valign="top"><a id="a0b54e231d069e8a231e14b223388808a"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> : id_type </td></tr>
<tr class="memdesc:a0b54e231d069e8a231e14b223388808a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default entity identifier. <br /></td></tr>
<tr class="separator:a0b54e231d069e8a231e14b223388808a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4d0fa77fae26e7c01793990996c581"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a> : std::uint8_t { <a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581a8223d1ccb16b6dd0b19fe9c6fdb13708">swap_and_pop</a> = 0u
, <a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581aa49f99ae99ae9daddd1fb79b73d2db28">in_place</a> = 1u
 }</td></tr>
<tr class="memdesc:abc4d0fa77fae26e7c01793990996c581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse set deletion policy.  <a href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">More...</a><br /></td></tr>
<tr class="separator:abc4d0fa77fae26e7c01793990996c581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae38ac5bc7b9097ec21eb1058db206cff"><td class="memTemplParams" colspan="2">template&lt;std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:ae38ac5bc7b9097ec21eb1058db206cff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae38ac5bc7b9097ec21eb1058db206cff">operator!=</a> (const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae38ac5bc7b9097ec21eb1058db206cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two wrappers differ in their content.  <a href="namespaceentt.html#ae38ac5bc7b9097ec21eb1058db206cff">More...</a><br /></td></tr>
<tr class="separator:ae38ac5bc7b9097ec21eb1058db206cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2364ab41cab0fccd92cdaaf8779581cb"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:a2364ab41cab0fccd92cdaaf8779581cb"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2364ab41cab0fccd92cdaaf8779581cb">any_cast</a> (const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;data)</td></tr>
<tr class="memdesc:a2364ab41cab0fccd92cdaaf8779581cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#a2364ab41cab0fccd92cdaaf8779581cb">More...</a><br /></td></tr>
<tr class="separator:a2364ab41cab0fccd92cdaaf8779581cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c210bb2e08d184415f5c5680d87d74e"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:a7c210bb2e08d184415f5c5680d87d74e"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7c210bb2e08d184415f5c5680d87d74e">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;data)</td></tr>
<tr class="memdesc:a7c210bb2e08d184415f5c5680d87d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#a7c210bb2e08d184415f5c5680d87d74e">More...</a><br /></td></tr>
<tr class="separator:a7c210bb2e08d184415f5c5680d87d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ade9ac7c0844a7c154287ca96ceba08"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:a1ade9ac7c0844a7c154287ca96ceba08"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a1ade9ac7c0844a7c154287ca96ceba08">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&amp;data)</td></tr>
<tr class="memdesc:a1ade9ac7c0844a7c154287ca96ceba08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#a1ade9ac7c0844a7c154287ca96ceba08">More...</a><br /></td></tr>
<tr class="separator:a1ade9ac7c0844a7c154287ca96ceba08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf3e0080cf2091703718dcbe558171b"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:aeaf3e0080cf2091703718dcbe558171b"><td class="memTemplItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aeaf3e0080cf2091703718dcbe558171b">any_cast</a> (const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *data)</td></tr>
<tr class="memdesc:aeaf3e0080cf2091703718dcbe558171b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#aeaf3e0080cf2091703718dcbe558171b">More...</a><br /></td></tr>
<tr class="separator:aeaf3e0080cf2091703718dcbe558171b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53c0786eb32685bbbfc6a2b9806338b"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:ac53c0786eb32685bbbfc6a2b9806338b"><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac53c0786eb32685bbbfc6a2b9806338b">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *data)</td></tr>
<tr class="memdesc:ac53c0786eb32685bbbfc6a2b9806338b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#ac53c0786eb32685bbbfc6a2b9806338b">More...</a><br /></td></tr>
<tr class="separator:ac53c0786eb32685bbbfc6a2b9806338b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd78292ee5137d33a4635bd55e99bf7e"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename... Args&gt; </td></tr>
<tr class="memitem:abd78292ee5137d33a4635bd55e99bf7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abd78292ee5137d33a4635bd55e99bf7e">make_any</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abd78292ee5137d33a4635bd55e99bf7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a wrapper from a given type, passing it all arguments.  <a href="namespaceentt.html#abd78292ee5137d33a4635bd55e99bf7e">More...</a><br /></td></tr>
<tr class="separator:abd78292ee5137d33a4635bd55e99bf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810f66c2c91deba50f96cae9119f2feb"><td class="memTemplParams" colspan="2">template&lt;std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename Type &gt; </td></tr>
<tr class="memitem:a810f66c2c91deba50f96cae9119f2feb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a810f66c2c91deba50f96cae9119f2feb">forward_as_any</a> (Type &amp;&amp;value)</td></tr>
<tr class="memdesc:a810f66c2c91deba50f96cae9119f2feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards its argument and avoids copies for lvalue references.  <a href="namespaceentt.html#a810f66c2c91deba50f96cae9119f2feb">More...</a><br /></td></tr>
<tr class="separator:a810f66c2c91deba50f96cae9119f2feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa97361ef962166a4fc51a582d7c6392"><td class="memTemplParams" colspan="2">template&lt;typename Char , std::size_t N&gt; </td></tr>
<tr class="memitem:aaa97361ef962166a4fc51a582d7c6392"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aaa97361ef962166a4fc51a582d7c6392">basic_hashed_string</a> (const Char(&amp;str)[N]) -&gt; <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt;</td></tr>
<tr class="memdesc:aaa97361ef962166a4fc51a582d7c6392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#aaa97361ef962166a4fc51a582d7c6392">More...</a><br /></td></tr>
<tr class="separator:aaa97361ef962166a4fc51a582d7c6392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac200eb460760246368bb737dc434c0eb"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:ac200eb460760246368bb737dc434c0eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac200eb460760246368bb737dc434c0eb">operator!=</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac200eb460760246368bb737dc434c0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#ac200eb460760246368bb737dc434c0eb">More...</a><br /></td></tr>
<tr class="separator:ac200eb460760246368bb737dc434c0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556190d147a6a92fc16bbf31bd4b263a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">entt::hashed_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a556190d147a6a92fc16bbf31bd4b263a">operator&quot;&quot;_hs</a> (const char *str, std::size_t)</td></tr>
<tr class="memdesc:a556190d147a6a92fc16bbf31bd4b263a"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined literal for hashed strings.  <a href="namespaceentt.html#a556190d147a6a92fc16bbf31bd4b263a">More...</a><br /></td></tr>
<tr class="separator:a556190d147a6a92fc16bbf31bd4b263a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226e03b3f52eb1bbce832ec53106bd6a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">entt::hashed_wstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a226e03b3f52eb1bbce832ec53106bd6a">operator&quot;&quot;_hws</a> (const wchar_t *str, std::size_t)</td></tr>
<tr class="memdesc:a226e03b3f52eb1bbce832ec53106bd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined literal for hashed wstrings.  <a href="namespaceentt.html#a226e03b3f52eb1bbce832ec53106bd6a">More...</a><br /></td></tr>
<tr class="separator:a226e03b3f52eb1bbce832ec53106bd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb63e4c764b340bf4d600807daa22921"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#afb63e4c764b340bf4d600807daa22921">operator!=</a> (const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;rhs)</td></tr>
<tr class="memdesc:afb63e4c764b340bf4d600807daa22921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two type info objects.  <a href="namespaceentt.html#afb63e4c764b340bf4d600807daa22921">More...</a><br /></td></tr>
<tr class="separator:afb63e4c764b340bf4d600807daa22921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f04d6b89000ab4a0f7aa9c49403734"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a39f04d6b89000ab4a0f7aa9c49403734"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1type__info.html">type_info</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a39f04d6b89000ab4a0f7aa9c49403734">type_id</a> ()</td></tr>
<tr class="memdesc:a39f04d6b89000ab4a0f7aa9c49403734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type info object for a given type.  <a href="namespaceentt.html#a39f04d6b89000ab4a0f7aa9c49403734">More...</a><br /></td></tr>
<tr class="separator:a39f04d6b89000ab4a0f7aa9c49403734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6e966c8af5b1452811aa55adbbdf47"><td class="memTemplParams" colspan="2">template&lt;typename... Type, typename... Other&gt; </td></tr>
<tr class="memitem:a6c6e966c8af5b1452811aa55adbbdf47"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type..., Other... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6c6e966c8af5b1452811aa55adbbdf47">operator+</a> (<a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type... &gt;, <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Other... &gt;)</td></tr>
<tr class="memdesc:a6c6e966c8af5b1452811aa55adbbdf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="namespaceentt.html#a6c6e966c8af5b1452811aa55adbbdf47">More...</a><br /></td></tr>
<tr class="separator:a6c6e966c8af5b1452811aa55adbbdf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc6dd5fb4d2bc92d9e5101b7b0bce1d"><td class="memTemplParams" colspan="2">template&lt;auto... Value, auto... Other&gt; </td></tr>
<tr class="memitem:aabc6dd5fb4d2bc92d9e5101b7b0bce1d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value..., Other... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aabc6dd5fb4d2bc92d9e5101b7b0bce1d">operator+</a> (<a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value... &gt;, <a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Other... &gt;)</td></tr>
<tr class="memdesc:aabc6dd5fb4d2bc92d9e5101b7b0bce1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="namespaceentt.html#aabc6dd5fb4d2bc92d9e5101b7b0bce1d">More...</a><br /></td></tr>
<tr class="separator:aabc6dd5fb4d2bc92d9e5101b7b0bce1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386a739051d9d37a5578785b77fc426b"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Class &gt; </td></tr>
<tr class="memitem:a386a739051d9d37a5578785b77fc426b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a386a739051d9d37a5578785b77fc426b">overload</a> (Type Class::*member)</td></tr>
<tr class="memdesc:a386a739051d9d37a5578785b77fc426b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant utility to disambiguate overloaded members of a class.  <a href="namespaceentt.html#a386a739051d9d37a5578785b77fc426b">More...</a><br /></td></tr>
<tr class="separator:a386a739051d9d37a5578785b77fc426b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ea6822ef21f52c732ba3baea450159"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ad4ea6822ef21f52c732ba3baea450159"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad4ea6822ef21f52c732ba3baea450159">overload</a> (Func *func)</td></tr>
<tr class="memdesc:ad4ea6822ef21f52c732ba3baea450159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant utility to disambiguate overloaded functions.  <a href="namespaceentt.html#ad4ea6822ef21f52c732ba3baea450159">More...</a><br /></td></tr>
<tr class="separator:ad4ea6822ef21f52c732ba3baea450159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eb67ac302229374c5fb623d529f5eb"><td class="memTemplParams" colspan="2">template&lt;class... Func&gt; </td></tr>
<tr class="memitem:a26eb67ac302229374c5fb623d529f5eb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a26eb67ac302229374c5fb623d529f5eb">overloaded</a> (Func...) -&gt; <a class="el" href="structentt_1_1overloaded.html">overloaded</a>&lt; Func... &gt;</td></tr>
<tr class="memdesc:a26eb67ac302229374c5fb623d529f5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a26eb67ac302229374c5fb623d529f5eb">More...</a><br /></td></tr>
<tr class="separator:a26eb67ac302229374c5fb623d529f5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d673d4f0014fabfd97bcaa3dedcb5c"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a32d673d4f0014fabfd97bcaa3dedcb5c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a32d673d4f0014fabfd97bcaa3dedcb5c">to_integral</a> (const Entity <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>)</td></tr>
<tr class="memdesc:a32d673d4f0014fabfd97bcaa3dedcb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an entity to its underlying type.  <a href="namespaceentt.html#a32d673d4f0014fabfd97bcaa3dedcb5c">More...</a><br /></td></tr>
<tr class="separator:a32d673d4f0014fabfd97bcaa3dedcb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6de691c4ec15d4a63ea8960563bbea0"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:af6de691c4ec15d4a63ea8960563bbea0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af6de691c4ec15d4a63ea8960563bbea0">operator==</a> (const Entity <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, const <a class="el" href="structentt_1_1null__t.html">null_t</a> other)</td></tr>
<tr class="memdesc:af6de691c4ec15d4a63ea8960563bbea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a null object and an entity identifier of any type.  <a href="namespaceentt.html#af6de691c4ec15d4a63ea8960563bbea0">More...</a><br /></td></tr>
<tr class="separator:af6de691c4ec15d4a63ea8960563bbea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6185f9faa3f9fa26ecb1b9a837016147"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a6185f9faa3f9fa26ecb1b9a837016147"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6185f9faa3f9fa26ecb1b9a837016147">operator!=</a> (const Entity <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, const <a class="el" href="structentt_1_1null__t.html">null_t</a> other)</td></tr>
<tr class="memdesc:a6185f9faa3f9fa26ecb1b9a837016147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a null object and an entity identifier of any type.  <a href="namespaceentt.html#a6185f9faa3f9fa26ecb1b9a837016147">More...</a><br /></td></tr>
<tr class="separator:a6185f9faa3f9fa26ecb1b9a837016147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f371da1ef604fa726a88e9733e5ee54"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a0f371da1ef604fa726a88e9733e5ee54"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0f371da1ef604fa726a88e9733e5ee54">operator==</a> (const Entity <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a> other)</td></tr>
<tr class="memdesc:a0f371da1ef604fa726a88e9733e5ee54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a tombstone object and an entity identifier of any type.  <a href="namespaceentt.html#a0f371da1ef604fa726a88e9733e5ee54">More...</a><br /></td></tr>
<tr class="separator:a0f371da1ef604fa726a88e9733e5ee54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39702a79d9ba6f5d7cb8668b0a7a1524"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a39702a79d9ba6f5d7cb8668b0a7a1524"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a39702a79d9ba6f5d7cb8668b0a7a1524">operator!=</a> (const Entity <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a> other)</td></tr>
<tr class="memdesc:a39702a79d9ba6f5d7cb8668b0a7a1524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a tombstone object and an entity identifier of any type.  <a href="namespaceentt.html#a39702a79d9ba6f5d7cb8668b0a7a1524">More...</a><br /></td></tr>
<tr class="separator:a39702a79d9ba6f5d7cb8668b0a7a1524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c51761e603d7ff1fefd41c026f19de3"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Other &gt; </td></tr>
<tr class="memitem:a6c51761e603d7ff1fefd41c026f19de3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6c51761e603d7ff1fefd41c026f19de3">operator!=</a> (const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Type &gt; &amp;lhs, const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Other &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6c51761e603d7ff1fefd41c026f19de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <a href="namespaceentt.html#a6c51761e603d7ff1fefd41c026f19de3">More...</a><br /></td></tr>
<tr class="separator:a6c51761e603d7ff1fefd41c026f19de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288ec07d4e87a28179d43b367ff11eab"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a288ec07d4e87a28179d43b367ff11eab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a288ec07d4e87a28179d43b367ff11eab">basic_handle</a> (<a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;, Entity) -&gt; <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Entity &gt;</td></tr>
<tr class="memdesc:a288ec07d4e87a28179d43b367ff11eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a288ec07d4e87a28179d43b367ff11eab">More...</a><br /></td></tr>
<tr class="separator:a288ec07d4e87a28179d43b367ff11eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de052205bafd99d67afde880b67a4e8"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a6de052205bafd99d67afde880b67a4e8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6de052205bafd99d67afde880b67a4e8">basic_handle</a> (const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;, Entity) -&gt; <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; const Entity &gt;</td></tr>
<tr class="memdesc:a6de052205bafd99d67afde880b67a4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a6de052205bafd99d67afde880b67a4e8">More...</a><br /></td></tr>
<tr class="separator:a6de052205bafd99d67afde880b67a4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0922fd2ea330d84a2e1b6f19e877aed"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:af0922fd2ea330d84a2e1b6f19e877aed"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af0922fd2ea330d84a2e1b6f19e877aed">as_view</a> (<a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) -&gt; <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; Entity &gt;</td></tr>
<tr class="memdesc:af0922fd2ea330d84a2e1b6f19e877aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#af0922fd2ea330d84a2e1b6f19e877aed">More...</a><br /></td></tr>
<tr class="separator:af0922fd2ea330d84a2e1b6f19e877aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4821869aa545da11205c90388fa2d08e"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a4821869aa545da11205c90388fa2d08e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4821869aa545da11205c90388fa2d08e">as_view</a> (const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) -&gt; <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; const Entity &gt;</td></tr>
<tr class="memdesc:a4821869aa545da11205c90388fa2d08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a4821869aa545da11205c90388fa2d08e">More...</a><br /></td></tr>
<tr class="separator:a4821869aa545da11205c90388fa2d08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcc1231f76478c7aa6f6ec9516cf045"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a4dcc1231f76478c7aa6f6ec9516cf045"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4dcc1231f76478c7aa6f6ec9516cf045">as_group</a> (<a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) -&gt; <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; Entity &gt;</td></tr>
<tr class="memdesc:a4dcc1231f76478c7aa6f6ec9516cf045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a4dcc1231f76478c7aa6f6ec9516cf045">More...</a><br /></td></tr>
<tr class="separator:a4dcc1231f76478c7aa6f6ec9516cf045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e62063b33b410e0a4bf1acc5b59596"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:ad6e62063b33b410e0a4bf1acc5b59596"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad6e62063b33b410e0a4bf1acc5b59596">as_group</a> (const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) -&gt; <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; const Entity &gt;</td></tr>
<tr class="memdesc:ad6e62063b33b410e0a4bf1acc5b59596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#ad6e62063b33b410e0a4bf1acc5b59596">More...</a><br /></td></tr>
<tr class="separator:ad6e62063b33b410e0a4bf1acc5b59596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa512a354fe328df6be5a92eb43cd4d69"><td class="memTemplParams" colspan="2">template&lt;auto Member, typename Entity  = entity&gt; </td></tr>
<tr class="memitem:aa512a354fe328df6be5a92eb43cd4d69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aa512a354fe328df6be5a92eb43cd4d69">invoke</a> (<a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;reg, const Entity entt)</td></tr>
<tr class="memdesc:aa512a354fe328df6be5a92eb43cd4d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to create a listener that directly invokes a member function.  <a href="namespaceentt.html#aa512a354fe328df6be5a92eb43cd4d69">More...</a><br /></td></tr>
<tr class="separator:aa512a354fe328df6be5a92eb43cd4d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81b68364d770429f343d703f415d12a"><td class="memTemplParams" colspan="2">template&lt;typename Entity , typename Component &gt; </td></tr>
<tr class="memitem:ae81b68364d770429f343d703f415d12a"><td class="memTemplItemLeft" align="right" valign="top">Entity&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae81b68364d770429f343d703f415d12a">to_entity</a> (const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;reg, const Component &amp;instance)</td></tr>
<tr class="memdesc:ae81b68364d770429f343d703f415d12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity associated with a given component.  <a href="namespaceentt.html#ae81b68364d770429f343d703f415d12a">More...</a><br /></td></tr>
<tr class="separator:ae81b68364d770429f343d703f415d12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9818c2f838cf5aa4c5ea335d6996eda0"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a9818c2f838cf5aa4c5ea335d6996eda0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a9818c2f838cf5aa4c5ea335d6996eda0">get_as_tuple</a> ([[maybe_unused]] Type &amp;container, [[maybe_unused]] const typename Type::entity_type entt)</td></tr>
<tr class="memdesc:a9818c2f838cf5aa4c5ea335d6996eda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element assigned to an entity from a storage, if any.  <a href="namespaceentt.html#a9818c2f838cf5aa4c5ea335d6996eda0">More...</a><br /></td></tr>
<tr class="separator:a9818c2f838cf5aa4c5ea335d6996eda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ba251f748ba853ef573f9b57ee5896"><td class="memTemplParams" colspan="2">template&lt;typename... Storage&gt; </td></tr>
<tr class="memitem:a28ba251f748ba853ef573f9b57ee5896"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a28ba251f748ba853ef573f9b57ee5896">basic_view</a> (<a class="el" href="structentt_1_1Storage.html">Storage</a> &amp;... <a class="el" href="namespaceentt.html#abcedb8f29753130e2bf3185bca211f05">storage</a>) -&gt; <a class="el" href="structentt_1_1basic__view.html">basic_view</a>&lt; std::common_type_t&lt; typename Storage::entity_type... &gt;, <a class="el" href="structentt_1_1exclude__t.html">entt::exclude_t</a>&lt;&gt;, <a class="el" href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">constness_as_t</a>&lt; typename Storage::value_type, <a class="el" href="structentt_1_1Storage.html">Storage</a> &gt;... &gt;</td></tr>
<tr class="memdesc:a28ba251f748ba853ef573f9b57ee5896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a28ba251f748ba853ef573f9b57ee5896">More...</a><br /></td></tr>
<tr class="separator:a28ba251f748ba853ef573f9b57ee5896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0174aa3efe81fb881deb652d4b6d233"><td class="memTemplParams" colspan="2">template&lt;typename Entity , typename... ELhs, typename... CLhs, typename... ERhs, typename... CRhs&gt; </td></tr>
<tr class="memitem:af0174aa3efe81fb881deb652d4b6d233"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af0174aa3efe81fb881deb652d4b6d233">operator|</a> (const <a class="el" href="structentt_1_1basic__view.html">basic_view</a>&lt; Entity, <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; ELhs... &gt;, CLhs... &gt; &amp;lhs, const <a class="el" href="structentt_1_1basic__view.html">basic_view</a>&lt; Entity, <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; ERhs... &gt;, CRhs... &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af0174aa3efe81fb881deb652d4b6d233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two views in a <em>more specific</em> one.  <a href="namespaceentt.html#af0174aa3efe81fb881deb652d4b6d233">More...</a><br /></td></tr>
<tr class="separator:af0174aa3efe81fb881deb652d4b6d233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab7b51802157a98106f238335fa7503"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a2ab7b51802157a98106f238335fa7503"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2ab7b51802157a98106f238335fa7503">dereference_meta_pointer_like</a> (const Type &amp;value)</td></tr>
<tr class="memdesc:a2ab7b51802157a98106f238335fa7503"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL based lookup function for dereferencing meta pointer-like types.  <a href="namespaceentt.html#a2ab7b51802157a98106f238335fa7503">More...</a><br /></td></tr>
<tr class="separator:a2ab7b51802157a98106f238335fa7503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae5a1bdbb378be2ae0556ff437cf513"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a3ae5a1bdbb378be2ae0556ff437cf513"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3ae5a1bdbb378be2ae0556ff437cf513">meta</a> ()</td></tr>
<tr class="memdesc:a3ae5a1bdbb378be2ae0556ff437cf513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to use for reflection.  <a href="namespaceentt.html#a3ae5a1bdbb378be2ae0556ff437cf513">More...</a><br /></td></tr>
<tr class="separator:a3ae5a1bdbb378be2ae0556ff437cf513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845d4ef2c448264153449c92157a0359"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a845d4ef2c448264153449c92157a0359">operator!=</a> (const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;lhs, const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;rhs)</td></tr>
<tr class="memdesc:a845d4ef2c448264153449c92157a0359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two wrappers differ in their content.  <a href="namespaceentt.html#a845d4ef2c448264153449c92157a0359">More...</a><br /></td></tr>
<tr class="separator:a845d4ef2c448264153449c92157a0359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfc8a0eecdf6230c2966786f8965589"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Args&gt; </td></tr>
<tr class="memitem:afdfc8a0eecdf6230c2966786f8965589"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#afdfc8a0eecdf6230c2966786f8965589">make_meta</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:afdfc8a0eecdf6230c2966786f8965589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a wrapper from a given type, passing it all arguments.  <a href="namespaceentt.html#afdfc8a0eecdf6230c2966786f8965589">More...</a><br /></td></tr>
<tr class="separator:afdfc8a0eecdf6230c2966786f8965589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c7a5a8ac08bc879abdaa00f920a996"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a77c7a5a8ac08bc879abdaa00f920a996"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a77c7a5a8ac08bc879abdaa00f920a996">forward_as_meta</a> (Type &amp;&amp;value)</td></tr>
<tr class="memdesc:a77c7a5a8ac08bc879abdaa00f920a996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards its argument and avoids copies for lvalue references.  <a href="namespaceentt.html#a77c7a5a8ac08bc879abdaa00f920a996">More...</a><br /></td></tr>
<tr class="separator:a77c7a5a8ac08bc879abdaa00f920a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ebb219547c34209a94c9eb6d26eda1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a04ebb219547c34209a94c9eb6d26eda1">operator!=</a> (const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;lhs, const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;rhs)</td></tr>
<tr class="memdesc:a04ebb219547c34209a94c9eb6d26eda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two objects refer to the same type.  <a href="namespaceentt.html#a04ebb219547c34209a94c9eb6d26eda1">More...</a><br /></td></tr>
<tr class="separator:a04ebb219547c34209a94c9eb6d26eda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b62be0d39676cb86f2aefefa890b198"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a0b62be0d39676cb86f2aefefa890b198"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0b62be0d39676cb86f2aefefa890b198">resolve</a> ()</td></tr>
<tr class="memdesc:a0b62be0d39676cb86f2aefefa890b198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type.  <a href="namespaceentt.html#a0b62be0d39676cb86f2aefefa890b198">More...</a><br /></td></tr>
<tr class="separator:a0b62be0d39676cb86f2aefefa890b198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1915a651e7ce55938a09269c3d9c98e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a1915a651e7ce55938a09269c3d9c98e4">resolve</a> (const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> id)</td></tr>
<tr class="memdesc:a1915a651e7ce55938a09269c3d9c98e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given identifier, if any.  <a href="namespaceentt.html#a1915a651e7ce55938a09269c3d9c98e4">More...</a><br /></td></tr>
<tr class="separator:a1915a651e7ce55938a09269c3d9c98e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a6e0b744ec6398f4e43811c59cced1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aa1a6e0b744ec6398f4e43811c59cced1">resolve</a> (const <a class="el" href="classentt_1_1type__info.html">type_info</a> info)</td></tr>
<tr class="memdesc:aa1a6e0b744ec6398f4e43811c59cced1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type info object, if any.  <a href="namespaceentt.html#aa1a6e0b744ec6398f4e43811c59cced1">More...</a><br /></td></tr>
<tr class="separator:aa1a6e0b744ec6398f4e43811c59cced1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0861c2878957a89499b0ca0801f7eeff"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Args, std::size_t... Index&gt; </td></tr>
<tr class="memitem:a0861c2878957a89499b0ca0801f7eeff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0861c2878957a89499b0ca0801f7eeff">meta_construct</a> (<a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args, std::index_sequence&lt; Index... &gt;)</td></tr>
<tr class="memdesc:a0861c2878957a89499b0ca0801f7eeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance given a list of erased parameters, if possible.  <a href="namespaceentt.html#a0861c2878957a89499b0ca0801f7eeff">More...</a><br /></td></tr>
<tr class="separator:a0861c2878957a89499b0ca0801f7eeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe109e5134bae55cb519799acbed732"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Data&gt; </td></tr>
<tr class="memitem:adbe109e5134bae55cb519799acbed732"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#adbe109e5134bae55cb519799acbed732">meta_setter</a> ([[maybe_unused]] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, [[maybe_unused]] <a class="el" href="classentt_1_1meta__any.html">meta_any</a> value)</td></tr>
<tr class="memdesc:adbe109e5134bae55cb519799acbed732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of a given variable.  <a href="namespaceentt.html#adbe109e5134bae55cb519799acbed732">More...</a><br /></td></tr>
<tr class="separator:adbe109e5134bae55cb519799acbed732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddec8e1e99754cfbb7afa9ceb1a5aa0"><td class="memTemplParams" colspan="2">template&lt;typename Policy  = as_is_t, typename Type &gt; </td></tr>
<tr class="memitem:a3ddec8e1e99754cfbb7afa9ceb1a5aa0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3ddec8e1e99754cfbb7afa9ceb1a5aa0">meta_dispatch</a> (Type &amp;&amp;value)</td></tr>
<tr class="memdesc:a3ddec8e1e99754cfbb7afa9ceb1a5aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a value depending on the given policy.  <a href="namespaceentt.html#a3ddec8e1e99754cfbb7afa9ceb1a5aa0">More...</a><br /></td></tr>
<tr class="separator:a3ddec8e1e99754cfbb7afa9ceb1a5aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe26d091f302630470004fe314a6a8d"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Data, typename Policy  = as_is_t&gt; </td></tr>
<tr class="memitem:a3fe26d091f302630470004fe314a6a8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3fe26d091f302630470004fe314a6a8d">meta_getter</a> ([[maybe_unused]] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance)</td></tr>
<tr class="memdesc:a3fe26d091f302630470004fe314a6a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a given variable.  <a href="namespaceentt.html#a3fe26d091f302630470004fe314a6a8d">More...</a><br /></td></tr>
<tr class="separator:a3fe26d091f302630470004fe314a6a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2d1a6ef198fb53abcb0fe808f0bdac"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Candidate, typename Policy  = as_is_t, std::size_t... Index&gt; </td></tr>
<tr class="memitem:a7a2d1a6ef198fb53abcb0fe808f0bdac"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_invocable_v&lt; decltype(Candidate)&gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7a2d1a6ef198fb53abcb0fe808f0bdac">meta_invoke</a> ([[maybe_unused]] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *args, std::index_sequence&lt; Index... &gt;)</td></tr>
<tr class="memdesc:a7a2d1a6ef198fb53abcb0fe808f0bdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a function given a list of erased parameters, if possible.  <a href="namespaceentt.html#a7a2d1a6ef198fb53abcb0fe808f0bdac">More...</a><br /></td></tr>
<tr class="separator:a7a2d1a6ef198fb53abcb0fe808f0bdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050e4320cd8ce648b9b9243817ac742a"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Candidate, typename Policy  = as_is_t, std::size_t... Index&gt; </td></tr>
<tr class="memitem:a050e4320cd8ce648b9b9243817ac742a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_invocable_v&lt; decltype(Candidate)&gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a050e4320cd8ce648b9b9243817ac742a">meta_invoke</a> (<a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *, std::index_sequence&lt; Index... &gt;)</td></tr>
<tr class="memdesc:a050e4320cd8ce648b9b9243817ac742a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a function given a list of erased parameters, if possible.  <a href="namespaceentt.html#a050e4320cd8ce648b9b9243817ac742a">More...</a><br /></td></tr>
<tr class="separator:a050e4320cd8ce648b9b9243817ac742a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaec3476b637deea0ca553427175664f"><td class="memTemplParams" colspan="2">template&lt;auto Member, typename Poly , typename... Args&gt; </td></tr>
<tr class="memitem:abaec3476b637deea0ca553427175664f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abaec3476b637deea0ca553427175664f">poly_call</a> (Poly &amp;&amp;self, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abaec3476b637deea0ca553427175664f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for calling <code><a class="el" href="structentt_1_1poly__base.html" title="Poly base class used to inject functionalities into concepts.">poly_base</a>&lt;Type&gt;<a class="el" href="namespaceentt.html#aa512a354fe328df6be5a92eb43cd4d69" title="Helper to create a listener that directly invokes a member function.">invoke</a></code>.  <a href="namespaceentt.html#abaec3476b637deea0ca553427175664f">More...</a><br /></td></tr>
<tr class="separator:abaec3476b637deea0ca553427175664f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8711ef7a24e5329d7cbd0d05136874e"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename... Args&gt; </td></tr>
<tr class="memitem:ac8711ef7a24e5329d7cbd0d05136874e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac8711ef7a24e5329d7cbd0d05136874e">operator!=</a> (const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;lhs, const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac8711ef7a24e5329d7cbd0d05136874e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two delegates.  <a href="namespaceentt.html#ac8711ef7a24e5329d7cbd0d05136874e">More...</a><br /></td></tr>
<tr class="separator:ac8711ef7a24e5329d7cbd0d05136874e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8907a3a72cd2da043d81f6fd50487a"><td class="memTemplParams" colspan="2">template&lt;auto Candidate&gt; </td></tr>
<tr class="memitem:a7c8907a3a72cd2da043d81f6fd50487a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7c8907a3a72cd2da043d81f6fd50487a">delegate</a> (<a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;) -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate)&gt;&gt;&gt;</td></tr>
<tr class="memdesc:a7c8907a3a72cd2da043d81f6fd50487a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a7c8907a3a72cd2da043d81f6fd50487a">More...</a><br /></td></tr>
<tr class="separator:a7c8907a3a72cd2da043d81f6fd50487a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ba791dbcdecb9415a5c11fe69c4b1c"><td class="memTemplParams" colspan="2">template&lt;auto Candidate, typename Type &gt; </td></tr>
<tr class="memitem:a39ba791dbcdecb9415a5c11fe69c4b1c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a39ba791dbcdecb9415a5c11fe69c4b1c">delegate</a> (<a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;, Type &amp;&amp;) -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate), Type &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a39ba791dbcdecb9415a5c11fe69c4b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a39ba791dbcdecb9415a5c11fe69c4b1c">More...</a><br /></td></tr>
<tr class="separator:a39ba791dbcdecb9415a5c11fe69c4b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba06006a862fa5dc613e8561ac4e92c"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename... Args&gt; </td></tr>
<tr class="memitem:aaba06006a862fa5dc613e8561ac4e92c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aaba06006a862fa5dc613e8561ac4e92c">delegate</a> (Ret(*)(const void *, Args...), const void *=nullptr) -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt;</td></tr>
<tr class="memdesc:aaba06006a862fa5dc613e8561ac4e92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#aaba06006a862fa5dc613e8561ac4e92c">More...</a><br /></td></tr>
<tr class="separator:aaba06006a862fa5dc613e8561ac4e92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c393cd14012db79a3bbabd816e46b3"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename... Args&gt; </td></tr>
<tr class="memitem:ad3c393cd14012db79a3bbabd816e46b3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad3c393cd14012db79a3bbabd816e46b3">sink</a> (<a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...)&gt; &amp;) -&gt; <a class="el" href="classentt_1_1sink.html">sink</a>&lt; Ret(Args...)&gt;</td></tr>
<tr class="memdesc:ad3c393cd14012db79a3bbabd816e46b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#ad3c393cd14012db79a3bbabd816e46b3">More...</a><br /></td></tr>
<tr class="separator:ad3c393cd14012db79a3bbabd816e46b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memTemplParams" colspan="2">template&lt;id_type Value&gt; </td></tr>
<tr class="memitem:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structentt_1_1monostate.html">monostate</a>&lt; Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab43a13f7ee60bcb0d04a001f92b86fa2">monostate_v</a> = {}</td></tr>
<tr class="memdesc:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ab43a13f7ee60bcb0d04a001f92b86fa2">More...</a><br /></td></tr>
<tr class="separator:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089f75043b082abca3ea144bce44e9ae"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a089f75043b082abca3ea144bce44e9ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1choice__t.html">choice_t</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a089f75043b082abca3ea144bce44e9ae">choice</a> {}</td></tr>
<tr class="memdesc:a089f75043b082abca3ea144bce44e9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for the choice trick.  <a href="namespaceentt.html#a089f75043b082abca3ea144bce44e9ae">More...</a><br /></td></tr>
<tr class="separator:a089f75043b082abca3ea144bce44e9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a15f9a70cbdd5a64f897a012ab2b5834f">size_of_v</a> = <a class="el" href="structentt_1_1size__of.html">size_of</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a15f9a70cbdd5a64f897a012ab2b5834f">More...</a><br /></td></tr>
<tr class="separator:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447c782d9f4f5332dfd4dde6f03d4a4e"><td class="memTemplParams" colspan="2">template&lt;auto Value, typename &gt; </td></tr>
<tr class="memitem:a447c782d9f4f5332dfd4dde6f03d4a4e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a447c782d9f4f5332dfd4dde6f03d4a4e">unpack_as_v</a> = Value</td></tr>
<tr class="memdesc:a447c782d9f4f5332dfd4dde6f03d4a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template to be used to <em>repeat</em> the same value a number of times equal to the size of a given parameter pack.  <a href="namespaceentt.html#a447c782d9f4f5332dfd4dde6f03d4a4e">More...</a><br /></td></tr>
<tr class="separator:a447c782d9f4f5332dfd4dde6f03d4a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988ce063936d499bf2d69406c391fd5c"><td class="memTemplParams" colspan="2">template&lt;class List , typename Type &gt; </td></tr>
<tr class="memitem:a988ce063936d499bf2d69406c391fd5c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a988ce063936d499bf2d69406c391fd5c">type_list_contains_v</a> = <a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a>&lt;List, Type&gt;::value</td></tr>
<tr class="memdesc:a988ce063936d499bf2d69406c391fd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a988ce063936d499bf2d69406c391fd5c">More...</a><br /></td></tr>
<tr class="separator:a988ce063936d499bf2d69406c391fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbfb162708696f9c1497d61573b540f"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename List &gt; </td></tr>
<tr class="memitem:a4bbfb162708696f9c1497d61573b540f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4bbfb162708696f9c1497d61573b540f">value_list_element_v</a> = <a class="el" href="structentt_1_1value__list__element.html">value_list_element</a>&lt;Index, List&gt;::value</td></tr>
<tr class="memdesc:a4bbfb162708696f9c1497d61573b540f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a4bbfb162708696f9c1497d61573b540f">More...</a><br /></td></tr>
<tr class="separator:a4bbfb162708696f9c1497d61573b540f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068dd98a70c771935d2bf3dd96dbad6d"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a068dd98a70c771935d2bf3dd96dbad6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a068dd98a70c771935d2bf3dd96dbad6d">is_equality_comparable_v</a> = <a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a068dd98a70c771935d2bf3dd96dbad6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a068dd98a70c771935d2bf3dd96dbad6d">More...</a><br /></td></tr>
<tr class="separator:a068dd98a70c771935d2bf3dd96dbad6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f238620469de3ef2bafdb28fe4657ef"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename Args &gt; </td></tr>
<tr class="memitem:a4f238620469de3ef2bafdb28fe4657ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4f238620469de3ef2bafdb28fe4657ef">is_applicable_v</a> = <a class="el" href="structentt_1_1is__applicable.html">is_applicable</a>&lt;Func, Args&gt;::value</td></tr>
<tr class="memdesc:a4f238620469de3ef2bafdb28fe4657ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a4f238620469de3ef2bafdb28fe4657ef">More...</a><br /></td></tr>
<tr class="separator:a4f238620469de3ef2bafdb28fe4657ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae764716fab8c01b12d3e209004b62647"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Func , typename Args &gt; </td></tr>
<tr class="memitem:ae764716fab8c01b12d3e209004b62647"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae764716fab8c01b12d3e209004b62647">is_applicable_r_v</a> = <a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a>&lt;Ret, Func, Args&gt;::value</td></tr>
<tr class="memdesc:ae764716fab8c01b12d3e209004b62647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ae764716fab8c01b12d3e209004b62647">More...</a><br /></td></tr>
<tr class="separator:ae764716fab8c01b12d3e209004b62647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8a96fcc4bc8da9a2aa1cdb0bc15b75c8">is_complete_v</a> = <a class="el" href="structentt_1_1is__complete.html">is_complete</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a8a96fcc4bc8da9a2aa1cdb0bc15b75c8">More...</a><br /></td></tr>
<tr class="separator:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac133ddb24ec535a11baf3143d188d6"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a3ac133ddb24ec535a11baf3143d188d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3ac133ddb24ec535a11baf3143d188d6">is_iterator_v</a> = <a class="el" href="structentt_1_1is__iterator.html">is_iterator</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a3ac133ddb24ec535a11baf3143d188d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a3ac133ddb24ec535a11baf3143d188d6">More...</a><br /></td></tr>
<tr class="separator:a3ac133ddb24ec535a11baf3143d188d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4081aa5332fcb3367063eeba93918b8"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename It &gt; </td></tr>
<tr class="memitem:ac4081aa5332fcb3367063eeba93918b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac4081aa5332fcb3367063eeba93918b8">is_iterator_type_v</a> = <a class="el" href="structentt_1_1is__iterator__type.html">is_iterator_type</a>&lt;Type, It&gt;::value</td></tr>
<tr class="memdesc:ac4081aa5332fcb3367063eeba93918b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ac4081aa5332fcb3367063eeba93918b8">More...</a><br /></td></tr>
<tr class="separator:ac4081aa5332fcb3367063eeba93918b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0c0a1c1d953ea991591748744cdd8b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1null__t.html">null_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2f0c0a1c1d953ea991591748744cdd8b">null</a> {}</td></tr>
<tr class="memdesc:a2f0c0a1c1d953ea991591748744cdd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time constant for null entities.  <a href="namespaceentt.html#a2f0c0a1c1d953ea991591748744cdd8b">More...</a><br /></td></tr>
<tr class="separator:a2f0c0a1c1d953ea991591748744cdd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674269102fdfe3fd6d7766210a828862"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a674269102fdfe3fd6d7766210a828862">tombstone</a> {}</td></tr>
<tr class="memdesc:a674269102fdfe3fd6d7766210a828862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time constant for tombstone entities.  <a href="namespaceentt.html#a674269102fdfe3fd6d7766210a828862">More...</a><br /></td></tr>
<tr class="separator:a674269102fdfe3fd6d7766210a828862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8b073b774362fe800d9cce3542927a"><td class="memItemLeft" align="right" valign="top"><a id="aea8b073b774362fe800d9cce3542927a"></a>
constexpr <a class="el" href="structentt_1_1basic__collector.html">basic_collector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aea8b073b774362fe800d9cce3542927a">collector</a> {}</td></tr>
<tr class="memdesc:aea8b073b774362fe800d9cce3542927a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template used to ease the definition of collectors. <br /></td></tr>
<tr class="separator:aea8b073b774362fe800d9cce3542927a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5b73210cef43c4db35ef8ce477cc38a6">exclude</a> {}</td></tr>
<tr class="memdesc:a5b73210cef43c4db35ef8ce477cc38a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for exclusion lists.  <a href="namespaceentt.html#a5b73210cef43c4db35ef8ce477cc38a6">More...</a><br /></td></tr>
<tr class="separator:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8c24ecc5ab0055f9f2a4725c95afb29e">get</a> {}</td></tr>
<tr class="memdesc:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for lists of observed components.  <a href="namespaceentt.html#a8c24ecc5ab0055f9f2a4725c95afb29e">More...</a><br /></td></tr>
<tr class="separator:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49b2ea24586994d23d6d837a550867a"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ad49b2ea24586994d23d6d837a550867a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad49b2ea24586994d23d6d837a550867a">is_key_only_meta_associative_container_v</a> = <a class="el" href="structentt_1_1is__key__only__meta__associative__container.html">is_key_only_meta_associative_container</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:ad49b2ea24586994d23d6d837a550867a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ad49b2ea24586994d23d6d837a550867a">More...</a><br /></td></tr>
<tr class="separator:ad49b2ea24586994d23d6d837a550867a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8c390cfe71301a0c10f4844e98424c"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:aaa8c390cfe71301a0c10f4844e98424c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aaa8c390cfe71301a0c10f4844e98424c">is_meta_pointer_like_v</a> = <a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:aaa8c390cfe71301a0c10f4844e98424c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#aaa8c390cfe71301a0c10f4844e98424c">More...</a><br /></td></tr>
<tr class="separator:aaa8c390cfe71301a0c10f4844e98424c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e73acd6f3d892955819677dc2664b7"><td class="memTemplParams" colspan="2"><a id="af1e73acd6f3d892955819677dc2664b7"></a>
template&lt;auto Func&gt; </td></tr>
<tr class="memitem:af1e73acd6f3d892955819677dc2664b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Func &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af1e73acd6f3d892955819677dc2664b7">connect_arg</a> {}</td></tr>
<tr class="memdesc:af1e73acd6f3d892955819677dc2664b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant of type <a class="el" href="structentt_1_1connect__arg__t.html" title="Used to wrap a function or a member of a specified type.">connect_arg_t</a> used to disambiguate calls. <br /></td></tr>
<tr class="separator:af1e73acd6f3d892955819677dc2664b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><code>EnTT</code> default namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aedfeed27a790ac90eb5989da8a3ea860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfeed27a790ac90eb5989da8a3ea860">&#9670;&nbsp;</a></span>const_handle_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#aedfeed27a790ac90eb5989da8a3ea860">entt::const_handle_view</a> = typedef <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt;const <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00109">109</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a7b051461867d3c5c97f77f10b662c26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b051461867d3c5c97f77f10b662c26b">&#9670;&nbsp;</a></span>constness_as_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">entt::constness_as_t</a> = typedef typename <a class="el" href="structentt_1_1constness__as.html">constness_as</a>&lt;To, From&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template to facilitate the transcription of the constness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The type to which to transcribe the constness. </td></tr>
    <tr><td class="paramname">From</td><td>The type from which to transcribe the constness. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00653">653</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a2628e82fa8042f75d817c58fc09c7aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2628e82fa8042f75d817c58fc09c7aaf">&#9670;&nbsp;</a></span>group</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a2628e82fa8042f75d817c58fc09c7aaf">entt::group</a> = typedef <a class="el" href="classentt_1_1basic__group.html">basic_group</a>&lt;<a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00141">141</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="aaa5809ceb50ec17713e8690c20a79490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5809ceb50ec17713e8690c20a79490">&#9670;&nbsp;</a></span>handle_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#aaa5809ceb50ec17713e8690c20a79490">entt::handle_view</a> = typedef <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt;<a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00101">101</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a0d9fd5898acf13553bbcf14b99159f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9fd5898acf13553bbcf14b99159f4d">&#9670;&nbsp;</a></span>integral_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">entt::integral_constant</a> = typedef std::integral_constant&lt;decltype(Value), Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a static constant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A static constant. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00112">112</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a49f19d031690e5ebfffd6c7a4f6bd364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f19d031690e5ebfffd6c7a4f6bd364">&#9670;&nbsp;</a></span>member_class_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Member &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a49f19d031690e5ebfffd6c7a4f6bd364">entt::member_class_t</a> = typedef typename <a class="el" href="classentt_1_1member__class.html">member_class</a>&lt;Member&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>A pointer to a non-static member object or function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00684">684</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a692beabf853ee0f9dc68beab816a6b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692beabf853ee0f9dc68beab816a6b27">&#9670;&nbsp;</a></span>meta_function_helper_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Candidate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a692beabf853ee0f9dc68beab816a6b27">entt::meta_function_helper_t</a> = typedef typename <a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a>&lt;Type, Candidate&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the meta function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to associate with the reflected type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00118">118</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="aad3d1f1d0e83ad8f124155c9e511c2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3d1f1d0e83ad8f124155c9e511c2cd">&#9670;&nbsp;</a></span>poly</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Concept &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#aad3d1f1d0e83ad8f124155c9e511c2cd">entt::poly</a> = typedef <a class="el" href="classentt_1_1basic__poly.html">basic_poly</a>&lt;Concept, sizeof(double[2])&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Concept</td><td>Concept descriptor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="poly_2fwd_8hpp_source.html#l00020">20</a> of file <a class="el" href="poly_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="abcedb8f29753130e2bf3185bca211f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcedb8f29753130e2bf3185bca211f05">&#9670;&nbsp;</a></span>storage</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#abcedb8f29753130e2bf3185bca211f05">entt::storage</a> = typedef <a class="el" href="structentt_1_1basic__storage.html">basic_storage</a>&lt;<a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00073">73</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a9f7bb8c357f08a01ad9c8dab0ea40c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7bb8c357f08a01ad9c8dab0ea40c1c">&#9670;&nbsp;</a></span>tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;id_type Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a9f7bb8c357f08a01ad9c8dab0ea40c1c">entt::tag</a> = typedef <a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">integral_constant</a>&lt;Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template to facilitate the creation of named values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A constant value at least convertible to <code>id_type</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00120">120</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a09f6bd6b4aebc03df720e7e69fdc6643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f6bd6b4aebc03df720e7e69fdc6643">&#9670;&nbsp;</a></span>type_identity_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a09f6bd6b4aebc03df720e7e69fdc6643">entt::type_identity_t</a> = typedef typename <a class="el" href="structentt_1_1type__identity.html">type_identity</a>&lt;Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00062">62</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a546467a3662e9a915d5d519ad565e801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546467a3662e9a915d5d519ad565e801">&#9670;&nbsp;</a></span>type_list_cat_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">entt::type_list_cat_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type lists to concatenate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00226">226</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="af2992fc009cb3199b0ef9a86bed2285c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2992fc009cb3199b0ef9a86bed2285c">&#9670;&nbsp;</a></span>type_list_diff_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#af2992fc009cb3199b0ef9a86bed2285c">entt::type_list_diff_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type lists between which to compute the difference. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00316">316</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ac839c1a03dba2436791d0056d6d0d1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac839c1a03dba2436791d0056d6d0d1b6">&#9670;&nbsp;</a></span>type_list_element_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename List &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#ac839c1a03dba2436791d0056d6d0d1b6">entt::type_list_element_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__element.html">type_list_element</a>&lt;Index, List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index of the type to return. </td></tr>
    <tr><td class="paramname">List</td><td>Type list to search into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00171">171</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a75a277a6037279d65cd3874b46ec7166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a277a6037279d65cd3874b46ec7166">&#9670;&nbsp;</a></span>type_list_unique_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">entt::type_list_unique_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a>&lt;Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00263">263</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a61a837a49598350009f463e37c86d322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a837a49598350009f463e37c86d322">&#9670;&nbsp;</a></span>unpack_as_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a61a837a49598350009f463e37c86d322">entt::unpack_as_t</a> = typedef Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using declaration to be used to <em>repeat</em> the same type a number of times equal to the size of a given parameter pack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type to repeat. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00095">95</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a1344cc62598091397018354e6905e431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1344cc62598091397018354e6905e431">&#9670;&nbsp;</a></span>value_list_cat_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a1344cc62598091397018354e6905e431">entt::value_list_cat_t</a> = typedef typename <a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Value lists to concatenate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00422">422</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="acc5a93cf82f9378248fe6385376cd943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5a93cf82f9378248fe6385376cd943">&#9670;&nbsp;</a></span>view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">entt::view</a> = typedef <a class="el" href="structentt_1_1basic__view.html">basic_view</a>&lt;<a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00129">129</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="abc4d0fa77fae26e7c01793990996c581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4d0fa77fae26e7c01793990996c581">&#9670;&nbsp;</a></span>deletion_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">entt::deletion_policy</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sparse set deletion policy. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abc4d0fa77fae26e7c01793990996c581a8223d1ccb16b6dd0b19fe9c6fdb13708"></a>swap_and_pop&#160;</td><td class="fielddoc"><p>Swap-and-pop deletion policy. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc4d0fa77fae26e7c01793990996c581aa49f99ae99ae9daddd1fb79b73d2db28"></a>in_place&#160;</td><td class="fielddoc"><p>In-place deletion policy. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00021">21</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1ade9ac7c0844a7c154287ca96ceba08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ade9ac7c0844a7c154287ca96ceba08">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00401">401</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a7c210bb2e08d184415f5c5680d87d74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c210bb2e08d184415f5c5680d87d74e">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00391">391</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="ac53c0786eb32685bbbfc6a2b9806338b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53c0786eb32685bbbfc6a2b9806338b">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type* entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00418">418</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a2364ab41cab0fccd92cdaaf8779581cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2364ab41cab0fccd92cdaaf8779581cb">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type entt::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00382">382</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="aeaf3e0080cf2091703718dcbe558171b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf3e0080cf2091703718dcbe558171b">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Type* entt::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00411">411</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a4dcc1231f76478c7aa6f6ec9516cf045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcc1231f76478c7aa6f6ec9516cf045">&#9670;&nbsp;</a></span>as_group() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__group.html">entt::as_group</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6e62063b33b410e0a4bf1acc5b59596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e62063b33b410e0a4bf1acc5b59596">&#9670;&nbsp;</a></span>as_group() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__group.html">entt::as_group</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; const Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0922fd2ea330d84a2e1b6f19e877aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0922fd2ea330d84a2e1b6f19e877aed">&#9670;&nbsp;</a></span>as_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__view.html">entt::as_view</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4821869aa545da11205c90388fa2d08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4821869aa545da11205c90388fa2d08e">&#9670;&nbsp;</a></span>as_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__view.html">entt::as_view</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; const Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a288ec07d4e87a28179d43b367ff11eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288ec07d4e87a28179d43b367ff11eab">&#9670;&nbsp;</a></span>basic_handle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1basic__handle.html">entt::basic_handle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Entity&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6de052205bafd99d67afde880b67a4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de052205bafd99d67afde880b67a4e8">&#9670;&nbsp;</a></span>basic_handle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1basic__handle.html">entt::basic_handle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Entity&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; const Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa97361ef962166a4fc51a582d7c6392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa97361ef962166a4fc51a582d7c6392">&#9670;&nbsp;</a></span>basic_hashed_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__hashed__string.html">entt::basic_hashed_string</a> </td>
          <td>(</td>
          <td class="paramtype">const Char(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[N]</td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the character type of the hashed string directly from a human-readable identifer provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of characters of the identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Human-readable identifer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28ba251f748ba853ef573f9b57ee5896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ba251f748ba853ef573f9b57ee5896">&#9670;&nbsp;</a></span>basic_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Storage&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1basic__view.html">entt::basic_view</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1Storage.html">Storage</a> &amp;...&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1basic__view.html">basic_view</a>&lt; std::common_type_t&lt; typename Storage::entity_type... &gt;, <a class="el" href="structentt_1_1exclude__t.html">entt::exclude_t</a>&lt;&gt;, <a class="el" href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">constness_as_t</a>&lt; typename Storage::value_type, <a class="el" href="structentt_1_1Storage.html">Storage</a> &gt;... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structentt_1_1Storage.html" title="Basic poly storage implementation.">Storage</a></td><td>Type of storage classes used to create the view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>The storage for the types to iterate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c8907a3a72cd2da043d81f6fd50487a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8907a3a72cd2da043d81f6fd50487a">&#9670;&nbsp;</a></span>delegate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Candidate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate)&gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>Function or member to connect to the delegate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39ba791dbcdecb9415a5c11fe69c4b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ba791dbcdecb9415a5c11fe69c4b1c">&#9670;&nbsp;</a></span>delegate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Candidate, typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate), Type &gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>Function or member to connect to the delegate. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of class or type of payload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba06006a862fa5dc613e8561ac4e92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba06006a862fa5dc613e8561ac4e92c">&#9670;&nbsp;</a></span>delegate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype">Ret(*)(const void *, Args...)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ab7b51802157a98106f238335fa7503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab7b51802157a98106f238335fa7503">&#9670;&nbsp;</a></span>dereference_meta_pointer_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) entt::dereference_meta_pointer_like </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ADL based lookup function for dereferencing meta pointer-like types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer-like object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value returned from the dereferenced pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adl__pointer_8hpp_source.html#l00015">15</a> of file <a class="el" href="adl__pointer_8hpp_source.html">adl_pointer.hpp</a>.</p>

</div>
</div>
<a id="a810f66c2c91deba50f96cae9119f2feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810f66c2c91deba50f96cae9119f2feb">&#9670;&nbsp;</a></span>forward_as_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt;Len, Align&gt; entt::forward_as_any </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forwards its argument and avoids copies for lvalue references. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Optional alignment requirement. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of argument to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Parameter to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized and not necessarily owning wrapper. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00448">448</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a77c7a5a8ac08bc879abdaa00f920a996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c7a5a8ac08bc879abdaa00f920a996">&#9670;&nbsp;</a></span>forward_as_meta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::forward_as_meta </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forwards its argument and avoids copies for lvalue references. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of argument to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Parameter to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized and not necessarily owning wrapper. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00613">613</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a9818c2f838cf5aa4c5ea335d6996eda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9818c2f838cf5aa4c5ea335d6996eda0">&#9670;&nbsp;</a></span>get_as_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto entt::get_as_tuple </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] Type &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const typename Type::entity_type&#160;</td>
          <td class="paramname"><em>entt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the element assigned to an entity from a storage, if any. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="structentt_1_1Storage.html" title="Basic poly storage implementation.">Storage</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>A valid instance of a storage class. </td></tr>
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A possibly empty tuple containing the requested element. </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l01031">1031</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="aa512a354fe328df6be5a92eb43cd4d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa512a354fe328df6be5a92eb43cd4d69">&#9670;&nbsp;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Member, typename Entity  = entity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void entt::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to create a listener that directly invokes a member function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>Member function to invoke on a component of the given type. </td></tr>
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>A registry that contains the given entity and its components. </td></tr>
    <tr><td class="paramname">entt</td><td>Entity from which to get the component. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="helper_8hpp_source.html#l00129">129</a> of file <a class="el" href="helper_8hpp_source.html">helper.hpp</a>.</p>

</div>
</div>
<a id="abd78292ee5137d33a4635bd55e99bf7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd78292ee5137d33a4635bd55e99bf7e">&#9670;&nbsp;</a></span>make_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt;Len, Align&gt; entt::make_any </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a wrapper from a given type, passing it all arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of object to use to initialize the wrapper. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Optional alignment requirement. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized wrapper for an object of the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00434">434</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="afdfc8a0eecdf6230c2966786f8965589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfc8a0eecdf6230c2966786f8965589">&#9670;&nbsp;</a></span>make_meta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::make_meta </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a wrapper from a given type, passing it all arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of object to use to initialize the wrapper. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized wrapper for an object of the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00601">601</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a3ae5a1bdbb378be2ae0556ff437cf513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae5a1bdbb378be2ae0556ff437cf513">&#9670;&nbsp;</a></span>meta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto entt::meta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to use for reflection. </p>
<p>This is the point from which everything starts.<br  />
 By invoking this function with a type that is not yet reflected, a meta type is created to which it will be possible to attach meta objects through a dedicated factory.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to reflect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta factory for the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00587">587</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a0861c2878957a89499b0ca0801f7eeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0861c2878957a89499b0ca0801f7eeff">&#9670;&nbsp;</a></span>meta_construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Args, std::size_t... Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance given a list of erased parameters, if possible. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Actual type of the instance to construct. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments expected. </td></tr>
    <tr><td class="paramname">Index</td><td>Indexes to use to extract erased arguments from their list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the new instance, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00141">141</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a3ddec8e1e99754cfbb7afa9ceb1a5aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ddec8e1e99754cfbb7afa9ceb1a5aa0">&#9670;&nbsp;</a></span>meta_dispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Policy  = as_is_t, typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_dispatch </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a value depending on the given policy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Type</td><td>Type of value to wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00208">208</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a3fe26d091f302630470004fe314a6a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe26d091f302630470004fe314a6a8d">&#9670;&nbsp;</a></span>meta_getter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Data, typename Policy  = as_is_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_getter </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value of a given variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the variable is associated. </td></tr>
    <tr><td class="paramname">Data</td><td>The actual variable to get. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the value of the underlying variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00232">232</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a7a2d1a6ef198fb53abcb0fe808f0bdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2d1a6ef198fb53abcb0fe808f0bdac">&#9670;&nbsp;</a></span>meta_invoke() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Candidate, typename Policy  = as_is_t, std::size_t... Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_invocable_v&lt;decltype(Candidate)&gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a>&gt; entt::meta_invoke </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes a function given a list of erased parameters, if possible. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to invoke. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Index</td><td>Indexes to use to extract erased arguments from their list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to invoke the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00272">272</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a050e4320cd8ce648b9b9243817ac742a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050e4320cd8ce648b9b9243817ac742a">&#9670;&nbsp;</a></span>meta_invoke() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Candidate, typename Policy  = as_is_t, std::size_t... Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_invocable_v&lt;decltype(Candidate)&gt;, <a class="el" href="classentt_1_1meta__any.html">meta_any</a>&gt; entt::meta_invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes a function given a list of erased parameters, if possible. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to invoke. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Index</td><td>Indexes to use to extract erased arguments from their list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00320">320</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="adbe109e5134bae55cb519799acbed732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe109e5134bae55cb519799acbed732">&#9670;&nbsp;</a></span>meta_setter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool entt::meta_setter </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of a given variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the variable is associated. </td></tr>
    <tr><td class="paramname">Data</td><td>The actual variable to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">value</td><td>Parameter to use to set the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00159">159</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="ae38ac5bc7b9097ec21eb1058db206cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38ac5bc7b9097ec21eb1058db206cff">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two wrappers differ in their content. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A wrapper, either empty or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A wrapper, either empty or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two wrappers differ in their content, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00368">368</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a6c51761e603d7ff1fefd41c026f19de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c51761e603d7ff1fefd41c026f19de3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Other &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
    <tr><td class="paramname">Other</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if both handles refer to the same registry and the same entity, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_2handle_8hpp_source.html#l00329">329</a> of file <a class="el" href="entity_2handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="ac200eb460760246368bb737dc434c0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac200eb460760246368bb737dc434c0eb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two hashed strings are identical, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00227">227</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="ac8711ef7a24e5329d7cbd0d05136874e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8711ef7a24e5329d7cbd0d05136874e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the contents of two delegates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid delegate object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid delegate object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two contents differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="delegate_8hpp_source.html#l00328">328</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a id="a6185f9faa3f9fa26ecb1b9a837016147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6185f9faa3f9fa26ecb1b9a837016147">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1null__t.html">null_t</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a null object and an entity identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Entity identifier with which to compare. </td></tr>
    <tr><td class="paramname">other</td><td>A null object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two elements differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00232">232</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a39702a79d9ba6f5d7cb8668b0a7a1524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39702a79d9ba6f5d7cb8668b0a7a1524">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a tombstone object and an entity identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Entity identifier with which to compare. </td></tr>
    <tr><td class="paramname">other</td><td>A tombstone object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two elements differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00323">323</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a845d4ef2c448264153449c92157a0359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845d4ef2c448264153449c92157a0359">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two wrappers differ in their content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A wrapper, either empty or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A wrapper, either empty or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two wrappers differ in their content, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00588">588</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a04ebb219547c34209a94c9eb6d26eda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ebb219547c34209a94c9eb6d26eda1">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two objects refer to the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>An object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>An object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the objects refer to the same node, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l01600">1600</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="afb63e4c764b340bf4d600807daa22921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb63e4c764b340bf4d600807daa22921">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two contents differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00237">237</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a556190d147a6a92fc16bbf31bd4b263a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556190d147a6a92fc16bbf31bd4b263a">&#9670;&nbsp;</a></span>operator&quot;&quot;_hs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">entt::hashed_string</a> entt::literals::operator&quot;&quot;_hs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined literal for hashed strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The literal without its suffix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized hashed string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00248">248</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a226e03b3f52eb1bbce832ec53106bd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226e03b3f52eb1bbce832ec53106bd6a">&#9670;&nbsp;</a></span>operator&quot;&quot;_hws()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">entt::hashed_wstring</a> entt::literals::operator&quot;&quot;_hws </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined literal for hashed wstrings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The literal without its suffix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized hashed wstring. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00258">258</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a6c6e966c8af5b1452811aa55adbbdf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6e966c8af5b1452811aa55adbbdf47">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type, typename... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt;Type..., Other...&gt; entt::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Other... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates multiple type lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Types provided by the first type list. </td></tr>
    <tr><td class="paramname">Other</td><td>Types provided by the second type list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type list composed by the types of both the type lists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00181">181</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aabc6dd5fb4d2bc92d9e5101b7b0bce1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc6dd5fb4d2bc92d9e5101b7b0bce1d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto... Value, auto... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1value__list.html">value_list</a>&lt;Value..., Other...&gt; entt::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Other... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates multiple value lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Values provided by the first value list. </td></tr>
    <tr><td class="paramname">Other</td><td>Values provided by the second value list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value list composed by the values of both the value lists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00377">377</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="af6de691c4ec15d4a63ea8960563bbea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6de691c4ec15d4a63ea8960563bbea0">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1null__t.html">null_t</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a null object and an entity identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Entity identifier with which to compare. </td></tr>
    <tr><td class="paramname">other</td><td>A null object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the two elements differ, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00219">219</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a0f371da1ef604fa726a88e9733e5ee54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f371da1ef604fa726a88e9733e5ee54">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a tombstone object and an entity identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Entity identifier with which to compare. </td></tr>
    <tr><td class="paramname">other</td><td>A tombstone object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the two elements differ, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00310">310</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="af0174aa3efe81fb881deb652d4b6d233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0174aa3efe81fb881deb652d4b6d233">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename... ELhs, typename... CLhs, typename... ERhs, typename... CRhs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto entt::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1basic__view.html">basic_view</a>&lt; Entity, <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; ELhs... &gt;, CLhs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1basic__view.html">basic_view</a>&lt; Entity, <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; ERhs... &gt;, CRhs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines two views in a <em>more specific</em> one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
    <tr><td class="paramname">ELhs</td><td>Filter list of the first view. </td></tr>
    <tr><td class="paramname">CLhs</td><td>Component list of the first view. </td></tr>
    <tr><td class="paramname">ERhs</td><td>Filter list of the second view. </td></tr>
    <tr><td class="paramname">CRhs</td><td>Component list of the second view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid reference to the first view. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid reference to the second view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A more specific view. </dd></dl>

<p class="definition">Definition at line <a class="el" href="view_8hpp_source.html#l01047">1047</a> of file <a class="el" href="view_8hpp_source.html">view.hpp</a>.</p>

</div>
</div>
<a id="ad4ea6822ef21f52c732ba3baea450159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ea6822ef21f52c732ba3baea450159">&#9670;&nbsp;</a></span>overload() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::overload </td>
          <td>(</td>
          <td class="paramtype">Func *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant utility to disambiguate overloaded functions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Function type of the desired overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A valid pointer to a function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2utility_8hpp_source.html#l00045">45</a> of file <a class="el" href="core_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a386a739051d9d37a5578785b77fc426b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386a739051d9d37a5578785b77fc426b">&#9670;&nbsp;</a></span>overload() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::overload </td>
          <td>(</td>
          <td class="paramtype">Type Class::*&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant utility to disambiguate overloaded members of a class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the desired overload. </td></tr>
    <tr><td class="paramname">Class</td><td>Type of class to which the member belongs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>A valid pointer to a member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the member. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2utility_8hpp_source.html#l00035">35</a> of file <a class="el" href="core_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a26eb67ac302229374c5fb623d529f5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26eb67ac302229374c5fb623d529f5eb">&#9670;&nbsp;</a></span>overloaded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Func&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1overloaded.html">entt::overloaded</a> </td>
          <td>(</td>
          <td class="paramtype">Func...&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1overloaded.html">overloaded</a>&lt; Func... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Types of function objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaec3476b637deea0ca553427175664f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaec3476b637deea0ca553427175664f">&#9670;&nbsp;</a></span>poly_call()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Member, typename Poly , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) entt::poly_call </td>
          <td>(</td>
          <td class="paramtype">Poly &amp;&amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcut for calling <code><a class="el" href="structentt_1_1poly__base.html" title="Poly base class used to inject functionalities into concepts.">poly_base</a>&lt;Type&gt;<a class="el" href="namespaceentt.html#aa512a354fe328df6be5a92eb43cd4d69" title="Helper to create a listener that directly invokes a member function.">invoke</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>Index of the function to invoke. </td></tr>
    <tr><td class="paramname">Poly</td><td>A fully defined poly object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A reference to the poly object that made the call. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the invoked function, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="poly_8hpp_source.html#l00160">160</a> of file <a class="el" href="poly_8hpp_source.html">poly.hpp</a>.</p>

</div>
</div>
<a id="a0b62be0d39676cb86f2aefefa890b198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b62be0d39676cb86f2aefefa890b198">&#9670;&nbsp;</a></span>resolve() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__range.html">meta_range</a>&lt; <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &gt; entt::resolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type. </p>
<p>Returns a range to use to visit all meta types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to use to search for a meta type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type, if any.</dd>
<dd>
An iterable range to use to visit all meta types. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00022">22</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a1915a651e7ce55938a09269c3d9c98e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1915a651e7ce55938a09269c3d9c98e4">&#9670;&nbsp;</a></span>resolve() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given identifier, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given identifier, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00041">41</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="aa1a6e0b744ec6398f4e43811c59cced1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a6e0b744ec6398f4e43811c59cced1">&#9670;&nbsp;</a></span>resolve() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a>&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type info object, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The type info object of the requested type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type info object, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00058">58</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="ad3c393cd14012db79a3bbabd816e46b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c393cd14012db79a3bbabd816e46b3">&#9670;&nbsp;</a></span>sink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sink.html">entt::sink</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1sink.html">sink</a>&lt; Ret(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the function type of a sink directly from the signal it refers to.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae81b68364d770429f343d703f415d12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81b68364d770429f343d703f415d12a">&#9670;&nbsp;</a></span>to_entity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Component &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Entity entt::to_entity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Component &amp;&#160;</td>
          <td class="paramname"><em>instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the entity associated with a given component. </p>
<dl class="section warning"><dt>Warning</dt><dd>Currently, this function only works correctly with the default pool as it makes assumptions about how the components are laid out.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
    <tr><td class="paramname">Component</td><td>Type of component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>A registry that contains the given entity and its components. </td></tr>
    <tr><td class="paramname">instance</td><td>A valid component instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entity associated with the given component. </dd></dl>

<p class="definition">Definition at line <a class="el" href="helper_8hpp_source.html#l00151">151</a> of file <a class="el" href="helper_8hpp_source.html">helper.hpp</a>.</p>

</div>
</div>
<a id="a32d673d4f0014fabfd97bcaa3dedcb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d673d4f0014fabfd97bcaa3dedcb5c">&#9670;&nbsp;</a></span>to_integral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::to_integral </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an entity to its underlying type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>The value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral representation of the given value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00141">141</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a39f04d6b89000ab4a0f7aa9c49403734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f04d6b89000ab4a0f7aa9c49403734">&#9670;&nbsp;</a></span>type_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1type__info.html">type_info</a> entt::type_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type info object for a given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type for which to generate a type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type info object for the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00248">248</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a089f75043b082abca3ea144bce44e9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089f75043b082abca3ea144bce44e9ae">&#9670;&nbsp;</a></span>choice</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1choice__t.html">choice_t</a>&lt;N&gt; entt::choice {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for the choice trick. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of choices available. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00039">39</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a5b73210cef43c4db35ef8ce477cc38a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b73210cef43c4db35ef8ce477cc38a6">&#9670;&nbsp;</a></span>exclude</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt;Type...&gt; entt::exclude {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for exclusion lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2utility_8hpp_source.html#l00024">24</a> of file <a class="el" href="entity_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a8c24ecc5ab0055f9f2a4725c95afb29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c24ecc5ab0055f9f2a4725c95afb29e">&#9670;&nbsp;</a></span>get</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt;Type...&gt; entt::get {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for lists of observed components. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2utility_8hpp_source.html#l00040">40</a> of file <a class="el" href="entity_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="ae764716fab8c01b12d3e209004b62647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae764716fab8c01b12d3e209004b62647">&#9670;&nbsp;</a></span>is_applicable_r_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Func , typename Args &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_applicable_r_v = <a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a>&lt;Ret, Func, Args&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>The type to which the return type of the function should be convertible. </td></tr>
    <tr><td class="paramname">Func</td><td>A valid function type. </td></tr>
    <tr><td class="paramname">Args</td><td>The list of arguments to use to probe the function type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00545">545</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a4f238620469de3ef2bafdb28fe4657ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f238620469de3ef2bafdb28fe4657ef">&#9670;&nbsp;</a></span>is_applicable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename Args &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_applicable_v = <a class="el" href="structentt_1_1is__applicable.html">is_applicable</a>&lt;Func, Args&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>A valid function type. </td></tr>
    <tr><td class="paramname">Args</td><td>The list of arguments to use to probe the function type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00518">518</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a96fcc4bc8da9a2aa1cdb0bc15b75c8">&#9670;&nbsp;</a></span>is_complete_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_complete_v = <a class="el" href="structentt_1_1is__complete.html">is_complete</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00567">567</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a068dd98a70c771935d2bf3dd96dbad6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068dd98a70c771935d2bf3dd96dbad6d">&#9670;&nbsp;</a></span>is_equality_comparable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_equality_comparable_v = <a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00484">484</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ac4081aa5332fcb3367063eeba93918b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4081aa5332fcb3367063eeba93918b8">&#9670;&nbsp;</a></span>is_iterator_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_iterator_type_v = <a class="el" href="structentt_1_1is__iterator__type.html">is_iterator_type</a>&lt;Type, It&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
    <tr><td class="paramname">It</td><td>Required iterator type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00624">624</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a3ac133ddb24ec535a11baf3143d188d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac133ddb24ec535a11baf3143d188d6">&#9670;&nbsp;</a></span>is_iterator_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_iterator_v = <a class="el" href="structentt_1_1is__iterator.html">is_iterator</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00591">591</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ad49b2ea24586994d23d6d837a550867a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49b2ea24586994d23d6d837a550867a">&#9670;&nbsp;</a></span>is_key_only_meta_associative_container_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::is_key_only_meta_associative_container_v = <a class="el" href="structentt_1_1is__key__only__meta__associative__container.html">is_key_only_meta_associative_container</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potentially key-only meta associative container type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="meta_2type__traits_8hpp_source.html#l00056">56</a> of file <a class="el" href="meta_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aaa8c390cfe71301a0c10f4844e98424c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8c390cfe71301a0c10f4844e98424c">&#9670;&nbsp;</a></span>is_meta_pointer_like_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::is_meta_pointer_like_v = <a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potentially pointer-like type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="meta_2type__traits_8hpp_source.html#l00082">82</a> of file <a class="el" href="meta_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ab43a13f7ee60bcb0d04a001f92b86fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43a13f7ee60bcb0d04a001f92b86fa2">&#9670;&nbsp;</a></span>monostate_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;id_type Value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1monostate.html">monostate</a>&lt;Value&gt; entt::monostate_v = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Value used to differentiate between different variables. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="monostate_8hpp_source.html#l00056">56</a> of file <a class="el" href="monostate_8hpp_source.html">monostate.hpp</a>.</p>

</div>
</div>
<a id="a2f0c0a1c1d953ea991591748744cdd8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0c0a1c1d953ea991591748744cdd8b">&#9670;&nbsp;</a></span>null</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1null__t.html">null_t</a> entt::null {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time constant for null entities. </p>
<p>There exist implicit conversions from this variable to entity identifiers of any allowed type. Similarly, there exist comparision operators between the null entity and any other entity identifier. </p>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00335">335</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a15f9a70cbdd5a64f897a012ab2b5834f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f9a70cbdd5a64f897a012ab2b5834f">&#9670;&nbsp;</a></span>size_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t entt::size_of_v = <a class="el" href="structentt_1_1size__of.html">size_of</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of which to return the size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00086">86</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a674269102fdfe3fd6d7766210a828862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674269102fdfe3fd6d7766210a828862">&#9670;&nbsp;</a></span>tombstone</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a> entt::tombstone {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time constant for tombstone entities. </p>
<p>There exist implicit conversions from this variable to entity identifiers of any allowed type. Similarly, there exist comparision operators between the tombstone entity and any other entity identifier. </p>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00345">345</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a988ce063936d499bf2d69406c391fd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988ce063936d499bf2d69406c391fd5c">&#9670;&nbsp;</a></span>type_list_contains_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class List , typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::type_list_contains_v = <a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a>&lt;List, Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type list. </td></tr>
    <tr><td class="paramname">Type</td><td>Type to look for. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00291">291</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a447c782d9f4f5332dfd4dde6f03d4a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447c782d9f4f5332dfd4dde6f03d4a4e">&#9670;&nbsp;</a></span>unpack_as_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Value, typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::unpack_as_v = Value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template to be used to <em>repeat</em> the same value a number of times equal to the size of a given parameter pack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A value to repeat. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00104">104</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a4bbfb162708696f9c1497d61573b540f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbfb162708696f9c1497d61573b540f">&#9670;&nbsp;</a></span>value_list_element_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename List &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::value_list_element_v = <a class="el" href="structentt_1_1value__list__element.html">value_list_element</a>&lt;Index, List&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index of the value to return. </td></tr>
    <tr><td class="paramname">List</td><td>Value list to search into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00367">367</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
