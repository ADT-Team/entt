<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: entt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EnTT
   &#160;<span id="projectnumber">3.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">entt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>EnTT</code> default namespace.  
<a href="namespaceentt.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1dense__hash__map.html">dense_hash_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associative container for key-value pairs with unique keys.  <a href="classentt_1_1dense__hash__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1dense__hash__set.html">dense_hash_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associative container for unique objects of a given type.  <a href="classentt_1_1dense__hash__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1std__sort.html">std_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object to wrap <code>std::sort</code> in a class type.  <a href="structentt_1_1std__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1insertion__sort.html">insertion_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing insertion sort.  <a href="structentt_1_1insertion__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1radix__sort.html">radix_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing LSD radix sort.  <a href="structentt_1_1radix__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__any.html">basic_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SBO friendly, type-safe container for single values of any type.  <a href="classentt_1_1basic__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compressed pair.  <a href="classentt_1_1compressed__pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1enum__as__bitmask.html">enum_as_bitmask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable bitmask support for enum classes.  <a href="structentt_1_1enum__as__bitmask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1enum__as__bitmask_3_01Type_00_01std_1_1void__t_3_01decltype_07Type_1_1__entt__enum__as__bitmask_08_4_01_4.html">enum_as_bitmask&lt; Type, std::void_t&lt; decltype(Type::_entt_enum_as_bitmask)&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable bitmask support for enum classes.  <a href="structentt_1_1enum__as__bitmask_3_01Type_00_01std_1_1void__t_3_01decltype_07Type_1_1__entt__enum__as__bitmask_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1family.html">family</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic identifier generator.  <a href="classentt_1_1family.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero overhead unique identifier.  <a href="classentt_1_1basic__hashed__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1identifier.html">identifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types identifiers.  <a href="classentt_1_1identifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1input__iterator__pointer.html">input_iterator_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type to use as pointer with input iterators.  <a href="structentt_1_1input__iterator__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1iterable__adaptor.html">iterable_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to create an iterable object from a pair of iterators.  <a href="structentt_1_1iterable__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1monostate.html">monostate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal implementation of the monostate pattern.  <a href="structentt_1_1monostate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__index.html">type_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type sequential identifier.  <a href="structentt_1_1type__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__hash.html">type_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type hash.  <a href="structentt_1_1type__hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__name.html">type_name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type name.  <a href="structentt_1_1type__name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1type__info.html">type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation specific information about a type.  <a href="classentt_1_1type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1choice__t.html">choice_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate overloaded functions.  <a href="structentt_1_1choice__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1choice__t_3_010_01_4.html">choice_t&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate overloaded functions.  <a href="structentt_1_1choice__t_3_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__identity.html">type_identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity type trait.  <a href="structentt_1_1type__identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1size__of.html">size_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-only <code>sizeof</code> wrapper that returns 0 where <code>sizeof</code> complains.  <a href="structentt_1_1size__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1size__of_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html">size_of&lt; Type, std::void_t&lt; decltype(sizeof(Type))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-only <code>sizeof</code> wrapper that returns 0 where <code>sizeof</code> complains.  <a href="structentt_1_1size__of_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list.html">type_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to use to push around lists of types, nothing more.  <a href="structentt_1_1type__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element.html">type_list_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element_3_01Index_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html">type_list_element&lt; Index, type_list&lt; Type, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1type__list__element_3_01Index_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element_3_010u_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html">type_list_element&lt; 0u, type_list&lt; Type, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1type__list__element_3_010u_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__cat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_4.html">type_list_cat&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html">type_list_cat&lt; type_list&lt; Type... &gt;, type_list&lt; Other... &gt;, List... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_01_4.html">type_list_cat&lt; type_list&lt; Type... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__unique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique_3_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html">type_list_unique&lt; type_list&lt; Type, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates types from a type list.  <a href="structentt_1_1type__list__unique_3_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique_3_01type__list_3_4_01_4.html">type_list_unique&lt; type_list&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates types from a type list.  <a href="structentt_1_1type__list__unique_3_01type__list_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a type list contains a given type, false otherwise.  <a href="structentt_1_1type__list__contains.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__contains_3_01type__list_3_01Type_8_8_8_01_4_00_01Other_01_4.html">type_list_contains&lt; type_list&lt; Type... &gt;, Other &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a type list contains a given type, false otherwise.  <a href="structentt_1_1type__list__contains_3_01type__list_3_01Type_8_8_8_01_4_00_01Other_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__diff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__diff_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_01_4.html">type_list_diff&lt; type_list&lt; Type... &gt;, type_list&lt; Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference between two type lists.  <a href="structentt_1_1type__list__diff_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list.html">value_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to use to push around lists of constant values, nothing more.  <a href="structentt_1_1value__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element.html">value_list_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1value__list__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element_3_01Index_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html">value_list_element&lt; Index, value_list&lt; Value, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the values of a value list.  <a href="structentt_1_1value__list__element_3_01Index_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element_3_010u_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html">value_list_element&lt; 0u, value_list&lt; Value, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1value__list__element_3_010u_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1value__list__cat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_4.html">value_list_cat&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_00_01value__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html">value_list_cat&lt; value_list&lt; Value... &gt;, value_list&lt; Other... &gt;, List... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_00_01value__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_01_4.html">value_list_cat&lt; value_list&lt; Value... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable.html">is_applicable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.  <a href="structentt_1_1is__applicable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable_3_01Func_00_01Tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable&lt; Func, Tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.  <a href="structentt_1_1is__applicable_3_01Func_00_01Tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable_3_01Func_00_01const_01Tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable&lt; Func, const Tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.  <a href="structentt_1_1is__applicable_3_01Func_00_01const_01Tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable_r, but with tuples for arguments.  <a href="structentt_1_1is__applicable__r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable__r_3_01Ret_00_01Func_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable_r&lt; Ret, Func, std::tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable_r, but with tuples for arguments.  <a href="structentt_1_1is__applicable__r_3_01Ret_00_01Func_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__complete.html">is_complete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is complete, false otherwise.  <a href="structentt_1_1is__complete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__complete_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html">is_complete&lt; Type, std::void_t&lt; decltype(sizeof(Type))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is complete, false otherwise.  <a href="structentt_1_1is__complete_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is an iterator, false otherwise.  <a href="structentt_1_1is__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__iterator_3_01Type_00_01std_1_1enable__if__t_3_9std_1_1is__same__v_3_01std_1_1rd42721e751eff098894616f5c9eb2c37.html">is_iterator&lt; Type, std::enable_if_t&lt;!std::is_same_v&lt; std::remove_const_t&lt; std::remove_pointer_t&lt; Type &gt; &gt;, void &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is an iterator, false otherwise.  <a href="structentt_1_1is__iterator_3_01Type_00_01std_1_1enable__if__t_3_9std_1_1is__same__v_3_01std_1_1rd42721e751eff098894616f5c9eb2c37.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__iterator__type.html">is_iterator_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is of the required iterator type, false otherwise.  <a href="structentt_1_1is__iterator__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__iterator__type_3_01Type_00_01It_00_01std_1_1enable__if__t_3_01is__iterator__v_1c6d668122d93a8a6f6186aab47dc295.html">is_iterator_type&lt; Type, It, std::enable_if_t&lt; is_iterator_v&lt; Type &gt; &amp;&amp;std::is_same_v&lt; Type, It &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is of the required iterator type, false otherwise.  <a href="structentt_1_1is__iterator__type_3_01Type_00_01It_00_01std_1_1enable__if__t_3_01is__iterator__v_1c6d668122d93a8a6f6186aab47dc295.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__iterator__type_3_01Type_00_01It_00_01std_1_1enable__if__t_3_9std_1_1is__same__d827a14c04f195b53a7b353d4f3d2a15.html">is_iterator_type&lt; Type, It, std::enable_if_t&lt;!std::is_same_v&lt; Type, It &gt;, std::void_t&lt; typename It::iterator_type &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is of the required iterator type, false otherwise.  <a href="structentt_1_1is__iterator__type_3_01Type_00_01It_00_01std_1_1enable__if__t_3_9std_1_1is__same__d827a14c04f195b53a7b353d4f3d2a15.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__ebco__eligible.html">is_ebco_eligible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is both an empty and non-final class, false otherwise.  <a href="structentt_1_1is__ebco__eligible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__transparent.html">is_transparent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if <code>Type::is_transparent</code> is valid and denotes a type, false otherwise.  <a href="structentt_1_1is__transparent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__transparent_3_01Type_00_01std_1_1void__t_3_01typename_01Type_1_1is__transparent_01_4_01_4.html">is_transparent&lt; Type, std::void_t&lt; typename Type::is_transparent &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if <code>Type::is_transparent</code> is valid and denotes a type, false otherwise.  <a href="structentt_1_1is__transparent_3_01Type_00_01std_1_1void__t_3_01typename_01Type_1_1is__transparent_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is equality comparable, false otherwise.  <a href="structentt_1_1is__equality__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__equality__comparable_3_01Type_00_01std_1_1void__t_3_01decltype_07std_1_1declva46aebf4c20f38cbd0108d1e297595736.html">is_equality_comparable&lt; Type, std::void_t&lt; decltype(std::declval&lt; Type &gt;()==std::declval&lt; Type &gt;())&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is equality comparable, false otherwise.  <a href="structentt_1_1is__equality__comparable_3_01Type_00_01std_1_1void__t_3_01decltype_07std_1_1declva46aebf4c20f38cbd0108d1e297595736.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1constness__as.html">constness_as</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transcribes the constness of a type to another type.  <a href="structentt_1_1constness__as.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1constness__as_3_01To_00_01const_01From_01_4.html">constness_as&lt; To, const From &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transcribes the constness of a type to another type.  <a href="structentt_1_1constness__as_3_01To_00_01const_01From_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1member__class.html">member_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the class of a non-static member object or function.  <a href="classentt_1_1member__class.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity function object (waiting for C++20).  <a href="structentt_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1overloaded.html">overloaded</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for visitors.  <a href="structentt_1_1overloaded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1y__combinator.html">y_combinator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of a y-combinator.  <a href="structentt_1_1y__combinator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__component__traits.html">basic_component_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commonly used default traits for all types.  <a href="structentt_1_1basic__component__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1component__traits.html">component_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common way to access various properties of components.  <a href="structentt_1_1component__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1entt__traits.html">entt_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity traits.  <a href="classentt_1_1entt__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1null__t.html">null_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null object for all identifiers. <br  />
  <a href="structentt_1_1null__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tombstone object for all identifiers. <br  />
  <a href="structentt_1_1tombstone__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic sparse set implementation.  <a href="classentt_1_1basic__sparse__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic storage implementation.  <a href="classentt_1_1basic__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast and reliable entity-component system.  <a href="classentt_1_1basic__registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view.html">basic_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View implementation.  <a href="classentt_1_1basic__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime view.  <a href="classentt_1_1basic__runtime__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group.html">basic_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group.  <a href="classentt_1_1basic__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__observer.html">basic_observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observer.  <a href="classentt_1_1basic__observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__organizer.html">basic_organizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for creating a static task graph.  <a href="classentt_1_1basic__organizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__handle.html">basic_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning handle to an entity.  <a href="structentt_1_1basic__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__snapshot.html">basic_snapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to create snapshots from a registry.  <a href="classentt_1_1basic__snapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__snapshot__loader.html">basic_snapshot_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to restore a snapshot as a whole.  <a href="classentt_1_1basic__snapshot__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__continuous__loader.html">basic_continuous_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for <em>continuous loading</em>.  <a href="classentt_1_1basic__continuous__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group_3_01Entity_00_01owned__t_3_4_00_01get__t_3_01Get_8_8_8_01_4_00_01exclu1dcd462b241f859eda99da588b99288a.html">basic_group&lt; Entity, owned_t&lt;&gt;, get_t&lt; Get... &gt;, exclude_t&lt; Exclude... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning group.  <a href="classentt_1_1basic__group_3_01Entity_00_01owned__t_3_4_00_01get__t_3_01Get_8_8_8_01_4_00_01exclu1dcd462b241f859eda99da588b99288a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group_3_01Entity_00_01owned__t_3_01Owned_8_8_8_01_4_00_01get__t_3_01Get_8_8_7e553a767a43a044ebe212daf245cf6c.html">basic_group&lt; Entity, owned_t&lt; Owned... &gt;, get_t&lt; Get... &gt;, exclude_t&lt; Exclude... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning group.  <a href="classentt_1_1basic__group_3_01Entity_00_01owned__t_3_01Owned_8_8_8_01_4_00_01get__t_3_01Get_8_8_7e553a767a43a044ebe212daf245cf6c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__view.html">as_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a registry to a view.  <a href="structentt_1_1as__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__group.html">as_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a registry to a group.  <a href="structentt_1_1as__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1matcher.html">matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grouping matcher.  <a href="structentt_1_1matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector.html">basic_collector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector_3_4.html">basic_collector&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector_3_01matcher_3_01type__list_3_01Reject_8_8_8_01_4_00_01type__list_98a79514dcad34a82f321f0796064ffb.html">basic_collector&lt; matcher&lt; type_list&lt; Reject... &gt;, type_list&lt; Require... &gt;, Rule... &gt;, Other... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector_3_01matcher_3_01type__list_3_01Reject_8_8_8_01_4_00_01type__list_98a79514dcad34a82f321f0796064ffb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage_3_01Entity_00_01Type_00_01Allocator_00_01std_1_1enable__if__t_3_01igb49d3f82639348392c5a5f0f427d22ad.html">basic_storage&lt; Entity, Type, Allocator, std::enable_if_t&lt; ignore_as_empty_v&lt; Type &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classentt_1_1basic__storage_3_01Entity_00_01Type_00_01Allocator_00_01std_1_1enable__if__t_3_01igb49d3f82639348392c5a5f0f427d22ad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh__storage__mixin.html">sigh_storage_mixin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin type used to add signal support to storage types.  <a href="classentt_1_1sigh__storage__mixin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1storage__traits.html">storage_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a common way to access certain properties of storage types.  <a href="structentt_1_1storage__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1exclude__t.html">exclude_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for exclusion lists.  <a href="structentt_1_1exclude__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1get__t.html">get_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for lists of observed components.  <a href="structentt_1_1get__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1owned__t.html">owned_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for lists of owned components.  <a href="structentt_1_1owned__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view_3_01Entity_00_01get__t_3_01Component_8_8_8_01_4_00_01exclude__t_3_01Exclude_8_8_8_01_4_01_4.html">basic_view&lt; Entity, get_t&lt; Component... &gt;, exclude_t&lt; Exclude... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi component view.  <a href="classentt_1_1basic__view_3_01Entity_00_01get__t_3_01Component_8_8_8_01_4_00_01exclude__t_3_01Exclude_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view_3_01Entity_00_01get__t_3_01Component_01_4_00_01exclude__t_3_4_00_01std_bf8e2b91f3656eee29ec275c7d65682d.html">basic_view&lt; Entity, get_t&lt; Component &gt;, exclude_t&lt;&gt;, std::void_t&lt; std::enable_if_t&lt;!component_traits&lt; std::remove_const_t&lt; Component &gt; &gt;::in_place_delete &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single component view specialization.  <a href="classentt_1_1basic__view_3_01Entity_00_01get__t_3_01Component_01_4_00_01exclude__t_3_4_00_01std_bf8e2b91f3656eee29ec275c7d65682d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1service__locator.html">service_locator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Service locator, nothing more.  <a href="structentt_1_1service__locator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1adl__meta__pointer__like.html">adl_meta_pointer_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fake ADL based lookup function for meta pointer-like types.  <a href="structentt_1_1adl__meta__pointer__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits_3_01std_1_1vector_3_01Type_00_01Args_8_8_8_01_4_01_4.html">meta_sequence_container_traits&lt; std::vector&lt; Type, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta sequence container traits for <code>std::vector</code>s of any type.  <a href="structentt_1_1meta__sequence__container__traits_3_01std_1_1vector_3_01Type_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits_3_01std_1_1array_3_01Type_00_01N_01_4_01_4.html">meta_sequence_container_traits&lt; std::array&lt; Type, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta sequence container traits for <code>std::array</code>s of any type.  <a href="structentt_1_1meta__sequence__container__traits_3_01std_1_1array_3_01Type_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1map_3_01Key_00_01Value_00_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::map&lt; Key, Value, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::map</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1map_3_01Key_00_01Value_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__map_3_01Key_00_01Value_00_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::unordered_map&lt; Key, Value, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::unordered_map</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__map_3_01Key_00_01Value_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1set_3_01Key_00_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::set&lt; Key, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::set</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1set_3_01Key_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__set_3_01Key_00_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::unordered_set&lt; Key, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::unordered_set</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__set_3_01Key_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01dense__hash__map_3_01Key_00_01Type_00_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; dense_hash_map&lt; Key, Type, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code><a class="el" href="classentt_1_1dense__hash__map.html" title="Associative container for key-value pairs with unique keys.">dense_hash_map</a></code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01dense__hash__map_3_01Key_00_01Type_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01dense__hash__set_3_01Type_00_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; dense_hash_set&lt; Type, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code><a class="el" href="classentt_1_1dense__hash__set.html" title="Associative container for unique objects of a given type.">dense_hash_set</a></code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01dense__hash__set_3_01Type_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__ctx.html">meta_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque container for a meta context.  <a href="structentt_1_1meta__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__factory.html">meta_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta factory to be used for reflection purposes.  <a href="classentt_1_1meta__factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__factory_3_01Type_00_01Spec_8_8_8_01_4.html">meta_factory&lt; Type, Spec... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended meta factory to be used for reflection purposes.  <a href="classentt_1_1meta__factory_3_01Type_00_01Spec_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__factory_3_01Type_01_4.html">meta_factory&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic meta factory to be used for reflection purposes.  <a href="classentt_1_1meta__factory_3_01Type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__sequence__container.html">meta_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy object for sequence containers.  <a href="classentt_1_1meta__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__associative__container.html">meta_associative_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy object for associative containers.  <a href="classentt_1_1meta__associative__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__any.html">meta_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for values of any type.  <a href="classentt_1_1meta__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque pointers to instances of any type.  <a href="structentt_1_1meta__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__prop.html">meta_prop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for properties of any type.  <a href="structentt_1_1meta__prop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__data.html">meta_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for data members.  <a href="structentt_1_1meta__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__func.html">meta_func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for member functions.  <a href="structentt_1_1meta__func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__type.html">meta_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for types.  <a href="classentt_1_1meta__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01Type_01_5_01_4.html">is_meta_pointer_like&lt; Type * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes plain pointers pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01Type_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01Type_07_5_08_0fN_0e_4.html">is_meta_pointer_like&lt; Type(*)[N]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization used to reject pointers to arrays.  <a href="structentt_1_1is__meta__pointer__like_3_01Type_07_5_08_0fN_0e_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01std_1_1shared__ptr_3_01Type_01_4_01_4.html">is_meta_pointer_like&lt; std::shared_ptr&lt; Type &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <code>std::shared_ptr</code>s of any type pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01std_1_1shared__ptr_3_01Type_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01std_1_1unique__ptr_3_01Type_00_01Args_8_8_8_01_4_01_4.html">is_meta_pointer_like&lt; std::unique_ptr&lt; Type, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <code>std::unique_ptr</code>s of any type pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01std_1_1unique__ptr_3_01Type_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__ref__t.html">as_ref_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as ref</em> policy.  <a href="structentt_1_1as__ref__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__cref__t.html">as_cref_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as cref</em> policy.  <a href="structentt_1_1as__cref__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__is__t.html">as_is_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as-is</em> policy.  <a href="structentt_1_1as__is__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__void__t.html">as_void_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as void</em> policy.  <a href="structentt_1_1as__void__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__range.html">meta_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterable range to use to iterate all types of meta objects.  <a href="structentt_1_1meta__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__class__template__tag.html">meta_class_template_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate class templates.  <a href="structentt_1_1meta__class__template__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__template__traits_3_01Clazz_3_01Args_8_8_8_01_4_01_4.html">meta_template_traits&lt; Clazz&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose traits class for generating meta template information.  <a href="structentt_1_1meta__template__traits_3_01Clazz_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__template__traits.html">meta_template_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta template information.  <a href="structentt_1_1meta__template__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits.html">meta_sequence_container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta sequence containers.  <a href="structentt_1_1meta__sequence__container__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits.html">meta_associative_container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta associative containers.  <a href="structentt_1_1meta__associative__container__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is a pointer-like type from the point of view of the meta system, false otherwise.  <a href="structentt_1_1is__meta__pointer__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01const_01Type_01_4.html">is_meta_pointer_like&lt; const Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization to ensure that const pointer-like types are also accepted.  <a href="structentt_1_1is__meta__pointer__like_3_01const_01Type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor.html">meta_function_descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1meta__function__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_01const_01_4.html">meta_function_descriptor&lt; Type, Ret(Class::*)(Args...) const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_01const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_4.html">meta_function_descriptor&lt; Type, Ret(Class::*)(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_01Class_1_1_5_01_4.html">meta_function_descriptor&lt; Type, Ret Class::* &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_01Class_1_1_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07MaybeType_00_01Args_8_8_8_08_4.html">meta_function_descriptor&lt; Type, Ret(*)(MaybeType, Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07MaybeType_00_01Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07_08_4.html">meta_function_descriptor&lt; Type, Ret(*)()&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function helper.  <a href="classentt_1_1meta__function__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__poly.html">basic_poly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static polymorphism made simple and within everyone's reach.  <a href="classentt_1_1basic__poly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1poly__inspector.html">poly_inspector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspector class used to infer the type of the virtual table.  <a href="structentt_1_1poly__inspector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1poly__vtable.html">poly_vtable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static virtual table factory.  <a href="classentt_1_1poly__vtable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1poly__base.html">poly_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poly base class used to inject functionalities into concepts.  <a href="structentt_1_1poly__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1process.html">process</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for processes.  <a href="classentt_1_1process.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1process__adaptor.html">process_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor for lambdas and functors to turn them into processes.  <a href="structentt_1_1process__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1scheduler.html">scheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooperative scheduler for processes.  <a href="classentt_1_1scheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1resource__cache.html">resource_cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple cache for resources of a given type.  <a href="classentt_1_1resource__cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1resource__handle.html">resource_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared resource handle.  <a href="classentt_1_1resource__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1resource__loader.html">resource_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for resource loaders.  <a href="classentt_1_1resource__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to wrap a function or a member of a specified type.  <a href="structentt_1_1connect__arg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1delegate.html">delegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic delegate implementation.  <a href="classentt_1_1delegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1delegate_3_01Ret_07Args_8_8_8_08_4.html">delegate&lt; Ret(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to use to send around functions and members.  <a href="classentt_1_1delegate_3_01Ret_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1dispatcher.html">dispatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic dispatcher implementation.  <a href="classentt_1_1dispatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1emitter.html">emitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose event emitter.  <a href="classentt_1_1emitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sink.html">sink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink class.  <a href="classentt_1_1sink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh.html">sigh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmanaged signal handler.  <a href="classentt_1_1sigh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh_3_01Ret_07Args_8_8_8_08_00_01Allocator_01_4.html">sigh&lt; Ret(Args...), Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmanaged signal handler.  <a href="classentt_1_1sigh_3_01Ret_07Args_8_8_8_08_00_01Allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1connection.html">connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection class.  <a href="classentt_1_1connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1scoped__connection.html">scoped_connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scoped connection class.  <a href="structentt_1_1scoped__connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sink_3_01sigh_3_01Ret_07Args_8_8_8_08_00_01Allocator_01_4_01_4.html">sink&lt; sigh&lt; Ret(Args...), Allocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink class.  <a href="classentt_1_1sink_3_01sigh_3_01Ret_07Args_8_8_8_08_00_01Allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a13e040e7b38a8f86d1ab2f096f37b627"><td class="memItemLeft" align="right" valign="top"><a id="a13e040e7b38a8f86d1ab2f096f37b627"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> = std::uint32_t</td></tr>
<tr class="memdesc:a13e040e7b38a8f86d1ab2f096f37b627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for type identifiers. <br /></td></tr>
<tr class="separator:a13e040e7b38a8f86d1ab2f096f37b627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4846741b8f485584c196304f588b94ad"><td class="memItemLeft" align="right" valign="top"><a id="a4846741b8f485584c196304f588b94ad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4846741b8f485584c196304f588b94ad">any</a> = <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt;&gt;</td></tr>
<tr class="memdesc:a4846741b8f485584c196304f588b94ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a4846741b8f485584c196304f588b94ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9dd22ce26cd7913a294b3fd520649b"><td class="memItemLeft" align="right" valign="top"><a id="a8f9dd22ce26cd7913a294b3fd520649b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">hashed_string</a> = <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a8f9dd22ce26cd7913a294b3fd520649b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases for common character types. <br /></td></tr>
<tr class="separator:a8f9dd22ce26cd7913a294b3fd520649b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2768719b1f5967caf5836b2656d0ed6"><td class="memItemLeft" align="right" valign="top"><a id="af2768719b1f5967caf5836b2656d0ed6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">hashed_wstring</a> = <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; wchar_t &gt;</td></tr>
<tr class="memdesc:af2768719b1f5967caf5836b2656d0ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases for common character types. <br /></td></tr>
<tr class="separator:af2768719b1f5967caf5836b2656d0ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a09f6bd6b4aebc03df720e7e69fdc6643">type_identity_t</a> = typename <a class="el" href="structentt_1_1type__identity.html">type_identity</a>&lt; Type &gt;::type</td></tr>
<tr class="memdesc:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a09f6bd6b4aebc03df720e7e69fdc6643">More...</a><br /></td></tr>
<tr class="separator:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62c84ccab78132ef356b13e4ff12dfa"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename &gt; </td></tr>
<tr class="memitem:ae62c84ccab78132ef356b13e4ff12dfa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae62c84ccab78132ef356b13e4ff12dfa">unpack_as_type</a> = Type</td></tr>
<tr class="memdesc:ae62c84ccab78132ef356b13e4ff12dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using declaration to be used to <em>repeat</em> the same type a number of times equal to the size of a given parameter pack.  <a href="namespaceentt.html#ae62c84ccab78132ef356b13e4ff12dfa">More...</a><br /></td></tr>
<tr class="separator:ae62c84ccab78132ef356b13e4ff12dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9fd5898acf13553bbcf14b99159f4d"><td class="memTemplParams" colspan="2">template&lt;auto Value&gt; </td></tr>
<tr class="memitem:a0d9fd5898acf13553bbcf14b99159f4d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">integral_constant</a> = std::integral_constant&lt; decltype(Value), Value &gt;</td></tr>
<tr class="memdesc:a0d9fd5898acf13553bbcf14b99159f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a static constant.  <a href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">More...</a><br /></td></tr>
<tr class="separator:a0d9fd5898acf13553bbcf14b99159f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="memTemplParams" colspan="2">template&lt;id_type Value&gt; </td></tr>
<tr class="memitem:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a9f7bb8c357f08a01ad9c8dab0ea40c1c">tag</a> = <a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">integral_constant</a>&lt; Value &gt;</td></tr>
<tr class="memdesc:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template to facilitate the creation of named values.  <a href="namespaceentt.html#a9f7bb8c357f08a01ad9c8dab0ea40c1c">More...</a><br /></td></tr>
<tr class="separator:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac839c1a03dba2436791d0056d6d0d1b6"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename List &gt; </td></tr>
<tr class="memitem:ac839c1a03dba2436791d0056d6d0d1b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac839c1a03dba2436791d0056d6d0d1b6">type_list_element_t</a> = typename <a class="el" href="structentt_1_1type__list__element.html">type_list_element</a>&lt; Index, List &gt;::type</td></tr>
<tr class="memdesc:ac839c1a03dba2436791d0056d6d0d1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#ac839c1a03dba2436791d0056d6d0d1b6">More...</a><br /></td></tr>
<tr class="separator:ac839c1a03dba2436791d0056d6d0d1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546467a3662e9a915d5d519ad565e801"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:a546467a3662e9a915d5d519ad565e801"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">type_list_cat_t</a> = typename <a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a>&lt; List... &gt;::type</td></tr>
<tr class="memdesc:a546467a3662e9a915d5d519ad565e801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">More...</a><br /></td></tr>
<tr class="separator:a546467a3662e9a915d5d519ad565e801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a277a6037279d65cd3874b46ec7166"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a75a277a6037279d65cd3874b46ec7166"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">type_list_unique_t</a> = typename <a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a>&lt; Type &gt;::type</td></tr>
<tr class="memdesc:a75a277a6037279d65cd3874b46ec7166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">More...</a><br /></td></tr>
<tr class="separator:a75a277a6037279d65cd3874b46ec7166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2992fc009cb3199b0ef9a86bed2285c"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:af2992fc009cb3199b0ef9a86bed2285c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af2992fc009cb3199b0ef9a86bed2285c">type_list_diff_t</a> = typename <a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a>&lt; List... &gt;::type</td></tr>
<tr class="memdesc:af2992fc009cb3199b0ef9a86bed2285c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#af2992fc009cb3199b0ef9a86bed2285c">More...</a><br /></td></tr>
<tr class="separator:af2992fc009cb3199b0ef9a86bed2285c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1344cc62598091397018354e6905e431"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:a1344cc62598091397018354e6905e431"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a1344cc62598091397018354e6905e431">value_list_cat_t</a> = typename <a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a>&lt; List... &gt;::type</td></tr>
<tr class="memdesc:a1344cc62598091397018354e6905e431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a1344cc62598091397018354e6905e431">More...</a><br /></td></tr>
<tr class="separator:a1344cc62598091397018354e6905e431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b051461867d3c5c97f77f10b662c26b"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a7b051461867d3c5c97f77f10b662c26b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">constness_as_t</a> = typename <a class="el" href="structentt_1_1constness__as.html">constness_as</a>&lt; To, From &gt;::type</td></tr>
<tr class="memdesc:a7b051461867d3c5c97f77f10b662c26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template to facilitate the transcription of the constness.  <a href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">More...</a><br /></td></tr>
<tr class="separator:a7b051461867d3c5c97f77f10b662c26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="memTemplParams" colspan="2">template&lt;typename Member &gt; </td></tr>
<tr class="memitem:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a49f19d031690e5ebfffd6c7a4f6bd364">member_class_t</a> = typename <a class="el" href="classentt_1_1member__class.html">member_class</a>&lt; Member &gt;::type</td></tr>
<tr class="memdesc:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a49f19d031690e5ebfffd6c7a4f6bd364">More...</a><br /></td></tr>
<tr class="separator:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27c0013e504d544508cdacc01170b68"><td class="memItemLeft" align="right" valign="top"><a id="ac27c0013e504d544508cdacc01170b68"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac27c0013e504d544508cdacc01170b68">sparse_set</a> = <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:ac27c0013e504d544508cdacc01170b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:ac27c0013e504d544508cdacc01170b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcedb8f29753130e2bf3185bca211f05"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abcedb8f29753130e2bf3185bca211f05"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abcedb8f29753130e2bf3185bca211f05">storage</a> = <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args... &gt;</td></tr>
<tr class="memdesc:abcedb8f29753130e2bf3185bca211f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#abcedb8f29753130e2bf3185bca211f05">More...</a><br /></td></tr>
<tr class="separator:abcedb8f29753130e2bf3185bca211f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292643317d1dbb13e45824f757bd1086"><td class="memItemLeft" align="right" valign="top"><a id="a292643317d1dbb13e45824f757bd1086"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a292643317d1dbb13e45824f757bd1086">registry</a> = <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a292643317d1dbb13e45824f757bd1086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a292643317d1dbb13e45824f757bd1086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dfbb2991c5a19c6e2578830f7e3eda"><td class="memItemLeft" align="right" valign="top"><a id="a48dfbb2991c5a19c6e2578830f7e3eda"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a48dfbb2991c5a19c6e2578830f7e3eda">observer</a> = <a class="el" href="classentt_1_1basic__observer.html">basic_observer</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a48dfbb2991c5a19c6e2578830f7e3eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a48dfbb2991c5a19c6e2578830f7e3eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5870a148e25a503557bdd47327c7a05a"><td class="memItemLeft" align="right" valign="top"><a id="a5870a148e25a503557bdd47327c7a05a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5870a148e25a503557bdd47327c7a05a">organizer</a> = <a class="el" href="classentt_1_1basic__organizer.html">basic_organizer</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a5870a148e25a503557bdd47327c7a05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a5870a148e25a503557bdd47327c7a05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0027b922894421f703102c374c234c"><td class="memItemLeft" align="right" valign="top"><a id="a5a0027b922894421f703102c374c234c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5a0027b922894421f703102c374c234c">handle</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a5a0027b922894421f703102c374c234c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a5a0027b922894421f703102c374c234c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ab1aae5e5786a3ebb3b9bf1c7e82bd"><td class="memItemLeft" align="right" valign="top"><a id="a54ab1aae5e5786a3ebb3b9bf1c7e82bd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a54ab1aae5e5786a3ebb3b9bf1c7e82bd">const_handle</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; const <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a54ab1aae5e5786a3ebb3b9bf1c7e82bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a54ab1aae5e5786a3ebb3b9bf1c7e82bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5809ceb50ec17713e8690c20a79490"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aaa5809ceb50ec17713e8690c20a79490"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aaa5809ceb50ec17713e8690c20a79490">handle_view</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args... &gt;</td></tr>
<tr class="memdesc:aaa5809ceb50ec17713e8690c20a79490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#aaa5809ceb50ec17713e8690c20a79490">More...</a><br /></td></tr>
<tr class="separator:aaa5809ceb50ec17713e8690c20a79490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfeed27a790ac90eb5989da8a3ea860"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aedfeed27a790ac90eb5989da8a3ea860"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aedfeed27a790ac90eb5989da8a3ea860">const_handle_view</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; const <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args... &gt;</td></tr>
<tr class="memdesc:aedfeed27a790ac90eb5989da8a3ea860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#aedfeed27a790ac90eb5989da8a3ea860">More...</a><br /></td></tr>
<tr class="separator:aedfeed27a790ac90eb5989da8a3ea860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80012f9fa628920a3507ae947704d447"><td class="memItemLeft" align="right" valign="top"><a id="a80012f9fa628920a3507ae947704d447"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a80012f9fa628920a3507ae947704d447">snapshot</a> = <a class="el" href="classentt_1_1basic__snapshot.html">basic_snapshot</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a80012f9fa628920a3507ae947704d447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a80012f9fa628920a3507ae947704d447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e50fc296c4ea68183db332950b99f5"><td class="memItemLeft" align="right" valign="top"><a id="ae7e50fc296c4ea68183db332950b99f5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae7e50fc296c4ea68183db332950b99f5">snapshot_loader</a> = <a class="el" href="classentt_1_1basic__snapshot__loader.html">basic_snapshot_loader</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:ae7e50fc296c4ea68183db332950b99f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:ae7e50fc296c4ea68183db332950b99f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b5b489846f6f2a5d143db2b4aea5d0"><td class="memItemLeft" align="right" valign="top"><a id="a37b5b489846f6f2a5d143db2b4aea5d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a37b5b489846f6f2a5d143db2b4aea5d0">continuous_loader</a> = <a class="el" href="classentt_1_1basic__continuous__loader.html">basic_continuous_loader</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a37b5b489846f6f2a5d143db2b4aea5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a37b5b489846f6f2a5d143db2b4aea5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b7ba6bd51a290113765bc97188d247"><td class="memTemplParams" colspan="2">template&lt;typename Get , typename Exclude  = exclude_t&lt;&gt;&gt; </td></tr>
<tr class="memitem:a87b7ba6bd51a290113765bc97188d247"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a87b7ba6bd51a290113765bc97188d247">view</a> = <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Get, Exclude &gt;</td></tr>
<tr class="memdesc:a87b7ba6bd51a290113765bc97188d247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a87b7ba6bd51a290113765bc97188d247">More...</a><br /></td></tr>
<tr class="separator:a87b7ba6bd51a290113765bc97188d247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d470a55d982d87388e899c322e9ddc"><td class="memItemLeft" align="right" valign="top"><a id="a85d470a55d982d87388e899c322e9ddc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a85d470a55d982d87388e899c322e9ddc">runtime_view</a> = <a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a85d470a55d982d87388e899c322e9ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a85d470a55d982d87388e899c322e9ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2628e82fa8042f75d817c58fc09c7aaf"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2628e82fa8042f75d817c58fc09c7aaf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2628e82fa8042f75d817c58fc09c7aaf">group</a> = <a class="el" href="classentt_1_1basic__group.html">basic_group</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args... &gt;</td></tr>
<tr class="memdesc:a2628e82fa8042f75d817c58fc09c7aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a2628e82fa8042f75d817c58fc09c7aaf">More...</a><br /></td></tr>
<tr class="separator:a2628e82fa8042f75d817c58fc09c7aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692beabf853ee0f9dc68beab816a6b27"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Candidate &gt; </td></tr>
<tr class="memitem:a692beabf853ee0f9dc68beab816a6b27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a692beabf853ee0f9dc68beab816a6b27">meta_function_helper_t</a> = typename <a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a>&lt; Type, Candidate &gt;::type</td></tr>
<tr class="memdesc:a692beabf853ee0f9dc68beab816a6b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a692beabf853ee0f9dc68beab816a6b27">More...</a><br /></td></tr>
<tr class="separator:a692beabf853ee0f9dc68beab816a6b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3d1f1d0e83ad8f124155c9e511c2cd"><td class="memTemplParams" colspan="2">template&lt;typename Concept &gt; </td></tr>
<tr class="memitem:aad3d1f1d0e83ad8f124155c9e511c2cd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aad3d1f1d0e83ad8f124155c9e511c2cd">poly</a> = <a class="el" href="classentt_1_1basic__poly.html">basic_poly</a>&lt; Concept, sizeof(double[2])&gt;</td></tr>
<tr class="memdesc:aad3d1f1d0e83ad8f124155c9e511c2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#aad3d1f1d0e83ad8f124155c9e511c2cd">More...</a><br /></td></tr>
<tr class="separator:aad3d1f1d0e83ad8f124155c9e511c2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0b54e231d069e8a231e14b223388808a"><td class="memItemLeft" align="right" valign="top"><a id="a0b54e231d069e8a231e14b223388808a"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> : id_type </td></tr>
<tr class="memdesc:a0b54e231d069e8a231e14b223388808a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default entity identifier. <br /></td></tr>
<tr class="separator:a0b54e231d069e8a231e14b223388808a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4d0fa77fae26e7c01793990996c581"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a> : std::uint8_t { <a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581a8223d1ccb16b6dd0b19fe9c6fdb13708">swap_and_pop</a> = 0u
, <a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581aa49f99ae99ae9daddd1fb79b73d2db28">in_place</a> = 1u
 }</td></tr>
<tr class="memdesc:abc4d0fa77fae26e7c01793990996c581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse set deletion policy.  <a href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">More...</a><br /></td></tr>
<tr class="separator:abc4d0fa77fae26e7c01793990996c581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae38ac5bc7b9097ec21eb1058db206cff"><td class="memTemplParams" colspan="2">template&lt;std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:ae38ac5bc7b9097ec21eb1058db206cff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae38ac5bc7b9097ec21eb1058db206cff">operator!=</a> (const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae38ac5bc7b9097ec21eb1058db206cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two wrappers differ in their content.  <a href="namespaceentt.html#ae38ac5bc7b9097ec21eb1058db206cff">More...</a><br /></td></tr>
<tr class="separator:ae38ac5bc7b9097ec21eb1058db206cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2364ab41cab0fccd92cdaaf8779581cb"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:a2364ab41cab0fccd92cdaaf8779581cb"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2364ab41cab0fccd92cdaaf8779581cb">any_cast</a> (const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;data)</td></tr>
<tr class="memdesc:a2364ab41cab0fccd92cdaaf8779581cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#a2364ab41cab0fccd92cdaaf8779581cb">More...</a><br /></td></tr>
<tr class="separator:a2364ab41cab0fccd92cdaaf8779581cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c210bb2e08d184415f5c5680d87d74e"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:a7c210bb2e08d184415f5c5680d87d74e"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7c210bb2e08d184415f5c5680d87d74e">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;data)</td></tr>
<tr class="memdesc:a7c210bb2e08d184415f5c5680d87d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#a7c210bb2e08d184415f5c5680d87d74e">More...</a><br /></td></tr>
<tr class="separator:a7c210bb2e08d184415f5c5680d87d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ade9ac7c0844a7c154287ca96ceba08"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:a1ade9ac7c0844a7c154287ca96ceba08"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a1ade9ac7c0844a7c154287ca96ceba08">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&amp;data)</td></tr>
<tr class="memdesc:a1ade9ac7c0844a7c154287ca96ceba08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#a1ade9ac7c0844a7c154287ca96ceba08">More...</a><br /></td></tr>
<tr class="separator:a1ade9ac7c0844a7c154287ca96ceba08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf3e0080cf2091703718dcbe558171b"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:aeaf3e0080cf2091703718dcbe558171b"><td class="memTemplItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aeaf3e0080cf2091703718dcbe558171b">any_cast</a> (const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *data)</td></tr>
<tr class="memdesc:aeaf3e0080cf2091703718dcbe558171b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#aeaf3e0080cf2091703718dcbe558171b">More...</a><br /></td></tr>
<tr class="separator:aeaf3e0080cf2091703718dcbe558171b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53c0786eb32685bbbfc6a2b9806338b"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:ac53c0786eb32685bbbfc6a2b9806338b"><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac53c0786eb32685bbbfc6a2b9806338b">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *data)</td></tr>
<tr class="memdesc:ac53c0786eb32685bbbfc6a2b9806338b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#ac53c0786eb32685bbbfc6a2b9806338b">More...</a><br /></td></tr>
<tr class="separator:ac53c0786eb32685bbbfc6a2b9806338b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246375cb799b9dc67b9a555f91d94099"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename... Args&gt; </td></tr>
<tr class="memitem:a246375cb799b9dc67b9a555f91d94099"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a246375cb799b9dc67b9a555f91d94099">make_any</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a246375cb799b9dc67b9a555f91d94099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a wrapper from a given type, passing it all arguments.  <a href="namespaceentt.html#a246375cb799b9dc67b9a555f91d94099">More...</a><br /></td></tr>
<tr class="separator:a246375cb799b9dc67b9a555f91d94099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810f66c2c91deba50f96cae9119f2feb"><td class="memTemplParams" colspan="2">template&lt;std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename Type &gt; </td></tr>
<tr class="memitem:a810f66c2c91deba50f96cae9119f2feb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a810f66c2c91deba50f96cae9119f2feb">forward_as_any</a> (Type &amp;&amp;value)</td></tr>
<tr class="memdesc:a810f66c2c91deba50f96cae9119f2feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards its argument and avoids copies for lvalue references.  <a href="namespaceentt.html#a810f66c2c91deba50f96cae9119f2feb">More...</a><br /></td></tr>
<tr class="separator:a810f66c2c91deba50f96cae9119f2feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af638f85aa855e8364af76d8bf93eee3b"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Other &gt; </td></tr>
<tr class="memitem:af638f85aa855e8364af76d8bf93eee3b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af638f85aa855e8364af76d8bf93eee3b">compressed_pair</a> (Type &amp;&amp;, Other &amp;&amp;) -&gt; <a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; std::decay_t&lt; Type &gt;, std::decay_t&lt; Other &gt;&gt;</td></tr>
<tr class="memdesc:af638f85aa855e8364af76d8bf93eee3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#af638f85aa855e8364af76d8bf93eee3b">More...</a><br /></td></tr>
<tr class="separator:af638f85aa855e8364af76d8bf93eee3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef08fc4202f32f712bde26f55db463cb"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second &gt; </td></tr>
<tr class="memitem:aef08fc4202f32f712bde26f55db463cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aef08fc4202f32f712bde26f55db463cb">swap</a> (<a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; First, Second &gt; &amp;lhs, <a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; First, Second &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aef08fc4202f32f712bde26f55db463cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two compressed pair objects.  <a href="namespaceentt.html#aef08fc4202f32f712bde26f55db463cb">More...</a><br /></td></tr>
<tr class="separator:aef08fc4202f32f712bde26f55db463cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa97361ef962166a4fc51a582d7c6392"><td class="memTemplParams" colspan="2">template&lt;typename Char , std::size_t N&gt; </td></tr>
<tr class="memitem:aaa97361ef962166a4fc51a582d7c6392"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aaa97361ef962166a4fc51a582d7c6392">basic_hashed_string</a> (const Char(&amp;str)[N]) -&gt; <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt;</td></tr>
<tr class="memdesc:aaa97361ef962166a4fc51a582d7c6392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#aaa97361ef962166a4fc51a582d7c6392">More...</a><br /></td></tr>
<tr class="separator:aaa97361ef962166a4fc51a582d7c6392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b2e32d6df969a3d20a8f263265fe96"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:a07b2e32d6df969a3d20a8f263265fe96"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a07b2e32d6df969a3d20a8f263265fe96">operator==</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a07b2e32d6df969a3d20a8f263265fe96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#a07b2e32d6df969a3d20a8f263265fe96">More...</a><br /></td></tr>
<tr class="separator:a07b2e32d6df969a3d20a8f263265fe96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac200eb460760246368bb737dc434c0eb"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:ac200eb460760246368bb737dc434c0eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac200eb460760246368bb737dc434c0eb">operator!=</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac200eb460760246368bb737dc434c0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#ac200eb460760246368bb737dc434c0eb">More...</a><br /></td></tr>
<tr class="separator:ac200eb460760246368bb737dc434c0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95abccf779882bf65c4bb1cb99b8059c"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:a95abccf779882bf65c4bb1cb99b8059c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a95abccf779882bf65c4bb1cb99b8059c">operator&lt;</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a95abccf779882bf65c4bb1cb99b8059c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#a95abccf779882bf65c4bb1cb99b8059c">More...</a><br /></td></tr>
<tr class="separator:a95abccf779882bf65c4bb1cb99b8059c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400fd2e18a1fe98013bd4cdb281ad98f"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:a400fd2e18a1fe98013bd4cdb281ad98f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a400fd2e18a1fe98013bd4cdb281ad98f">operator&lt;=</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a400fd2e18a1fe98013bd4cdb281ad98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#a400fd2e18a1fe98013bd4cdb281ad98f">More...</a><br /></td></tr>
<tr class="separator:a400fd2e18a1fe98013bd4cdb281ad98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affca347714c6771f1f5928f1c18a070f"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:affca347714c6771f1f5928f1c18a070f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#affca347714c6771f1f5928f1c18a070f">operator&gt;</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs)</td></tr>
<tr class="memdesc:affca347714c6771f1f5928f1c18a070f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#affca347714c6771f1f5928f1c18a070f">More...</a><br /></td></tr>
<tr class="separator:affca347714c6771f1f5928f1c18a070f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d583f542e17fa8eb56d8d01c34b8920"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:a5d583f542e17fa8eb56d8d01c34b8920"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5d583f542e17fa8eb56d8d01c34b8920">operator&gt;=</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5d583f542e17fa8eb56d8d01c34b8920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#a5d583f542e17fa8eb56d8d01c34b8920">More...</a><br /></td></tr>
<tr class="separator:a5d583f542e17fa8eb56d8d01c34b8920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556190d147a6a92fc16bbf31bd4b263a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">entt::hashed_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a556190d147a6a92fc16bbf31bd4b263a">operator&quot;&quot;_hs</a> (const char *str, std::size_t)</td></tr>
<tr class="memdesc:a556190d147a6a92fc16bbf31bd4b263a"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined literal for hashed strings.  <a href="namespaceentt.html#a556190d147a6a92fc16bbf31bd4b263a">More...</a><br /></td></tr>
<tr class="separator:a556190d147a6a92fc16bbf31bd4b263a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226e03b3f52eb1bbce832ec53106bd6a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">entt::hashed_wstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a226e03b3f52eb1bbce832ec53106bd6a">operator&quot;&quot;_hws</a> (const wchar_t *str, std::size_t)</td></tr>
<tr class="memdesc:a226e03b3f52eb1bbce832ec53106bd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined literal for hashed wstrings.  <a href="namespaceentt.html#a226e03b3f52eb1bbce832ec53106bd6a">More...</a><br /></td></tr>
<tr class="separator:a226e03b3f52eb1bbce832ec53106bd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ed50d1975e6adee73101eb05c88d73"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a94ed50d1975e6adee73101eb05c88d73"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a94ed50d1975e6adee73101eb05c88d73">to_address</a> (Type &amp;&amp;ptr)</td></tr>
<tr class="memdesc:a94ed50d1975e6adee73101eb05c88d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps fancy pointers, does nothing otherwise (waiting for C++20).  <a href="namespaceentt.html#a94ed50d1975e6adee73101eb05c88d73">More...</a><br /></td></tr>
<tr class="separator:a94ed50d1975e6adee73101eb05c88d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb49df8bf1b69e836039b76e5b9938e"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a9eb49df8bf1b69e836039b76e5b9938e"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a9eb49df8bf1b69e836039b76e5b9938e">propagate_on_container_copy_assignment</a> ([[maybe_unused]] Allocator &amp;lhs, [[maybe_unused]] Allocator &amp;rhs)</td></tr>
<tr class="memdesc:a9eb49df8bf1b69e836039b76e5b9938e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to design allocation-aware containers.  <a href="namespaceentt.html#a9eb49df8bf1b69e836039b76e5b9938e">More...</a><br /></td></tr>
<tr class="separator:a9eb49df8bf1b69e836039b76e5b9938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122ae54373a080574c45c77319cec7f7"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a122ae54373a080574c45c77319cec7f7"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a122ae54373a080574c45c77319cec7f7">propagate_on_container_move_assignment</a> ([[maybe_unused]] Allocator &amp;lhs, [[maybe_unused]] Allocator &amp;rhs)</td></tr>
<tr class="memdesc:a122ae54373a080574c45c77319cec7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to design allocation-aware containers.  <a href="namespaceentt.html#a122ae54373a080574c45c77319cec7f7">More...</a><br /></td></tr>
<tr class="separator:a122ae54373a080574c45c77319cec7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1359cd624e6726f884df34df66656855"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a1359cd624e6726f884df34df66656855"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a1359cd624e6726f884df34df66656855">propagate_on_container_swap</a> ([[maybe_unused]] Allocator &amp;lhs, [[maybe_unused]] Allocator &amp;rhs)</td></tr>
<tr class="memdesc:a1359cd624e6726f884df34df66656855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to design allocation-aware containers.  <a href="namespaceentt.html#a1359cd624e6726f884df34df66656855">More...</a><br /></td></tr>
<tr class="separator:a1359cd624e6726f884df34df66656855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3755517604de1d9d3f3e0a5549c750c5"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3755517604de1d9d3f3e0a5549c750c5">is_power_of_two</a> (const std::size_t value)</td></tr>
<tr class="memdesc:a3755517604de1d9d3f3e0a5549c750c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a value is a power of two or not.  <a href="namespaceentt.html#a3755517604de1d9d3f3e0a5549c750c5">More...</a><br /></td></tr>
<tr class="separator:a3755517604de1d9d3f3e0a5549c750c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2dbf5d86123af800abdd8fe69542ca"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5a2dbf5d86123af800abdd8fe69542ca">next_power_of_two</a> (const std::size_t value)</td></tr>
<tr class="memdesc:a5a2dbf5d86123af800abdd8fe69542ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest power of two greater than or equal to a value.  <a href="namespaceentt.html#a5a2dbf5d86123af800abdd8fe69542ca">More...</a><br /></td></tr>
<tr class="separator:a5a2dbf5d86123af800abdd8fe69542ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fe7952c2a11ebc2b47d95fb749adda"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a28fe7952c2a11ebc2b47d95fb749adda">fast_mod</a> (const std::size_t value, const std::size_t mod)</td></tr>
<tr class="memdesc:a28fe7952c2a11ebc2b47d95fb749adda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast module utility function (powers of two only).  <a href="namespaceentt.html#a28fe7952c2a11ebc2b47d95fb749adda">More...</a><br /></td></tr>
<tr class="separator:a28fe7952c2a11ebc2b47d95fb749adda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ad46972bf4848e06a728c232b94bf0"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a29ad46972bf4848e06a728c232b94bf0"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a29ad46972bf4848e06a728c232b94bf0">unwrap_tuple</a> (Type &amp;&amp;value)</td></tr>
<tr class="memdesc:a29ad46972bf4848e06a728c232b94bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to unwrap tuples of a single element.  <a href="namespaceentt.html#a29ad46972bf4848e06a728c232b94bf0">More...</a><br /></td></tr>
<tr class="separator:a29ad46972bf4848e06a728c232b94bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f95d943a5794e7f7b481d3e02a2d96"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a13f95d943a5794e7f7b481d3e02a2d96">operator==</a> (const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;rhs)</td></tr>
<tr class="memdesc:a13f95d943a5794e7f7b481d3e02a2d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two type info objects.  <a href="namespaceentt.html#a13f95d943a5794e7f7b481d3e02a2d96">More...</a><br /></td></tr>
<tr class="separator:a13f95d943a5794e7f7b481d3e02a2d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6b2e64d7d0ca7bd46c4fc9009cb552"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5b6b2e64d7d0ca7bd46c4fc9009cb552">operator!=</a> (const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;rhs)</td></tr>
<tr class="memdesc:a5b6b2e64d7d0ca7bd46c4fc9009cb552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two type info objects.  <a href="namespaceentt.html#a5b6b2e64d7d0ca7bd46c4fc9009cb552">More...</a><br /></td></tr>
<tr class="separator:a5b6b2e64d7d0ca7bd46c4fc9009cb552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2789bea84be3354b9ec3f48b0af539c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac2789bea84be3354b9ec3f48b0af539c">operator&lt;</a> (const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;rhs)</td></tr>
<tr class="memdesc:ac2789bea84be3354b9ec3f48b0af539c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two type info objects.  <a href="namespaceentt.html#ac2789bea84be3354b9ec3f48b0af539c">More...</a><br /></td></tr>
<tr class="separator:ac2789bea84be3354b9ec3f48b0af539c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99351681df5ffc84efcc14603ab6fc3"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac99351681df5ffc84efcc14603ab6fc3">operator&lt;=</a> (const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;rhs)</td></tr>
<tr class="memdesc:ac99351681df5ffc84efcc14603ab6fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two type info objects.  <a href="namespaceentt.html#ac99351681df5ffc84efcc14603ab6fc3">More...</a><br /></td></tr>
<tr class="separator:ac99351681df5ffc84efcc14603ab6fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f32860fd6de66a832389b365045047"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a28f32860fd6de66a832389b365045047">operator&gt;</a> (const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;rhs)</td></tr>
<tr class="memdesc:a28f32860fd6de66a832389b365045047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two type info objects.  <a href="namespaceentt.html#a28f32860fd6de66a832389b365045047">More...</a><br /></td></tr>
<tr class="separator:a28f32860fd6de66a832389b365045047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6acc16fe38d13c69b5d1fb237e4ac5"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2e6acc16fe38d13c69b5d1fb237e4ac5">operator&gt;=</a> (const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;rhs)</td></tr>
<tr class="memdesc:a2e6acc16fe38d13c69b5d1fb237e4ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two type info objects.  <a href="namespaceentt.html#a2e6acc16fe38d13c69b5d1fb237e4ac5">More...</a><br /></td></tr>
<tr class="separator:a2e6acc16fe38d13c69b5d1fb237e4ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2dcd5e9e474d7ab0f2db24dae09dd5"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a2e2dcd5e9e474d7ab0f2db24dae09dd5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2e2dcd5e9e474d7ab0f2db24dae09dd5">type_id</a> ()</td></tr>
<tr class="memdesc:a2e2dcd5e9e474d7ab0f2db24dae09dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type info object associated to a given type.  <a href="namespaceentt.html#a2e2dcd5e9e474d7ab0f2db24dae09dd5">More...</a><br /></td></tr>
<tr class="separator:a2e2dcd5e9e474d7ab0f2db24dae09dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6e966c8af5b1452811aa55adbbdf47"><td class="memTemplParams" colspan="2">template&lt;typename... Type, typename... Other&gt; </td></tr>
<tr class="memitem:a6c6e966c8af5b1452811aa55adbbdf47"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type..., Other... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6c6e966c8af5b1452811aa55adbbdf47">operator+</a> (<a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type... &gt;, <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Other... &gt;)</td></tr>
<tr class="memdesc:a6c6e966c8af5b1452811aa55adbbdf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="namespaceentt.html#a6c6e966c8af5b1452811aa55adbbdf47">More...</a><br /></td></tr>
<tr class="separator:a6c6e966c8af5b1452811aa55adbbdf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc6dd5fb4d2bc92d9e5101b7b0bce1d"><td class="memTemplParams" colspan="2">template&lt;auto... Value, auto... Other&gt; </td></tr>
<tr class="memitem:aabc6dd5fb4d2bc92d9e5101b7b0bce1d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value..., Other... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aabc6dd5fb4d2bc92d9e5101b7b0bce1d">operator+</a> (<a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value... &gt;, <a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Other... &gt;)</td></tr>
<tr class="memdesc:aabc6dd5fb4d2bc92d9e5101b7b0bce1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="namespaceentt.html#aabc6dd5fb4d2bc92d9e5101b7b0bce1d">More...</a><br /></td></tr>
<tr class="separator:aabc6dd5fb4d2bc92d9e5101b7b0bce1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386a739051d9d37a5578785b77fc426b"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Class &gt; </td></tr>
<tr class="memitem:a386a739051d9d37a5578785b77fc426b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a386a739051d9d37a5578785b77fc426b">overload</a> (Type Class::*member)</td></tr>
<tr class="memdesc:a386a739051d9d37a5578785b77fc426b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant utility to disambiguate overloaded members of a class.  <a href="namespaceentt.html#a386a739051d9d37a5578785b77fc426b">More...</a><br /></td></tr>
<tr class="separator:a386a739051d9d37a5578785b77fc426b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ea6822ef21f52c732ba3baea450159"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ad4ea6822ef21f52c732ba3baea450159"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad4ea6822ef21f52c732ba3baea450159">overload</a> (Func *func)</td></tr>
<tr class="memdesc:ad4ea6822ef21f52c732ba3baea450159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant utility to disambiguate overloaded functions.  <a href="namespaceentt.html#ad4ea6822ef21f52c732ba3baea450159">More...</a><br /></td></tr>
<tr class="separator:ad4ea6822ef21f52c732ba3baea450159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eb67ac302229374c5fb623d529f5eb"><td class="memTemplParams" colspan="2">template&lt;class... Func&gt; </td></tr>
<tr class="memitem:a26eb67ac302229374c5fb623d529f5eb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a26eb67ac302229374c5fb623d529f5eb">overloaded</a> (Func...) -&gt; <a class="el" href="structentt_1_1overloaded.html">overloaded</a>&lt; Func... &gt;</td></tr>
<tr class="memdesc:a26eb67ac302229374c5fb623d529f5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a26eb67ac302229374c5fb623d529f5eb">More...</a><br /></td></tr>
<tr class="separator:a26eb67ac302229374c5fb623d529f5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7521f3d3ca914ea5bd131269ba75aa"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:abd7521f3d3ca914ea5bd131269ba75aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::entity_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abd7521f3d3ca914ea5bd131269ba75aa">to_integral</a> (const Entity value)</td></tr>
<tr class="memdesc:abd7521f3d3ca914ea5bd131269ba75aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an entity to its underlying type.  <a href="namespaceentt.html#abd7521f3d3ca914ea5bd131269ba75aa">More...</a><br /></td></tr>
<tr class="separator:abd7521f3d3ca914ea5bd131269ba75aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b0b05750caf25f9718c2bebf55d25c"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:ae1b0b05750caf25f9718c2bebf55d25c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::entity_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae1b0b05750caf25f9718c2bebf55d25c">to_entity</a> (const Entity value)</td></tr>
<tr class="memdesc:ae1b0b05750caf25f9718c2bebf55d25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity part once converted to the underlying type.  <a href="namespaceentt.html#ae1b0b05750caf25f9718c2bebf55d25c">More...</a><br /></td></tr>
<tr class="separator:ae1b0b05750caf25f9718c2bebf55d25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dc0f67afc2c0924dc2c0f51dcadadf"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:ae7dc0f67afc2c0924dc2c0f51dcadadf"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classentt_1_1entt__traits.html">entt_traits</a>&lt; Entity &gt;::version_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae7dc0f67afc2c0924dc2c0f51dcadadf">to_version</a> (const Entity value)</td></tr>
<tr class="memdesc:ae7dc0f67afc2c0924dc2c0f51dcadadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version part once converted to the underlying type.  <a href="namespaceentt.html#ae7dc0f67afc2c0924dc2c0f51dcadadf">More...</a><br /></td></tr>
<tr class="separator:ae7dc0f67afc2c0924dc2c0f51dcadadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6de691c4ec15d4a63ea8960563bbea0"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:af6de691c4ec15d4a63ea8960563bbea0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af6de691c4ec15d4a63ea8960563bbea0">operator==</a> (const Entity <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, const <a class="el" href="structentt_1_1null__t.html">null_t</a> other)</td></tr>
<tr class="memdesc:af6de691c4ec15d4a63ea8960563bbea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a null object and an identifier of any type.  <a href="namespaceentt.html#af6de691c4ec15d4a63ea8960563bbea0">More...</a><br /></td></tr>
<tr class="separator:af6de691c4ec15d4a63ea8960563bbea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6185f9faa3f9fa26ecb1b9a837016147"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a6185f9faa3f9fa26ecb1b9a837016147"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6185f9faa3f9fa26ecb1b9a837016147">operator!=</a> (const Entity <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, const <a class="el" href="structentt_1_1null__t.html">null_t</a> other)</td></tr>
<tr class="memdesc:a6185f9faa3f9fa26ecb1b9a837016147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a null object and an identifier of any type.  <a href="namespaceentt.html#a6185f9faa3f9fa26ecb1b9a837016147">More...</a><br /></td></tr>
<tr class="separator:a6185f9faa3f9fa26ecb1b9a837016147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f371da1ef604fa726a88e9733e5ee54"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a0f371da1ef604fa726a88e9733e5ee54"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0f371da1ef604fa726a88e9733e5ee54">operator==</a> (const Entity <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a> other)</td></tr>
<tr class="memdesc:a0f371da1ef604fa726a88e9733e5ee54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a tombstone object and an identifier of any type.  <a href="namespaceentt.html#a0f371da1ef604fa726a88e9733e5ee54">More...</a><br /></td></tr>
<tr class="separator:a0f371da1ef604fa726a88e9733e5ee54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39702a79d9ba6f5d7cb8668b0a7a1524"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a39702a79d9ba6f5d7cb8668b0a7a1524"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a39702a79d9ba6f5d7cb8668b0a7a1524">operator!=</a> (const Entity <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a> other)</td></tr>
<tr class="memdesc:a39702a79d9ba6f5d7cb8668b0a7a1524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a tombstone object and an identifier of any type.  <a href="namespaceentt.html#a39702a79d9ba6f5d7cb8668b0a7a1524">More...</a><br /></td></tr>
<tr class="separator:a39702a79d9ba6f5d7cb8668b0a7a1524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5fe16dfbb40ab097d339b0c008fae7"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename... Other&gt; </td></tr>
<tr class="memitem:aee5fe16dfbb40ab097d339b0c008fae7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aee5fe16dfbb40ab097d339b0c008fae7">operator==</a> (const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;lhs, const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Other... &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aee5fe16dfbb40ab097d339b0c008fae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <a href="namespaceentt.html#aee5fe16dfbb40ab097d339b0c008fae7">More...</a><br /></td></tr>
<tr class="separator:aee5fe16dfbb40ab097d339b0c008fae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef0d5ec3214e57aa4b8406fbe9ee3a5"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename... Other&gt; </td></tr>
<tr class="memitem:a7ef0d5ec3214e57aa4b8406fbe9ee3a5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7ef0d5ec3214e57aa4b8406fbe9ee3a5">operator!=</a> (const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;lhs, const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Other... &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7ef0d5ec3214e57aa4b8406fbe9ee3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <a href="namespaceentt.html#a7ef0d5ec3214e57aa4b8406fbe9ee3a5">More...</a><br /></td></tr>
<tr class="separator:a7ef0d5ec3214e57aa4b8406fbe9ee3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288ec07d4e87a28179d43b367ff11eab"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a288ec07d4e87a28179d43b367ff11eab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a288ec07d4e87a28179d43b367ff11eab">basic_handle</a> (<a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;, Entity) -&gt; <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Entity &gt;</td></tr>
<tr class="memdesc:a288ec07d4e87a28179d43b367ff11eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a288ec07d4e87a28179d43b367ff11eab">More...</a><br /></td></tr>
<tr class="separator:a288ec07d4e87a28179d43b367ff11eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de052205bafd99d67afde880b67a4e8"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a6de052205bafd99d67afde880b67a4e8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6de052205bafd99d67afde880b67a4e8">basic_handle</a> (const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;, Entity) -&gt; <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; const Entity &gt;</td></tr>
<tr class="memdesc:a6de052205bafd99d67afde880b67a4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a6de052205bafd99d67afde880b67a4e8">More...</a><br /></td></tr>
<tr class="separator:a6de052205bafd99d67afde880b67a4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0922fd2ea330d84a2e1b6f19e877aed"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:af0922fd2ea330d84a2e1b6f19e877aed"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af0922fd2ea330d84a2e1b6f19e877aed">as_view</a> (<a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) -&gt; <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; Entity &gt;</td></tr>
<tr class="memdesc:af0922fd2ea330d84a2e1b6f19e877aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#af0922fd2ea330d84a2e1b6f19e877aed">More...</a><br /></td></tr>
<tr class="separator:af0922fd2ea330d84a2e1b6f19e877aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4821869aa545da11205c90388fa2d08e"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a4821869aa545da11205c90388fa2d08e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4821869aa545da11205c90388fa2d08e">as_view</a> (const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) -&gt; <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; const Entity &gt;</td></tr>
<tr class="memdesc:a4821869aa545da11205c90388fa2d08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a4821869aa545da11205c90388fa2d08e">More...</a><br /></td></tr>
<tr class="separator:a4821869aa545da11205c90388fa2d08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcc1231f76478c7aa6f6ec9516cf045"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a4dcc1231f76478c7aa6f6ec9516cf045"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4dcc1231f76478c7aa6f6ec9516cf045">as_group</a> (<a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) -&gt; <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; Entity &gt;</td></tr>
<tr class="memdesc:a4dcc1231f76478c7aa6f6ec9516cf045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a4dcc1231f76478c7aa6f6ec9516cf045">More...</a><br /></td></tr>
<tr class="separator:a4dcc1231f76478c7aa6f6ec9516cf045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e62063b33b410e0a4bf1acc5b59596"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:ad6e62063b33b410e0a4bf1acc5b59596"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad6e62063b33b410e0a4bf1acc5b59596">as_group</a> (const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) -&gt; <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; const Entity &gt;</td></tr>
<tr class="memdesc:ad6e62063b33b410e0a4bf1acc5b59596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#ad6e62063b33b410e0a4bf1acc5b59596">More...</a><br /></td></tr>
<tr class="separator:ad6e62063b33b410e0a4bf1acc5b59596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa512a354fe328df6be5a92eb43cd4d69"><td class="memTemplParams" colspan="2">template&lt;auto Member, typename Entity  = entity&gt; </td></tr>
<tr class="memitem:aa512a354fe328df6be5a92eb43cd4d69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aa512a354fe328df6be5a92eb43cd4d69">invoke</a> (<a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;reg, const Entity entt)</td></tr>
<tr class="memdesc:aa512a354fe328df6be5a92eb43cd4d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to create a listener that directly invokes a member function.  <a href="namespaceentt.html#aa512a354fe328df6be5a92eb43cd4d69">More...</a><br /></td></tr>
<tr class="separator:aa512a354fe328df6be5a92eb43cd4d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81b68364d770429f343d703f415d12a"><td class="memTemplParams" colspan="2">template&lt;typename Entity , typename Component &gt; </td></tr>
<tr class="memitem:ae81b68364d770429f343d703f415d12a"><td class="memTemplItemLeft" align="right" valign="top">Entity&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae81b68364d770429f343d703f415d12a">to_entity</a> (const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;reg, const Component &amp;instance)</td></tr>
<tr class="memdesc:ae81b68364d770429f343d703f415d12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity associated with a given component.  <a href="namespaceentt.html#ae81b68364d770429f343d703f415d12a">More...</a><br /></td></tr>
<tr class="separator:ae81b68364d770429f343d703f415d12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270b9239b055bcfe25afa3fb32e1dba3"><td class="memTemplParams" colspan="2">template&lt;typename... Storage&gt; </td></tr>
<tr class="memitem:a270b9239b055bcfe25afa3fb32e1dba3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a270b9239b055bcfe25afa3fb32e1dba3">basic_view</a> (Storage &amp;...<a class="el" href="namespaceentt.html#abcedb8f29753130e2bf3185bca211f05">storage</a>) -&gt; <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; std::common_type_t&lt; typename Storage::entity_type... &gt;, <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt; <a class="el" href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">constness_as_t</a>&lt; typename Storage::value_type, Storage &gt;... &gt;, <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt;&gt;&gt;</td></tr>
<tr class="memdesc:a270b9239b055bcfe25afa3fb32e1dba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a270b9239b055bcfe25afa3fb32e1dba3">More...</a><br /></td></tr>
<tr class="separator:a270b9239b055bcfe25afa3fb32e1dba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab7b51802157a98106f238335fa7503"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a2ab7b51802157a98106f238335fa7503"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2ab7b51802157a98106f238335fa7503">dereference_meta_pointer_like</a> (const Type &amp;value)</td></tr>
<tr class="memdesc:a2ab7b51802157a98106f238335fa7503"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL based lookup function for dereferencing meta pointer-like types.  <a href="namespaceentt.html#a2ab7b51802157a98106f238335fa7503">More...</a><br /></td></tr>
<tr class="separator:a2ab7b51802157a98106f238335fa7503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae5a1bdbb378be2ae0556ff437cf513"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a3ae5a1bdbb378be2ae0556ff437cf513"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3ae5a1bdbb378be2ae0556ff437cf513">meta</a> ()</td></tr>
<tr class="memdesc:a3ae5a1bdbb378be2ae0556ff437cf513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to use for reflection.  <a href="namespaceentt.html#a3ae5a1bdbb378be2ae0556ff437cf513">More...</a><br /></td></tr>
<tr class="separator:a3ae5a1bdbb378be2ae0556ff437cf513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5090482af8e4ab0afa3e27abf1eec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4f5090482af8e4ab0afa3e27abf1eec3">meta_reset</a> (const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> id)</td></tr>
<tr class="memdesc:a4f5090482af8e4ab0afa3e27abf1eec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a type and all its parts.  <a href="namespaceentt.html#a4f5090482af8e4ab0afa3e27abf1eec3">More...</a><br /></td></tr>
<tr class="separator:a4f5090482af8e4ab0afa3e27abf1eec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6591abe0fd3b376413e2ba5ba760ea"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a0e6591abe0fd3b376413e2ba5ba760ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0e6591abe0fd3b376413e2ba5ba760ea">meta_reset</a> ()</td></tr>
<tr class="memdesc:a0e6591abe0fd3b376413e2ba5ba760ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a type and all its parts.  <a href="namespaceentt.html#a0e6591abe0fd3b376413e2ba5ba760ea">More...</a><br /></td></tr>
<tr class="separator:a0e6591abe0fd3b376413e2ba5ba760ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845d4ef2c448264153449c92157a0359"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a845d4ef2c448264153449c92157a0359">operator!=</a> (const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;lhs, const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;rhs)</td></tr>
<tr class="memdesc:a845d4ef2c448264153449c92157a0359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two wrappers differ in their content.  <a href="namespaceentt.html#a845d4ef2c448264153449c92157a0359">More...</a><br /></td></tr>
<tr class="separator:a845d4ef2c448264153449c92157a0359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd5e7fb78b64f8238eacae2f10ba06e"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Args&gt; </td></tr>
<tr class="memitem:abdd5e7fb78b64f8238eacae2f10ba06e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abdd5e7fb78b64f8238eacae2f10ba06e">make_meta</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:abdd5e7fb78b64f8238eacae2f10ba06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a wrapper from a given type, passing it all arguments.  <a href="namespaceentt.html#abdd5e7fb78b64f8238eacae2f10ba06e">More...</a><br /></td></tr>
<tr class="separator:abdd5e7fb78b64f8238eacae2f10ba06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c7a5a8ac08bc879abdaa00f920a996"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a77c7a5a8ac08bc879abdaa00f920a996"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a77c7a5a8ac08bc879abdaa00f920a996">forward_as_meta</a> (Type &amp;&amp;value)</td></tr>
<tr class="memdesc:a77c7a5a8ac08bc879abdaa00f920a996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards its argument and avoids copies for lvalue references.  <a href="namespaceentt.html#a77c7a5a8ac08bc879abdaa00f920a996">More...</a><br /></td></tr>
<tr class="separator:a77c7a5a8ac08bc879abdaa00f920a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ebb219547c34209a94c9eb6d26eda1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a04ebb219547c34209a94c9eb6d26eda1">operator!=</a> (const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;lhs, const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;rhs)</td></tr>
<tr class="memdesc:a04ebb219547c34209a94c9eb6d26eda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two objects refer to the same type.  <a href="namespaceentt.html#a04ebb219547c34209a94c9eb6d26eda1">More...</a><br /></td></tr>
<tr class="separator:a04ebb219547c34209a94c9eb6d26eda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b62be0d39676cb86f2aefefa890b198"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a0b62be0d39676cb86f2aefefa890b198"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0b62be0d39676cb86f2aefefa890b198">resolve</a> ()</td></tr>
<tr class="memdesc:a0b62be0d39676cb86f2aefefa890b198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type.  <a href="namespaceentt.html#a0b62be0d39676cb86f2aefefa890b198">More...</a><br /></td></tr>
<tr class="separator:a0b62be0d39676cb86f2aefefa890b198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1915a651e7ce55938a09269c3d9c98e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a1915a651e7ce55938a09269c3d9c98e4">resolve</a> (const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> id)</td></tr>
<tr class="memdesc:a1915a651e7ce55938a09269c3d9c98e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given identifier, if any.  <a href="namespaceentt.html#a1915a651e7ce55938a09269c3d9c98e4">More...</a><br /></td></tr>
<tr class="separator:a1915a651e7ce55938a09269c3d9c98e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834693b80a8d9af8b6d6edb81cb54b39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a834693b80a8d9af8b6d6edb81cb54b39">resolve</a> (const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;info)</td></tr>
<tr class="memdesc:a834693b80a8d9af8b6d6edb81cb54b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type info object.  <a href="namespaceentt.html#a834693b80a8d9af8b6d6edb81cb54b39">More...</a><br /></td></tr>
<tr class="separator:a834693b80a8d9af8b6d6edb81cb54b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957782a57268c06cef354868d4402c74"><td class="memTemplParams" colspan="2">template&lt;typename Policy  = as_is_t, typename Type &gt; </td></tr>
<tr class="memitem:a957782a57268c06cef354868d4402c74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a957782a57268c06cef354868d4402c74">meta_dispatch</a> ([[maybe_unused]] Type &amp;&amp;value)</td></tr>
<tr class="memdesc:a957782a57268c06cef354868d4402c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a value depending on the given policy.  <a href="namespaceentt.html#a957782a57268c06cef354868d4402c74">More...</a><br /></td></tr>
<tr class="separator:a957782a57268c06cef354868d4402c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe109e5134bae55cb519799acbed732"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Data&gt; </td></tr>
<tr class="memitem:adbe109e5134bae55cb519799acbed732"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#adbe109e5134bae55cb519799acbed732">meta_setter</a> ([[maybe_unused]] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, [[maybe_unused]] <a class="el" href="classentt_1_1meta__any.html">meta_any</a> value)</td></tr>
<tr class="memdesc:adbe109e5134bae55cb519799acbed732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of a given variable.  <a href="namespaceentt.html#adbe109e5134bae55cb519799acbed732">More...</a><br /></td></tr>
<tr class="separator:adbe109e5134bae55cb519799acbed732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe26d091f302630470004fe314a6a8d"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Data, typename Policy  = as_is_t&gt; </td></tr>
<tr class="memitem:a3fe26d091f302630470004fe314a6a8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3fe26d091f302630470004fe314a6a8d">meta_getter</a> ([[maybe_unused]] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance)</td></tr>
<tr class="memdesc:a3fe26d091f302630470004fe314a6a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a given variable.  <a href="namespaceentt.html#a3fe26d091f302630470004fe314a6a8d">More...</a><br /></td></tr>
<tr class="separator:a3fe26d091f302630470004fe314a6a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d375156fcfcc72d62eab6728650556"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Policy  = as_is_t, typename Candidate &gt; </td></tr>
<tr class="memitem:a00d375156fcfcc72d62eab6728650556"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a00d375156fcfcc72d62eab6728650556">meta_invoke</a> ([[maybe_unused]] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, Candidate &amp;&amp;candidate, [[maybe_unused]] <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a00d375156fcfcc72d62eab6728650556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to <em>invoke</em> an object given a list of erased parameters.  <a href="namespaceentt.html#a00d375156fcfcc72d62eab6728650556">More...</a><br /></td></tr>
<tr class="separator:a00d375156fcfcc72d62eab6728650556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3281f612575b11cef54d9d1008d7a469"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Candidate, typename Policy  = as_is_t&gt; </td></tr>
<tr class="memitem:a3281f612575b11cef54d9d1008d7a469"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3281f612575b11cef54d9d1008d7a469">meta_invoke</a> (<a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a3281f612575b11cef54d9d1008d7a469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to invoke a function given a list of erased parameters.  <a href="namespaceentt.html#a3281f612575b11cef54d9d1008d7a469">More...</a><br /></td></tr>
<tr class="separator:a3281f612575b11cef54d9d1008d7a469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0d075524517183181aa512417358a0"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Args&gt; </td></tr>
<tr class="memitem:a3b0d075524517183181aa512417358a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3b0d075524517183181aa512417358a0">meta_construct</a> (<a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a3b0d075524517183181aa512417358a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <a href="namespaceentt.html#a3b0d075524517183181aa512417358a0">More...</a><br /></td></tr>
<tr class="separator:a3b0d075524517183181aa512417358a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8c196db303590ebe456287b5890cf4"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Policy  = as_is_t, typename Candidate &gt; </td></tr>
<tr class="memitem:aef8c196db303590ebe456287b5890cf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aef8c196db303590ebe456287b5890cf4">meta_construct</a> (Candidate &amp;&amp;candidate, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:aef8c196db303590ebe456287b5890cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <a href="namespaceentt.html#aef8c196db303590ebe456287b5890cf4">More...</a><br /></td></tr>
<tr class="separator:aef8c196db303590ebe456287b5890cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681f2bc9d84e3851405cf4b8c8e21455"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Candidate, typename Policy  = as_is_t&gt; </td></tr>
<tr class="memitem:a681f2bc9d84e3851405cf4b8c8e21455"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a681f2bc9d84e3851405cf4b8c8e21455">meta_construct</a> (<a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args)</td></tr>
<tr class="memdesc:a681f2bc9d84e3851405cf4b8c8e21455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to construct an instance given a list of erased parameters.  <a href="namespaceentt.html#a681f2bc9d84e3851405cf4b8c8e21455">More...</a><br /></td></tr>
<tr class="separator:a681f2bc9d84e3851405cf4b8c8e21455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4f2adf317a555138ef5c1cf45b034a"><td class="memTemplParams" colspan="2">template&lt;auto Member, typename Poly , typename... Args&gt; </td></tr>
<tr class="memitem:a8b4f2adf317a555138ef5c1cf45b034a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8b4f2adf317a555138ef5c1cf45b034a">poly_call</a> (Poly &amp;&amp;self, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a8b4f2adf317a555138ef5c1cf45b034a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for calling <code><a class="el" href="structentt_1_1poly__base.html" title="Poly base class used to inject functionalities into concepts.">poly_base</a>&lt;Type&gt;<a class="el" href="namespaceentt.html#aa512a354fe328df6be5a92eb43cd4d69" title="Helper to create a listener that directly invokes a member function.">invoke</a></code>.  <a href="namespaceentt.html#a8b4f2adf317a555138ef5c1cf45b034a">More...</a><br /></td></tr>
<tr class="separator:a8b4f2adf317a555138ef5c1cf45b034a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8711ef7a24e5329d7cbd0d05136874e"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename... Args&gt; </td></tr>
<tr class="memitem:ac8711ef7a24e5329d7cbd0d05136874e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac8711ef7a24e5329d7cbd0d05136874e">operator!=</a> (const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;lhs, const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac8711ef7a24e5329d7cbd0d05136874e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two delegates.  <a href="namespaceentt.html#ac8711ef7a24e5329d7cbd0d05136874e">More...</a><br /></td></tr>
<tr class="separator:ac8711ef7a24e5329d7cbd0d05136874e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8907a3a72cd2da043d81f6fd50487a"><td class="memTemplParams" colspan="2">template&lt;auto Candidate&gt; </td></tr>
<tr class="memitem:a7c8907a3a72cd2da043d81f6fd50487a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7c8907a3a72cd2da043d81f6fd50487a">delegate</a> (<a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;) -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate)&gt;&gt;&gt;</td></tr>
<tr class="memdesc:a7c8907a3a72cd2da043d81f6fd50487a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a7c8907a3a72cd2da043d81f6fd50487a">More...</a><br /></td></tr>
<tr class="separator:a7c8907a3a72cd2da043d81f6fd50487a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ba791dbcdecb9415a5c11fe69c4b1c"><td class="memTemplParams" colspan="2">template&lt;auto Candidate, typename Type &gt; </td></tr>
<tr class="memitem:a39ba791dbcdecb9415a5c11fe69c4b1c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a39ba791dbcdecb9415a5c11fe69c4b1c">delegate</a> (<a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;, Type &amp;&amp;) -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate), Type &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a39ba791dbcdecb9415a5c11fe69c4b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a39ba791dbcdecb9415a5c11fe69c4b1c">More...</a><br /></td></tr>
<tr class="separator:a39ba791dbcdecb9415a5c11fe69c4b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba06006a862fa5dc613e8561ac4e92c"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename... Args&gt; </td></tr>
<tr class="memitem:aaba06006a862fa5dc613e8561ac4e92c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aaba06006a862fa5dc613e8561ac4e92c">delegate</a> (Ret(*)(const void *, Args...), const void *=nullptr) -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt;</td></tr>
<tr class="memdesc:aaba06006a862fa5dc613e8561ac4e92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#aaba06006a862fa5dc613e8561ac4e92c">More...</a><br /></td></tr>
<tr class="separator:aaba06006a862fa5dc613e8561ac4e92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4dd70afb5ef2529d05bc474b234f53"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename... Args, typename Allocator &gt; </td></tr>
<tr class="memitem:aba4dd70afb5ef2529d05bc474b234f53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aba4dd70afb5ef2529d05bc474b234f53">sink</a> (<a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...), Allocator &gt; &amp;) -&gt; <a class="el" href="classentt_1_1sink.html">sink</a>&lt; <a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...), Allocator &gt;&gt;</td></tr>
<tr class="memdesc:aba4dd70afb5ef2529d05bc474b234f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#aba4dd70afb5ef2529d05bc474b234f53">More...</a><br /></td></tr>
<tr class="separator:aba4dd70afb5ef2529d05bc474b234f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8378b9330b5c90b6b11deee3637ebca6"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a8378b9330b5c90b6b11deee3637ebca6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8378b9330b5c90b6b11deee3637ebca6">enum_as_bitmask_v</a> = <a class="el" href="structentt_1_1enum__as__bitmask.html">enum_as_bitmask</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a8378b9330b5c90b6b11deee3637ebca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a8378b9330b5c90b6b11deee3637ebca6">More...</a><br /></td></tr>
<tr class="separator:a8378b9330b5c90b6b11deee3637ebca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memTemplParams" colspan="2">template&lt;id_type Value&gt; </td></tr>
<tr class="memitem:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structentt_1_1monostate.html">monostate</a>&lt; Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab43a13f7ee60bcb0d04a001f92b86fa2">monostate_v</a> = {}</td></tr>
<tr class="memdesc:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ab43a13f7ee60bcb0d04a001f92b86fa2">More...</a><br /></td></tr>
<tr class="separator:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089f75043b082abca3ea144bce44e9ae"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a089f75043b082abca3ea144bce44e9ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1choice__t.html">choice_t</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a089f75043b082abca3ea144bce44e9ae">choice</a> {}</td></tr>
<tr class="memdesc:a089f75043b082abca3ea144bce44e9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for the choice trick.  <a href="namespaceentt.html#a089f75043b082abca3ea144bce44e9ae">More...</a><br /></td></tr>
<tr class="separator:a089f75043b082abca3ea144bce44e9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a15f9a70cbdd5a64f897a012ab2b5834f">size_of_v</a> = <a class="el" href="structentt_1_1size__of.html">size_of</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a15f9a70cbdd5a64f897a012ab2b5834f">More...</a><br /></td></tr>
<tr class="separator:a15f9a70cbdd5a64f897a012ab2b5834f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7558c4e09ee416fb7fa3576737ff65"><td class="memTemplParams" colspan="2">template&lt;auto Value, typename &gt; </td></tr>
<tr class="memitem:aee7558c4e09ee416fb7fa3576737ff65"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aee7558c4e09ee416fb7fa3576737ff65">unpack_as_value</a> = Value</td></tr>
<tr class="memdesc:aee7558c4e09ee416fb7fa3576737ff65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template to be used to <em>repeat</em> the same value a number of times equal to the size of a given parameter pack.  <a href="namespaceentt.html#aee7558c4e09ee416fb7fa3576737ff65">More...</a><br /></td></tr>
<tr class="separator:aee7558c4e09ee416fb7fa3576737ff65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988ce063936d499bf2d69406c391fd5c"><td class="memTemplParams" colspan="2">template&lt;typename List , typename Type &gt; </td></tr>
<tr class="memitem:a988ce063936d499bf2d69406c391fd5c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a988ce063936d499bf2d69406c391fd5c">type_list_contains_v</a> = <a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a>&lt;List, Type&gt;::value</td></tr>
<tr class="memdesc:a988ce063936d499bf2d69406c391fd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a988ce063936d499bf2d69406c391fd5c">More...</a><br /></td></tr>
<tr class="separator:a988ce063936d499bf2d69406c391fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbfb162708696f9c1497d61573b540f"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename List &gt; </td></tr>
<tr class="memitem:a4bbfb162708696f9c1497d61573b540f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4bbfb162708696f9c1497d61573b540f">value_list_element_v</a> = <a class="el" href="structentt_1_1value__list__element.html">value_list_element</a>&lt;Index, List&gt;::value</td></tr>
<tr class="memdesc:a4bbfb162708696f9c1497d61573b540f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a4bbfb162708696f9c1497d61573b540f">More...</a><br /></td></tr>
<tr class="separator:a4bbfb162708696f9c1497d61573b540f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f238620469de3ef2bafdb28fe4657ef"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename Args &gt; </td></tr>
<tr class="memitem:a4f238620469de3ef2bafdb28fe4657ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4f238620469de3ef2bafdb28fe4657ef">is_applicable_v</a> = <a class="el" href="structentt_1_1is__applicable.html">is_applicable</a>&lt;Func, Args&gt;::value</td></tr>
<tr class="memdesc:a4f238620469de3ef2bafdb28fe4657ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a4f238620469de3ef2bafdb28fe4657ef">More...</a><br /></td></tr>
<tr class="separator:a4f238620469de3ef2bafdb28fe4657ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae764716fab8c01b12d3e209004b62647"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Func , typename Args &gt; </td></tr>
<tr class="memitem:ae764716fab8c01b12d3e209004b62647"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae764716fab8c01b12d3e209004b62647">is_applicable_r_v</a> = <a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a>&lt;Ret, Func, Args&gt;::value</td></tr>
<tr class="memdesc:ae764716fab8c01b12d3e209004b62647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ae764716fab8c01b12d3e209004b62647">More...</a><br /></td></tr>
<tr class="separator:ae764716fab8c01b12d3e209004b62647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8a96fcc4bc8da9a2aa1cdb0bc15b75c8">is_complete_v</a> = <a class="el" href="structentt_1_1is__complete.html">is_complete</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a8a96fcc4bc8da9a2aa1cdb0bc15b75c8">More...</a><br /></td></tr>
<tr class="separator:a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac133ddb24ec535a11baf3143d188d6"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a3ac133ddb24ec535a11baf3143d188d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3ac133ddb24ec535a11baf3143d188d6">is_iterator_v</a> = <a class="el" href="structentt_1_1is__iterator.html">is_iterator</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a3ac133ddb24ec535a11baf3143d188d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a3ac133ddb24ec535a11baf3143d188d6">More...</a><br /></td></tr>
<tr class="separator:a3ac133ddb24ec535a11baf3143d188d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4081aa5332fcb3367063eeba93918b8"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename It &gt; </td></tr>
<tr class="memitem:ac4081aa5332fcb3367063eeba93918b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac4081aa5332fcb3367063eeba93918b8">is_iterator_type_v</a> = <a class="el" href="structentt_1_1is__iterator__type.html">is_iterator_type</a>&lt;Type, It&gt;::value</td></tr>
<tr class="memdesc:ac4081aa5332fcb3367063eeba93918b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ac4081aa5332fcb3367063eeba93918b8">More...</a><br /></td></tr>
<tr class="separator:ac4081aa5332fcb3367063eeba93918b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5b1446d23f1cba20563114f5da1f9d"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:afb5b1446d23f1cba20563114f5da1f9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#afb5b1446d23f1cba20563114f5da1f9d">is_ebco_eligible_v</a> = <a class="el" href="structentt_1_1is__ebco__eligible.html">is_ebco_eligible</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:afb5b1446d23f1cba20563114f5da1f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#afb5b1446d23f1cba20563114f5da1f9d">More...</a><br /></td></tr>
<tr class="separator:afb5b1446d23f1cba20563114f5da1f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd3998d86cc531f800d0104478771f4"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a5fd3998d86cc531f800d0104478771f4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5fd3998d86cc531f800d0104478771f4">is_transparent_v</a> = <a class="el" href="structentt_1_1is__transparent.html">is_transparent</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a5fd3998d86cc531f800d0104478771f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a5fd3998d86cc531f800d0104478771f4">More...</a><br /></td></tr>
<tr class="separator:a5fd3998d86cc531f800d0104478771f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068dd98a70c771935d2bf3dd96dbad6d"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a068dd98a70c771935d2bf3dd96dbad6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a068dd98a70c771935d2bf3dd96dbad6d">is_equality_comparable_v</a> = <a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a068dd98a70c771935d2bf3dd96dbad6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a068dd98a70c771935d2bf3dd96dbad6d">More...</a><br /></td></tr>
<tr class="separator:a068dd98a70c771935d2bf3dd96dbad6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f9b531ebde614244a0da111d4b66ff"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ab9f9b531ebde614244a0da111d4b66ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab9f9b531ebde614244a0da111d4b66ff">ignore_as_empty_v</a> = <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt;Type&gt;::ignore_if_empty &amp;&amp;std::is_empty_v&lt;Type&gt;</td></tr>
<tr class="memdesc:ab9f9b531ebde614244a0da111d4b66ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ab9f9b531ebde614244a0da111d4b66ff">More...</a><br /></td></tr>
<tr class="separator:ab9f9b531ebde614244a0da111d4b66ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0c0a1c1d953ea991591748744cdd8b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1null__t.html">null_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2f0c0a1c1d953ea991591748744cdd8b">null</a> {}</td></tr>
<tr class="memdesc:a2f0c0a1c1d953ea991591748744cdd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time constant for null entities.  <a href="namespaceentt.html#a2f0c0a1c1d953ea991591748744cdd8b">More...</a><br /></td></tr>
<tr class="separator:a2f0c0a1c1d953ea991591748744cdd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674269102fdfe3fd6d7766210a828862"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a674269102fdfe3fd6d7766210a828862">tombstone</a> {}</td></tr>
<tr class="memdesc:a674269102fdfe3fd6d7766210a828862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time constant for tombstone entities.  <a href="namespaceentt.html#a674269102fdfe3fd6d7766210a828862">More...</a><br /></td></tr>
<tr class="separator:a674269102fdfe3fd6d7766210a828862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8b073b774362fe800d9cce3542927a"><td class="memItemLeft" align="right" valign="top"><a id="aea8b073b774362fe800d9cce3542927a"></a>
constexpr <a class="el" href="structentt_1_1basic__collector.html">basic_collector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aea8b073b774362fe800d9cce3542927a">collector</a> {}</td></tr>
<tr class="memdesc:aea8b073b774362fe800d9cce3542927a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template used to ease the definition of collectors. <br /></td></tr>
<tr class="separator:aea8b073b774362fe800d9cce3542927a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5b73210cef43c4db35ef8ce477cc38a6">exclude</a> {}</td></tr>
<tr class="memdesc:a5b73210cef43c4db35ef8ce477cc38a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for exclusion lists.  <a href="namespaceentt.html#a5b73210cef43c4db35ef8ce477cc38a6">More...</a><br /></td></tr>
<tr class="separator:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8c24ecc5ab0055f9f2a4725c95afb29e">get</a> {}</td></tr>
<tr class="memdesc:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for lists of observed components.  <a href="namespaceentt.html#a8c24ecc5ab0055f9f2a4725c95afb29e">More...</a><br /></td></tr>
<tr class="separator:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91ddbe2446a912714a5fe7251e25768"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:ac91ddbe2446a912714a5fe7251e25768"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1owned__t.html">owned_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac91ddbe2446a912714a5fe7251e25768">owned</a> {}</td></tr>
<tr class="memdesc:ac91ddbe2446a912714a5fe7251e25768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for lists of owned components.  <a href="namespaceentt.html#ac91ddbe2446a912714a5fe7251e25768">More...</a><br /></td></tr>
<tr class="separator:ac91ddbe2446a912714a5fe7251e25768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8c390cfe71301a0c10f4844e98424c"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:aaa8c390cfe71301a0c10f4844e98424c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aaa8c390cfe71301a0c10f4844e98424c">is_meta_pointer_like_v</a> = <a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:aaa8c390cfe71301a0c10f4844e98424c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#aaa8c390cfe71301a0c10f4844e98424c">More...</a><br /></td></tr>
<tr class="separator:aaa8c390cfe71301a0c10f4844e98424c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e73acd6f3d892955819677dc2664b7"><td class="memTemplParams" colspan="2"><a id="af1e73acd6f3d892955819677dc2664b7"></a>
template&lt;auto Func&gt; </td></tr>
<tr class="memitem:af1e73acd6f3d892955819677dc2664b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Func &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af1e73acd6f3d892955819677dc2664b7">connect_arg</a> {}</td></tr>
<tr class="memdesc:af1e73acd6f3d892955819677dc2664b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant of type <a class="el" href="structentt_1_1connect__arg__t.html" title="Used to wrap a function or a member of a specified type.">connect_arg_t</a> used to disambiguate calls. <br /></td></tr>
<tr class="separator:af1e73acd6f3d892955819677dc2664b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><code>EnTT</code> default namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aedfeed27a790ac90eb5989da8a3ea860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfeed27a790ac90eb5989da8a3ea860">&#9670;&nbsp;</a></span>const_handle_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#aedfeed27a790ac90eb5989da8a3ea860">entt::const_handle_view</a> = typedef <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt;const <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00086">86</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a7b051461867d3c5c97f77f10b662c26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b051461867d3c5c97f77f10b662c26b">&#9670;&nbsp;</a></span>constness_as_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">entt::constness_as_t</a> = typedef typename <a class="el" href="structentt_1_1constness__as.html">constness_as</a>&lt;To, From&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template to facilitate the transcription of the constness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The type to which to transcribe the constness. </td></tr>
    <tr><td class="paramname">From</td><td>The type from which to transcribe the constness. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00645">645</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a2628e82fa8042f75d817c58fc09c7aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2628e82fa8042f75d817c58fc09c7aaf">&#9670;&nbsp;</a></span>group</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a2628e82fa8042f75d817c58fc09c7aaf">entt::group</a> = typedef <a class="el" href="classentt_1_1basic__group.html">basic_group</a>&lt;<a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00113">113</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="aaa5809ceb50ec17713e8690c20a79490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5809ceb50ec17713e8690c20a79490">&#9670;&nbsp;</a></span>handle_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#aaa5809ceb50ec17713e8690c20a79490">entt::handle_view</a> = typedef <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt;<a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00079">79</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a0d9fd5898acf13553bbcf14b99159f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9fd5898acf13553bbcf14b99159f4d">&#9670;&nbsp;</a></span>integral_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">entt::integral_constant</a> = typedef std::integral_constant&lt;decltype(Value), Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a static constant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A static constant. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00096">96</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a49f19d031690e5ebfffd6c7a4f6bd364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f19d031690e5ebfffd6c7a4f6bd364">&#9670;&nbsp;</a></span>member_class_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Member &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a49f19d031690e5ebfffd6c7a4f6bd364">entt::member_class_t</a> = typedef typename <a class="el" href="classentt_1_1member__class.html">member_class</a>&lt;Member&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>A pointer to a non-static member object or function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00674">674</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a692beabf853ee0f9dc68beab816a6b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692beabf853ee0f9dc68beab816a6b27">&#9670;&nbsp;</a></span>meta_function_helper_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Candidate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a692beabf853ee0f9dc68beab816a6b27">entt::meta_function_helper_t</a> = typedef typename <a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a>&lt;Type, Candidate&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the meta function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to associate with the reflected type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00154">154</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="aad3d1f1d0e83ad8f124155c9e511c2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3d1f1d0e83ad8f124155c9e511c2cd">&#9670;&nbsp;</a></span>poly</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Concept &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#aad3d1f1d0e83ad8f124155c9e511c2cd">entt::poly</a> = typedef <a class="el" href="classentt_1_1basic__poly.html">basic_poly</a>&lt;Concept, sizeof(double[2])&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Concept</td><td>Concept descriptor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="poly_2fwd_8hpp_source.html#l00016">16</a> of file <a class="el" href="poly_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="abcedb8f29753130e2bf3185bca211f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcedb8f29753130e2bf3185bca211f05">&#9670;&nbsp;</a></span>storage</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#abcedb8f29753130e2bf3185bca211f05">entt::storage</a> = typedef <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt;<a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00057">57</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a9f7bb8c357f08a01ad9c8dab0ea40c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7bb8c357f08a01ad9c8dab0ea40c1c">&#9670;&nbsp;</a></span>tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;id_type Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a9f7bb8c357f08a01ad9c8dab0ea40c1c">entt::tag</a> = typedef <a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">integral_constant</a>&lt;Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template to facilitate the creation of named values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A constant value at least convertible to <code>id_type</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00103">103</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a09f6bd6b4aebc03df720e7e69fdc6643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f6bd6b4aebc03df720e7e69fdc6643">&#9670;&nbsp;</a></span>type_identity_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a09f6bd6b4aebc03df720e7e69fdc6643">entt::type_identity_t</a> = typedef typename <a class="el" href="structentt_1_1type__identity.html">type_identity</a>&lt;Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00053">53</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a546467a3662e9a915d5d519ad565e801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546467a3662e9a915d5d519ad565e801">&#9670;&nbsp;</a></span>type_list_cat_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">entt::type_list_cat_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type lists to concatenate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00199">199</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="af2992fc009cb3199b0ef9a86bed2285c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2992fc009cb3199b0ef9a86bed2285c">&#9670;&nbsp;</a></span>type_list_diff_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#af2992fc009cb3199b0ef9a86bed2285c">entt::type_list_diff_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type lists between which to compute the difference. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00278">278</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ac839c1a03dba2436791d0056d6d0d1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac839c1a03dba2436791d0056d6d0d1b6">&#9670;&nbsp;</a></span>type_list_element_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename List &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#ac839c1a03dba2436791d0056d6d0d1b6">entt::type_list_element_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__element.html">type_list_element</a>&lt;Index, List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index of the type to return. </td></tr>
    <tr><td class="paramname">List</td><td>Type list to search into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00148">148</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a75a277a6037279d65cd3874b46ec7166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a277a6037279d65cd3874b46ec7166">&#9670;&nbsp;</a></span>type_list_unique_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">entt::type_list_unique_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a>&lt;Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00231">231</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ae62c84ccab78132ef356b13e4ff12dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62c84ccab78132ef356b13e4ff12dfa">&#9670;&nbsp;</a></span>unpack_as_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#ae62c84ccab78132ef356b13e4ff12dfa">entt::unpack_as_type</a> = typedef Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using declaration to be used to <em>repeat</em> the same type a number of times equal to the size of a given parameter pack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type to repeat. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00081">81</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a1344cc62598091397018354e6905e431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1344cc62598091397018354e6905e431">&#9670;&nbsp;</a></span>value_list_cat_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a1344cc62598091397018354e6905e431">entt::value_list_cat_t</a> = typedef typename <a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Value lists to concatenate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00374">374</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a87b7ba6bd51a290113765bc97188d247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b7ba6bd51a290113765bc97188d247">&#9670;&nbsp;</a></span>view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Get , typename Exclude  = exclude_t&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a87b7ba6bd51a290113765bc97188d247">entt::view</a> = typedef <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt;<a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Get, Exclude&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Get</td><td>Types of components iterated by the view. </td></tr>
    <tr><td class="paramname">Exclude</td><td>Types of components used to filter the view. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00103">103</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="abc4d0fa77fae26e7c01793990996c581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4d0fa77fae26e7c01793990996c581">&#9670;&nbsp;</a></span>deletion_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">entt::deletion_policy</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sparse set deletion policy. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abc4d0fa77fae26e7c01793990996c581a8223d1ccb16b6dd0b19fe9c6fdb13708"></a>swap_and_pop&#160;</td><td class="fielddoc"><p>Swap-and-pop deletion policy. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc4d0fa77fae26e7c01793990996c581aa49f99ae99ae9daddd1fb79b73d2db28"></a>in_place&#160;</td><td class="fielddoc"><p>In-place deletion policy. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00143">143</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1ade9ac7c0844a7c154287ca96ceba08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ade9ac7c0844a7c154287ca96ceba08">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00436">436</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a7c210bb2e08d184415f5c5680d87d74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c210bb2e08d184415f5c5680d87d74e">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00427">427</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="ac53c0786eb32685bbbfc6a2b9806338b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53c0786eb32685bbbfc6a2b9806338b">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type* entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00459">459</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a2364ab41cab0fccd92cdaaf8779581cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2364ab41cab0fccd92cdaaf8779581cb">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type entt::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00419">419</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="aeaf3e0080cf2091703718dcbe558171b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf3e0080cf2091703718dcbe558171b">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Type* entt::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00452">452</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a4dcc1231f76478c7aa6f6ec9516cf045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcc1231f76478c7aa6f6ec9516cf045">&#9670;&nbsp;</a></span>as_group() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__group.html">entt::as_group</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6e62063b33b410e0a4bf1acc5b59596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e62063b33b410e0a4bf1acc5b59596">&#9670;&nbsp;</a></span>as_group() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__group.html">entt::as_group</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; const Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0922fd2ea330d84a2e1b6f19e877aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0922fd2ea330d84a2e1b6f19e877aed">&#9670;&nbsp;</a></span>as_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__view.html">entt::as_view</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4821869aa545da11205c90388fa2d08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4821869aa545da11205c90388fa2d08e">&#9670;&nbsp;</a></span>as_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__view.html">entt::as_view</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; const Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a288ec07d4e87a28179d43b367ff11eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288ec07d4e87a28179d43b367ff11eab">&#9670;&nbsp;</a></span>basic_handle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1basic__handle.html">entt::basic_handle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Entity&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6de052205bafd99d67afde880b67a4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de052205bafd99d67afde880b67a4e8">&#9670;&nbsp;</a></span>basic_handle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1basic__handle.html">entt::basic_handle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Entity&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; const Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa97361ef962166a4fc51a582d7c6392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa97361ef962166a4fc51a582d7c6392">&#9670;&nbsp;</a></span>basic_hashed_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__hashed__string.html">entt::basic_hashed_string</a> </td>
          <td>(</td>
          <td class="paramtype">const Char(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[N]</td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the character type of the hashed string directly from a human-readable identifer provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of characters of the identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Human-readable identifer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a270b9239b055bcfe25afa3fb32e1dba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270b9239b055bcfe25afa3fb32e1dba3">&#9670;&nbsp;</a></span>basic_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Storage&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__view.html">entt::basic_view</a> </td>
          <td>(</td>
          <td class="paramtype">Storage &amp;...&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; std::common_type_t&lt; typename Storage::entity_type... &gt;, <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt; <a class="el" href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">constness_as_t</a>&lt; typename Storage::value_type, Storage &gt;... &gt;, <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Storage</td><td>Type of storage classes used to create the view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>The storage for the types to iterate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af638f85aa855e8364af76d8bf93eee3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af638f85aa855e8364af76d8bf93eee3b">&#9670;&nbsp;</a></span>compressed_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Other &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1compressed__pair.html">entt::compressed_pair</a> </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Other &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; std::decay_t&lt; Type &gt;, std::decay_t&lt; Other &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of value to use to initialize the first element. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of value to use to initialize the second element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c8907a3a72cd2da043d81f6fd50487a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8907a3a72cd2da043d81f6fd50487a">&#9670;&nbsp;</a></span>delegate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Candidate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate)&gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>Function or member to connect to the delegate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39ba791dbcdecb9415a5c11fe69c4b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ba791dbcdecb9415a5c11fe69c4b1c">&#9670;&nbsp;</a></span>delegate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Candidate, typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate), Type &gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>Function or member to connect to the delegate. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of class or type of payload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba06006a862fa5dc613e8561ac4e92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba06006a862fa5dc613e8561ac4e92c">&#9670;&nbsp;</a></span>delegate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype">Ret(*)(const void *, Args...)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ab7b51802157a98106f238335fa7503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab7b51802157a98106f238335fa7503">&#9670;&nbsp;</a></span>dereference_meta_pointer_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) entt::dereference_meta_pointer_like </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ADL based lookup function for dereferencing meta pointer-like types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer-like object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value returned from the dereferenced pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adl__pointer_8hpp_source.html#l00013">13</a> of file <a class="el" href="adl__pointer_8hpp_source.html">adl_pointer.hpp</a>.</p>

</div>
</div>
<a id="a28fe7952c2a11ebc2b47d95fb749adda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fe7952c2a11ebc2b47d95fb749adda">&#9670;&nbsp;</a></span>fast_mod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t entt::fast_mod </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast module utility function (powers of two only). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A value for which to calculate the modulus. </td></tr>
    <tr><td class="paramname">mod</td><td><em>Modulus</em>, it must be a power of two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The common remainder. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00101">101</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a810f66c2c91deba50f96cae9119f2feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810f66c2c91deba50f96cae9119f2feb">&#9670;&nbsp;</a></span>forward_as_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt;Len, Align&gt; entt::forward_as_any </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forwards its argument and avoids copies for lvalue references. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Optional alignment requirement. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of argument to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Parameter to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized and not necessarily owning wrapper. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00488">488</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a77c7a5a8ac08bc879abdaa00f920a996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c7a5a8ac08bc879abdaa00f920a996">&#9670;&nbsp;</a></span>forward_as_meta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::forward_as_meta </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forwards its argument and avoids copies for lvalue references. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of argument to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Parameter to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized and not necessarily owning wrapper. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00629">629</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="aa512a354fe328df6be5a92eb43cd4d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa512a354fe328df6be5a92eb43cd4d69">&#9670;&nbsp;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Member, typename Entity  = entity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void entt::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to create a listener that directly invokes a member function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>Member function to invoke on a component of the given type. </td></tr>
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>A registry that contains the given entity and its components. </td></tr>
    <tr><td class="paramname">entt</td><td>Entity from which to get the component. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="helper_8hpp_source.html#l00119">119</a> of file <a class="el" href="helper_8hpp_source.html">helper.hpp</a>.</p>

</div>
</div>
<a id="a3755517604de1d9d3f3e0a5549c750c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3755517604de1d9d3f3e0a5549c750c5">&#9670;&nbsp;</a></span>is_power_of_two()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_power_of_two </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a value is a power of two or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A value that may or may not be a power of two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value is a power of two, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00075">75</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a246375cb799b9dc67b9a555f91d94099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246375cb799b9dc67b9a555f91d94099">&#9670;&nbsp;</a></span>make_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len = basic_any&lt;&gt;::length, std::size_t Align = basic_any&lt;Len&gt;::alignment, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt;Len, Align&gt; entt::make_any </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a wrapper from a given type, passing it all arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of object to use to initialize the wrapper. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Optional alignment requirement. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized wrapper for an object of the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00475">475</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="abdd5e7fb78b64f8238eacae2f10ba06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd5e7fb78b64f8238eacae2f10ba06e">&#9670;&nbsp;</a></span>make_meta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::make_meta </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a wrapper from a given type, passing it all arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of object to use to initialize the wrapper. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to use to construct the new instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized wrapper for an object of the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00618">618</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a3ae5a1bdbb378be2ae0556ff437cf513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae5a1bdbb378be2ae0556ff437cf513">&#9670;&nbsp;</a></span>meta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto entt::meta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to use for reflection. </p>
<p>This is the point from which everything starts.<br  />
 By invoking this function with a type that is not yet reflected, a meta type is created to which it will be possible to attach meta objects through a dedicated factory.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to reflect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta factory for the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00582">582</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="aef8c196db303590ebe456287b5890cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8c196db303590ebe456287b5890cf4">&#9670;&nbsp;</a></span>meta_construct() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Policy  = as_is_t, typename Candidate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype">Candidate &amp;&amp;&#160;</td>
          <td class="paramname"><em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the object to <em>invoke</em> is associated. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Candidate</td><td>The type of the actual object to <em>invoke</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to <em>invoke</em> the object. </td></tr>
    <tr><td class="paramname">candidate</td><td>The actual object to <em>invoke</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00373">373</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a3b0d075524517183181aa512417358a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0d075524517183181aa512417358a0">&#9670;&nbsp;</a></span>meta_construct() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Actual type of the instance to construct. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments expected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the new instance, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00359">359</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a681f2bc9d84e3851405cf4b8c8e21455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681f2bc9d84e3851405cf4b8c8e21455">&#9670;&nbsp;</a></span>meta_construct() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Candidate, typename Policy  = as_is_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to construct an instance given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to invoke. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to invoke the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00390">390</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a957782a57268c06cef354868d4402c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957782a57268c06cef354868d4402c74">&#9670;&nbsp;</a></span>meta_dispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Policy  = as_is_t, typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_dispatch </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a value depending on the given policy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Type</td><td>Type of value to wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00164">164</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a3fe26d091f302630470004fe314a6a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe26d091f302630470004fe314a6a8d">&#9670;&nbsp;</a></span>meta_getter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Data, typename Policy  = as_is_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_getter </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value of a given variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the variable is associated. </td></tr>
    <tr><td class="paramname">Data</td><td>The actual variable to get. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the value of the underlying variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00240">240</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a00d375156fcfcc72d62eab6728650556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d375156fcfcc72d62eab6728650556">&#9670;&nbsp;</a></span>meta_invoke() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Policy  = as_is_t, typename Candidate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_invoke </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Candidate &amp;&amp;&#160;</td>
          <td class="paramname"><em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to <em>invoke</em> an object given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the object to <em>invoke</em> is associated. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Candidate</td><td>The type of the actual object to <em>invoke</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">candidate</td><td>The actual object to <em>invoke</em>. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to <em>invoke</em> the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00333">333</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a3281f612575b11cef54d9d1008d7a469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3281f612575b11cef54d9d1008d7a469">&#9670;&nbsp;</a></span>meta_invoke() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Candidate, typename Policy  = as_is_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to invoke a function given a list of erased parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to invoke. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to invoke the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00347">347</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a0e6591abe0fd3b376413e2ba5ba760ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6591abe0fd3b376413e2ba5ba760ea">&#9670;&nbsp;</a></span>meta_reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::meta_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a type and all its parts. </p>
<p>Resets all searchable types.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceentt.html#a4f5090482af8e4ab0afa3e27abf1eec3" title="Resets a type and all its parts.">meta_reset</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceentt.html#a4f5090482af8e4ab0afa3e27abf1eec3" title="Resets a type and all its parts.">meta_reset</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00635">635</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a4f5090482af8e4ab0afa3e27abf1eec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5090482af8e4ab0afa3e27abf1eec3">&#9670;&nbsp;</a></span>meta_reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::meta_reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a type and all its parts. </p>
<p>Resets a type and all its data members, member functions and properties, as well as its constructors, destructors and conversion functions if any.<br  />
 Base classes aren't reset but the link between the two types is removed.</p>
<p>The type is also removed from the list of searchable types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique identifier. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00599">599</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="adbe109e5134bae55cb519799acbed732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe109e5134bae55cb519799acbed732">&#9670;&nbsp;</a></span>meta_setter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool entt::meta_setter </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of a given variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the variable is associated. </td></tr>
    <tr><td class="paramname">Data</td><td>The actual variable to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">value</td><td>Parameter to use to set the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00197">197</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a5a2dbf5d86123af800abdd8fe69542ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2dbf5d86123af800abdd8fe69542ca">&#9670;&nbsp;</a></span>next_power_of_two()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t entt::next_power_of_two </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the smallest power of two greater than or equal to a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest power of two greater than or equal to the given value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00084">84</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ae38ac5bc7b9097ec21eb1058db206cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38ac5bc7b9097ec21eb1058db206cff">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two wrappers differ in their content. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A wrapper, either empty or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A wrapper, either empty or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two wrappers differ in their content, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00406">406</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a7ef0d5ec3214e57aa4b8406fbe9ee3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef0d5ec3214e57aa4b8406fbe9ee3a5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args, typename... Other&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Other... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Scope of the first handle. </td></tr>
    <tr><td class="paramname">Other</td><td>Scope of the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if both handles refer to the same registry and the same entity, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_2handle_8hpp_source.html#l00320">320</a> of file <a class="el" href="entity_2handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="ac200eb460760246368bb737dc434c0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac200eb460760246368bb737dc434c0eb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two hashed strings differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00229">229</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="ac8711ef7a24e5329d7cbd0d05136874e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8711ef7a24e5329d7cbd0d05136874e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the contents of two delegates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid delegate object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid delegate object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two contents differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="delegate_8hpp_source.html#l00310">310</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a id="a6185f9faa3f9fa26ecb1b9a837016147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6185f9faa3f9fa26ecb1b9a837016147">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1null__t.html">null_t</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a null object and an identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Identifier with which to compare. </td></tr>
    <tr><td class="paramname">other</td><td>A null object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two elements differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00236">236</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a39702a79d9ba6f5d7cb8668b0a7a1524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39702a79d9ba6f5d7cb8668b0a7a1524">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a tombstone object and an identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Identifier with which to compare. </td></tr>
    <tr><td class="paramname">other</td><td>A tombstone object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two elements differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00315">315</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a845d4ef2c448264153449c92157a0359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845d4ef2c448264153449c92157a0359">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two wrappers differ in their content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A wrapper, either empty or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A wrapper, either empty or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two wrappers differ in their content, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00606">606</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a04ebb219547c34209a94c9eb6d26eda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ebb219547c34209a94c9eb6d26eda1">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two objects refer to the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>An object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>An object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the objects refer to the same node, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l01377">1377</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a5b6b2e64d7d0ca7bd46c4fc9009cb552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6b2e64d7d0ca7bd46c4fc9009cb552">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two type info objects differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00198">198</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a556190d147a6a92fc16bbf31bd4b263a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556190d147a6a92fc16bbf31bd4b263a">&#9670;&nbsp;</a></span>operator&quot;&quot;_hs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">entt::hashed_string</a> entt::literals::operator&quot;&quot;_hs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined literal for hashed strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The literal without its suffix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized hashed string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00297">297</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a226e03b3f52eb1bbce832ec53106bd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226e03b3f52eb1bbce832ec53106bd6a">&#9670;&nbsp;</a></span>operator&quot;&quot;_hws()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">entt::hashed_wstring</a> entt::literals::operator&quot;&quot;_hws </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined literal for hashed wstrings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The literal without its suffix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized hashed wstring. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00306">306</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a6c6e966c8af5b1452811aa55adbbdf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6e966c8af5b1452811aa55adbbdf47">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type, typename... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt;Type..., Other...&gt; entt::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Other... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates multiple type lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Types provided by the first type list. </td></tr>
    <tr><td class="paramname">Other</td><td>Types provided by the second type list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type list composed by the types of both the type lists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00157">157</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aabc6dd5fb4d2bc92d9e5101b7b0bce1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc6dd5fb4d2bc92d9e5101b7b0bce1d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto... Value, auto... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1value__list.html">value_list</a>&lt;Value..., Other...&gt; entt::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Other... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates multiple value lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Values provided by the first value list. </td></tr>
    <tr><td class="paramname">Other</td><td>Values provided by the second value list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value list composed by the values of both the value lists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00332">332</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a95abccf779882bf65c4bb1cb99b8059c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95abccf779882bf65c4bb1cb99b8059c">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is less than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00241">241</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="ac2789bea84be3354b9ec3f48b0af539c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2789bea84be3354b9ec3f48b0af539c">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is less than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00208">208</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a400fd2e18a1fe98013bd4cdb281ad98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400fd2e18a1fe98013bd4cdb281ad98f">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is less than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00254">254</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="ac99351681df5ffc84efcc14603ab6fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99351681df5ffc84efcc14603ab6fc3">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is less than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00219">219</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="aee5fe16dfbb40ab097d339b0c008fae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5fe16dfbb40ab097d339b0c008fae7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args, typename... Other&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Other... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Scope of the first handle. </td></tr>
    <tr><td class="paramname">Other</td><td>Scope of the second handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both handles refer to the same registry and the same entity, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_2handle_8hpp_source.html#l00306">306</a> of file <a class="el" href="entity_2handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a07b2e32d6df969a3d20a8f263265fe96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b2e32d6df969a3d20a8f263265fe96">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two hashed strings are identical, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00217">217</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="af6de691c4ec15d4a63ea8960563bbea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6de691c4ec15d4a63ea8960563bbea0">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1null__t.html">null_t</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a null object and an identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Identifier with which to compare. </td></tr>
    <tr><td class="paramname">other</td><td>A null object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the two elements differ, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00224">224</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a0f371da1ef604fa726a88e9733e5ee54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f371da1ef604fa726a88e9733e5ee54">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a tombstone object and an identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Identifier with which to compare. </td></tr>
    <tr><td class="paramname">other</td><td>A tombstone object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the two elements differ, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00303">303</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a13f95d943a5794e7f7b481d3e02a2d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f95d943a5794e7f7b481d3e02a2d96">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two type info objects are identical, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00188">188</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="affca347714c6771f1f5928f1c18a070f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affca347714c6771f1f5928f1c18a070f">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is greater than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00267">267</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a28f32860fd6de66a832389b365045047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f32860fd6de66a832389b365045047">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is greater than the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00230">230</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a5d583f542e17fa8eb56d8d01c34b8920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d583f542e17fa8eb56d8d01c34b8920">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is greater than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00280">280</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a2e6acc16fe38d13c69b5d1fb237e4ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6acc16fe38d13c69b5d1fb237e4ac5">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first element is greater than or equal to the second, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00241">241</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="ad4ea6822ef21f52c732ba3baea450159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ea6822ef21f52c732ba3baea450159">&#9670;&nbsp;</a></span>overload() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::overload </td>
          <td>(</td>
          <td class="paramtype">Func *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant utility to disambiguate overloaded functions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Function type of the desired overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A valid pointer to a function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2utility_8hpp_source.html#l00045">45</a> of file <a class="el" href="core_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a386a739051d9d37a5578785b77fc426b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386a739051d9d37a5578785b77fc426b">&#9670;&nbsp;</a></span>overload() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::overload </td>
          <td>(</td>
          <td class="paramtype">Type Class::*&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant utility to disambiguate overloaded members of a class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the desired overload. </td></tr>
    <tr><td class="paramname">Class</td><td>Type of class to which the member belongs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>A valid pointer to a member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the member. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2utility_8hpp_source.html#l00034">34</a> of file <a class="el" href="core_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a26eb67ac302229374c5fb623d529f5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26eb67ac302229374c5fb623d529f5eb">&#9670;&nbsp;</a></span>overloaded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Func&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1overloaded.html">entt::overloaded</a> </td>
          <td>(</td>
          <td class="paramtype">Func...&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1overloaded.html">overloaded</a>&lt; Func... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Types of function objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b4f2adf317a555138ef5c1cf45b034a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4f2adf317a555138ef5c1cf45b034a">&#9670;&nbsp;</a></span>poly_call()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Member, typename Poly , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) entt::poly_call </td>
          <td>(</td>
          <td class="paramtype">Poly &amp;&amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcut for calling <code><a class="el" href="structentt_1_1poly__base.html" title="Poly base class used to inject functionalities into concepts.">poly_base</a>&lt;Type&gt;<a class="el" href="namespaceentt.html#aa512a354fe328df6be5a92eb43cd4d69" title="Helper to create a listener that directly invokes a member function.">invoke</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>Index of the function to invoke. </td></tr>
    <tr><td class="paramname">Poly</td><td>A fully defined poly object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A reference to the poly object that made the call. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the invoked function, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="poly_8hpp_source.html#l00172">172</a> of file <a class="el" href="poly_8hpp_source.html">poly.hpp</a>.</p>

</div>
</div>
<a id="a9eb49df8bf1b69e836039b76e5b9938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb49df8bf1b69e836039b76e5b9938e">&#9670;&nbsp;</a></span>propagate_on_container_copy_assignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void entt::propagate_on_container_copy_assignment </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] Allocator &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] Allocator &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to design allocation-aware containers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Allocator</td><td>Type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid allocator. </td></tr>
    <tr><td class="paramname">rhs</td><td>Another valid allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00035">35</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a122ae54373a080574c45c77319cec7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122ae54373a080574c45c77319cec7f7">&#9670;&nbsp;</a></span>propagate_on_container_move_assignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void entt::propagate_on_container_move_assignment </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] Allocator &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] Allocator &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to design allocation-aware containers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Allocator</td><td>Type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid allocator. </td></tr>
    <tr><td class="paramname">rhs</td><td>Another valid allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00048">48</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a1359cd624e6726f884df34df66656855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1359cd624e6726f884df34df66656855">&#9670;&nbsp;</a></span>propagate_on_container_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void entt::propagate_on_container_swap </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] Allocator &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] Allocator &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to design allocation-aware containers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Allocator</td><td>Type of allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid allocator. </td></tr>
    <tr><td class="paramname">rhs</td><td>Another valid allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00061">61</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a0b62be0d39676cb86f2aefefa890b198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b62be0d39676cb86f2aefefa890b198">&#9670;&nbsp;</a></span>resolve() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1meta__range.html">meta_range</a>&lt; <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &gt; entt::resolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type. </p>
<p>Returns a range to use to visit all meta types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to use to search for a meta type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type, if any.</dd>
<dd>
An iterable range to use to visit all meta types. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00019">19</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a1915a651e7ce55938a09269c3d9c98e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1915a651e7ce55938a09269c3d9c98e4">&#9670;&nbsp;</a></span>resolve() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given identifier, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given identifier, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00036">36</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a834693b80a8d9af8b6d6edb81cb54b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834693b80a8d9af8b6d6edb81cb54b39">&#9670;&nbsp;</a></span>resolve() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type info object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The type info object of the requested type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type info object, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00051">51</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="aba4dd70afb5ef2529d05bc474b234f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4dd70afb5ef2529d05bc474b234f53">&#9670;&nbsp;</a></span>sink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename... Args, typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sink.html">entt::sink</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...), Allocator &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1sink.html">sink</a>&lt; <a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...), Allocator &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the signal handler type of a sink directly from the signal it refers to.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef08fc4202f32f712bde26f55db463cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef08fc4202f32f712bde26f55db463cb">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void entt::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; First, Second &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1compressed__pair.html">compressed_pair</a>&lt; First, Second &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two compressed pair objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">First</td><td>The type of the first element that the pairs store. </td></tr>
    <tr><td class="paramname">Second</td><td>The type of the second element that the pairs store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid compressed pair object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid compressed pair object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="compressed__pair_8hpp_source.html#l00248">248</a> of file <a class="el" href="compressed__pair_8hpp_source.html">compressed_pair.hpp</a>.</p>

</div>
</div>
<a id="a94ed50d1975e6adee73101eb05c88d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ed50d1975e6adee73101eb05c88d73">&#9670;&nbsp;</a></span>to_address()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::to_address </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unwraps fancy pointers, does nothing otherwise (waiting for C++20). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Pointer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Fancy or raw pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raw pointer that represents the address of the original pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory_8hpp_source.html#l00020">20</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ae81b68364d770429f343d703f415d12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81b68364d770429f343d703f415d12a">&#9670;&nbsp;</a></span>to_entity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Component &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Entity entt::to_entity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Component &amp;&#160;</td>
          <td class="paramname"><em>instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the entity associated with a given component. </p>
<dl class="section warning"><dt>Warning</dt><dd>Currently, this function only works correctly with the default pool as it makes assumptions about how the components are laid out.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
    <tr><td class="paramname">Component</td><td>Type of component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>A registry that contains the given entity and its components. </td></tr>
    <tr><td class="paramname">instance</td><td>A valid component instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entity associated with the given component. </dd></dl>

<p class="definition">Definition at line <a class="el" href="helper_8hpp_source.html#l00140">140</a> of file <a class="el" href="helper_8hpp_source.html">helper.hpp</a>.</p>

</div>
</div>
<a id="ae1b0b05750caf25f9718c2bebf55d25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b0b05750caf25f9718c2bebf55d25c">&#9670;&nbsp;</a></span>to_entity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classentt_1_1entt__traits.html">entt_traits</a>&lt;Entity&gt;::entity_type entt::to_entity </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entity part once converted to the underlying type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral representation of the entity part. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>The value type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00148">148</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="abd7521f3d3ca914ea5bd131269ba75aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7521f3d3ca914ea5bd131269ba75aa">&#9670;&nbsp;</a></span>to_integral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classentt_1_1entt__traits.html">entt_traits</a>&lt;Entity&gt;::entity_type entt::to_integral </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an entity to its underlying type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral representation of the given value. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>The value type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00139">139</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="ae7dc0f67afc2c0924dc2c0f51dcadadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7dc0f67afc2c0924dc2c0f51dcadadf">&#9670;&nbsp;</a></span>to_version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classentt_1_1entt__traits.html">entt_traits</a>&lt;Entity&gt;::version_type entt::to_version </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the version part once converted to the underlying type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral representation of the version part. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>The value type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00157">157</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a2e2dcd5e9e474d7ab0f2db24dae09dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2dcd5e9e474d7ab0f2db24dae09dd5">&#9670;&nbsp;</a></span>type_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classentt_1_1type__info.html">type_info</a>&amp; entt::type_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type info object associated to a given type. </p>
<p>The type doesn't need to be a complete type. If the type is a reference, the result refers to the referenced type. In all cases, top-level cv-qualifiers are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type for which to generate a type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized type info object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00256">256</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="a29ad46972bf4848e06a728c232b94bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ad46972bf4848e06a728c232b94bf0">&#9670;&nbsp;</a></span>unwrap_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) entt::unwrap_tuple </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to unwrap tuples of a single element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Tuple type of any sizes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A tuple object of the given type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tuple itself if it contains more than one element, the first element otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00019">19</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a089f75043b082abca3ea144bce44e9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089f75043b082abca3ea144bce44e9ae">&#9670;&nbsp;</a></span>choice</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1choice__t.html">choice_t</a>&lt;N&gt; entt::choice {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for the choice trick. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of choices available. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00032">32</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a8378b9330b5c90b6b11deee3637ebca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8378b9330b5c90b6b11deee3637ebca6">&#9670;&nbsp;</a></span>enum_as_bitmask_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::enum_as_bitmask_v = <a class="el" href="structentt_1_1enum__as__bitmask.html">enum_as_bitmask</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The enum class type for which to enable bitmask support. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="enum_8hpp_source.html#l00025">25</a> of file <a class="el" href="enum_8hpp_source.html">enum.hpp</a>.</p>

</div>
</div>
<a id="a5b73210cef43c4db35ef8ce477cc38a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b73210cef43c4db35ef8ce477cc38a6">&#9670;&nbsp;</a></span>exclude</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt;Type...&gt; entt::exclude {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for exclusion lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2utility_8hpp_source.html#l00020">20</a> of file <a class="el" href="entity_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a8c24ecc5ab0055f9f2a4725c95afb29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c24ecc5ab0055f9f2a4725c95afb29e">&#9670;&nbsp;</a></span>get</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt;Type...&gt; entt::get {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for lists of observed components. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2utility_8hpp_source.html#l00034">34</a> of file <a class="el" href="entity_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="ab9f9b531ebde614244a0da111d4b66ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f9b531ebde614244a0da111d4b66ff">&#9670;&nbsp;</a></span>ignore_as_empty_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::ignore_as_empty_v = <a class="el" href="structentt_1_1component__traits.html">component_traits</a>&lt;Type&gt;::ignore_if_empty &amp;&amp;std::is_empty_v&lt;Type&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of component. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="component_8hpp_source.html#l00033">33</a> of file <a class="el" href="component_8hpp_source.html">component.hpp</a>.</p>

</div>
</div>
<a id="ae764716fab8c01b12d3e209004b62647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae764716fab8c01b12d3e209004b62647">&#9670;&nbsp;</a></span>is_applicable_r_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Func , typename Args &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_applicable_r_v = <a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a>&lt;Ret, Func, Args&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>The type to which the return type of the function should be convertible. </td></tr>
    <tr><td class="paramname">Func</td><td>A valid function type. </td></tr>
    <tr><td class="paramname">Args</td><td>The list of arguments to use to probe the function type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00428">428</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a4f238620469de3ef2bafdb28fe4657ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f238620469de3ef2bafdb28fe4657ef">&#9670;&nbsp;</a></span>is_applicable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename Args &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_applicable_v = <a class="el" href="structentt_1_1is__applicable.html">is_applicable</a>&lt;Func, Args&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>A valid function type. </td></tr>
    <tr><td class="paramname">Args</td><td>The list of arguments to use to probe the function type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00404">404</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a8a96fcc4bc8da9a2aa1cdb0bc15b75c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a96fcc4bc8da9a2aa1cdb0bc15b75c8">&#9670;&nbsp;</a></span>is_complete_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_complete_v = <a class="el" href="structentt_1_1is__complete.html">is_complete</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00447">447</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="afb5b1446d23f1cba20563114f5da1f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5b1446d23f1cba20563114f5da1f9d">&#9670;&nbsp;</a></span>is_ebco_eligible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_ebco_eligible_v = <a class="el" href="structentt_1_1is__ebco__eligible.html">is_ebco_eligible</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00530">530</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a068dd98a70c771935d2bf3dd96dbad6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068dd98a70c771935d2bf3dd96dbad6d">&#9670;&nbsp;</a></span>is_equality_comparable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_equality_comparable_v = <a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00619">619</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ac4081aa5332fcb3367063eeba93918b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4081aa5332fcb3367063eeba93918b8">&#9670;&nbsp;</a></span>is_iterator_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_iterator_type_v = <a class="el" href="structentt_1_1is__iterator__type.html">is_iterator_type</a>&lt;Type, It&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
    <tr><td class="paramname">It</td><td>Required iterator type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00514">514</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a3ac133ddb24ec535a11baf3143d188d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac133ddb24ec535a11baf3143d188d6">&#9670;&nbsp;</a></span>is_iterator_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_iterator_v = <a class="el" href="structentt_1_1is__iterator.html">is_iterator</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00487">487</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aaa8c390cfe71301a0c10f4844e98424c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8c390cfe71301a0c10f4844e98424c">&#9670;&nbsp;</a></span>is_meta_pointer_like_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::is_meta_pointer_like_v = <a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potentially pointer-like type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="meta_2type__traits_8hpp_source.html#l00051">51</a> of file <a class="el" href="meta_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a5fd3998d86cc531f800d0104478771f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd3998d86cc531f800d0104478771f4">&#9670;&nbsp;</a></span>is_transparent_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::is_transparent_v = <a class="el" href="structentt_1_1is__transparent.html">is_transparent</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00549">549</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ab43a13f7ee60bcb0d04a001f92b86fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43a13f7ee60bcb0d04a001f92b86fa2">&#9670;&nbsp;</a></span>monostate_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;id_type Value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1monostate.html">monostate</a>&lt;Value&gt; entt::monostate_v = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Value used to differentiate between different variables. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="monostate_8hpp_source.html#l00052">52</a> of file <a class="el" href="monostate_8hpp_source.html">monostate.hpp</a>.</p>

</div>
</div>
<a id="a2f0c0a1c1d953ea991591748744cdd8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0c0a1c1d953ea991591748744cdd8b">&#9670;&nbsp;</a></span>null</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1null__t.html">null_t</a> entt::null {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time constant for null entities. </p>
<p>There exist implicit conversions from this variable to identifiers of any allowed type. Similarly, there exist comparision operators between the null entity and any other identifier. </p>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00326">326</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="ac91ddbe2446a912714a5fe7251e25768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91ddbe2446a912714a5fe7251e25768">&#9670;&nbsp;</a></span>owned</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1owned__t.html">owned_t</a>&lt;Type...&gt; entt::owned {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for lists of owned components. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2utility_8hpp_source.html#l00048">48</a> of file <a class="el" href="entity_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a15f9a70cbdd5a64f897a012ab2b5834f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f9a70cbdd5a64f897a012ab2b5834f">&#9670;&nbsp;</a></span>size_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t entt::size_of_v = <a class="el" href="structentt_1_1size__of.html">size_of</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of which to return the size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00073">73</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a674269102fdfe3fd6d7766210a828862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674269102fdfe3fd6d7766210a828862">&#9670;&nbsp;</a></span>tombstone</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1tombstone__t.html">tombstone_t</a> entt::tombstone {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time constant for tombstone entities. </p>
<p>There exist implicit conversions from this variable to identifiers of any allowed type. Similarly, there exist comparision operators between the tombstone entity and any other identifier. </p>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00335">335</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a988ce063936d499bf2d69406c391fd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988ce063936d499bf2d69406c391fd5c">&#9670;&nbsp;</a></span>type_list_contains_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List , typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::type_list_contains_v = <a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a>&lt;List, Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type list. </td></tr>
    <tr><td class="paramname">Type</td><td>Type to look for. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00256">256</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aee7558c4e09ee416fb7fa3576737ff65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7558c4e09ee416fb7fa3576737ff65">&#9670;&nbsp;</a></span>unpack_as_value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Value, typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::unpack_as_value = Value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template to be used to <em>repeat</em> the same value a number of times equal to the size of a given parameter pack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A value to repeat. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00089">89</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a4bbfb162708696f9c1497d61573b540f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbfb162708696f9c1497d61573b540f">&#9670;&nbsp;</a></span>value_list_element_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename List &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::value_list_element_v = <a class="el" href="structentt_1_1value__list__element.html">value_list_element</a>&lt;Index, List&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index of the value to return. </td></tr>
    <tr><td class="paramname">List</td><td>Value list to search into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00323">323</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
