<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: entt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EnTT
   &#160;<span id="projectnumber">3.7.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">entt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>EnTT</code> default namespace.  
<a href="namespaceentt.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1adl__meta__pointer__like.html">adl_meta_pointer_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fake ADL based lookup function for meta pointer-like types.  <a href="structentt_1_1adl__meta__pointer__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__cref__t.html">as_cref_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as cref</em> policy.  <a href="structentt_1_1as__cref__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__group.html">as_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a registry to a group.  <a href="structentt_1_1as__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__is__t.html">as_is_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as-is</em> policy.  <a href="structentt_1_1as__is__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__ref__t.html">as_ref_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as ref</em> policy.  <a href="structentt_1_1as__ref__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__view.html">as_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a registry to a view.  <a href="structentt_1_1as__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1as__void__t.html">as_void_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class type used to request the <em>as void</em> policy.  <a href="structentt_1_1as__void__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__any.html">basic_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SBO friendly, type-safe container for single values of any type.  <a href="classentt_1_1basic__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__associative__container.html">basic_associative_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic STL-compatible associative container traits.  <a href="structentt_1_1basic__associative__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector.html">basic_collector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector_3_01matcher_3_01type__list_3_01Reject_8_8_8_01_4_00_01type__list_98a79514dcad34a82f321f0796064ffb.html">basic_collector&lt; matcher&lt; type_list&lt; Reject... &gt;, type_list&lt; Require... &gt;, Rule... &gt;, Other... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector_3_01matcher_3_01type__list_3_01Reject_8_8_8_01_4_00_01type__list_98a79514dcad34a82f321f0796064ffb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__collector_3_4.html">basic_collector&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector.  <a href="structentt_1_1basic__collector_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__container.html">basic_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic STL-compatible container traits.  <a href="structentt_1_1basic__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__continuous__loader.html">basic_continuous_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for <em>continuous loading</em>.  <a href="classentt_1_1basic__continuous__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__dynamic__associative__container.html">basic_dynamic_associative_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic STL-compatible dynamic associative container traits.  <a href="structentt_1_1basic__dynamic__associative__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__dynamic__container.html">basic_dynamic_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic STL-compatible dynamic container traits.  <a href="structentt_1_1basic__dynamic__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group.html">basic_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group.  <a href="classentt_1_1basic__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01get__t_3_01Get_8_8_8_01_4_01_4.html">basic_group&lt; Entity, exclude_t&lt; Exclude... &gt;, get_t&lt; Get... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning group.  <a href="classentt_1_1basic__group_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01get__t_3_01Get_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__group_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01get__t_3_01Get_1aada3a14110654dc27700c17c9c2396.html">basic_group&lt; Entity, exclude_t&lt; Exclude... &gt;, get_t&lt; Get... &gt;, Owned... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning group.  <a href="classentt_1_1basic__group_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01get__t_3_01Get_1aada3a14110654dc27700c17c9c2396.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__handle.html">basic_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning handle to an entity.  <a href="structentt_1_1basic__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero overhead unique identifier.  <a href="classentt_1_1basic__hashed__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__observer.html">basic_observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observer.  <a href="classentt_1_1basic__observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__organizer.html">basic_organizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for creating a static task graph.  <a href="classentt_1_1basic__organizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__poly.html">basic_poly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static polymorphism made simple and within everyone's reach.  <a href="classentt_1_1basic__poly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast and reliable entity-component system.  <a href="classentt_1_1basic__registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime view.  <a href="classentt_1_1basic__runtime__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1basic__sequence__container.html">basic_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic STL-compatible sequence container traits.  <a href="structentt_1_1basic__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__snapshot.html">basic_snapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to create snapshots from a registry.  <a href="classentt_1_1basic__snapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__snapshot__loader.html">basic_snapshot_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to restore a snapshot as a whole.  <a href="classentt_1_1basic__snapshot__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic sparse set implementation.  <a href="classentt_1_1basic__sparse__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage.html">basic_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic storage implementation.  <a href="classentt_1_1basic__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__storage_3_01Entity_00_01Type_00_01std_1_1enable__if__t_3_01is__empty__v_3_01Type_01_4_01_4_01_4.html">basic_storage&lt; Entity, Type, std::enable_if_t&lt; is_empty_v&lt; Type &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic storage implementation.  <a href="classentt_1_1basic__storage_3_01Entity_00_01Type_00_01std_1_1enable__if__t_3_01is__empty__v_3_01Type_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view.html">basic_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View.  <a href="classentt_1_1basic__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01Component_8_8_8_01_4.html">basic_view&lt; Entity, exclude_t&lt; Exclude... &gt;, Component... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi component view.  <a href="classentt_1_1basic__view_3_01Entity_00_01exclude__t_3_01Exclude_8_8_8_01_4_00_01Component_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__view_3_01Entity_00_01exclude__t_3_4_00_01Component_01_4.html">basic_view&lt; Entity, exclude_t&lt;&gt;, Component &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single component view specialization.  <a href="classentt_1_1basic__view_3_01Entity_00_01exclude__t_3_4_00_01Component_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1choice__t.html">choice_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate overloaded functions.  <a href="structentt_1_1choice__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1choice__t_3_010_01_4.html">choice_t&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate overloaded functions.  <a href="structentt_1_1choice__t_3_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to wrap a function or a member of a specified type.  <a href="structentt_1_1connect__arg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1connection.html">connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection class.  <a href="classentt_1_1connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1constness__as.html">constness_as</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transcribes the constness of a type to another type.  <a href="structentt_1_1constness__as.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1constness__as_3_01To_00_01const_01From_01_4.html">constness_as&lt; To, const From &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transcribes the constness of a type to another type.  <a href="structentt_1_1constness__as_3_01To_00_01const_01From_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1delegate.html">delegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic delegate implementation.  <a href="classentt_1_1delegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1delegate_3_01Ret_07Args_8_8_8_08_4.html">delegate&lt; Ret(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to use to send around functions and members.  <a href="classentt_1_1delegate_3_01Ret_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1dispatcher.html">dispatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic dispatcher implementation.  <a href="classentt_1_1dispatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1dynamic__associative__key__only__container.html">dynamic_associative_key_only_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-compatible dynamic associative key-only container traits.  <a href="structentt_1_1dynamic__associative__key__only__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1dynamic__associative__key__value__container.html">dynamic_associative_key_value_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-compatible dynamic key-value associative container traits.  <a href="structentt_1_1dynamic__associative__key__value__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1dynamic__sequence__container.html">dynamic_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-compatible dynamic sequence container traits.  <a href="structentt_1_1dynamic__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1emitter.html">emitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose event emitter.  <a href="classentt_1_1emitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1entt__traits.html">entt_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity traits.  <a href="structentt_1_1entt__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1entt__traits_3_01std_1_1uint32__t_01_4.html">entt_traits&lt; std::uint32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity traits for a 32 bits entity identifier.  <a href="structentt_1_1entt__traits_3_01std_1_1uint32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1entt__traits_3_01std_1_1uint64__t_01_4.html">entt_traits&lt; std::uint64_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity traits for a 64 bits entity identifier.  <a href="structentt_1_1entt__traits_3_01std_1_1uint64__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1entt__traits_3_01Type_00_01std_1_1enable__if__t_3_01std_1_1is__enum__v_3_01Type_01_4_01_4_01_4.html">entt_traits&lt; Type, std::enable_if_t&lt; std::is_enum_v&lt; Type &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entity traits for enumeration types.  <a href="structentt_1_1entt__traits_3_01Type_00_01std_1_1enable__if__t_3_01std_1_1is__enum__v_3_01Type_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1exclude__t.html">exclude_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for exclusion lists.  <a href="structentt_1_1exclude__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1family.html">family</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic identifier generator.  <a href="classentt_1_1family.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1fixed__sequence__container.html">fixed_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-compatible fixed sequence container traits.  <a href="structentt_1_1fixed__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1get__t.html">get_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for lists of observed components.  <a href="structentt_1_1get__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1identifier.html">identifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types identifiers.  <a href="classentt_1_1identifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity function object (waiting for C++20).  <a href="structentt_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1insertion__sort.html">insertion_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing insertion sort.  <a href="structentt_1_1insertion__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable.html">is_applicable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.  <a href="structentt_1_1is__applicable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable_3_01Func_00_01const_01Tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable&lt; Func, const Tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.  <a href="structentt_1_1is__applicable_3_01Func_00_01const_01Tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable_3_01Func_00_01Tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable&lt; Func, Tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable, but with tuples.  <a href="structentt_1_1is__applicable_3_01Func_00_01Tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable_r, but with tuples for arguments.  <a href="structentt_1_1is__applicable__r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__applicable__r_3_01Ret_00_01Func_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html">is_applicable_r&lt; Ret, Func, std::tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::is_invocable_r, but with tuples for arguments.  <a href="structentt_1_1is__applicable__r_3_01Ret_00_01Func_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__complete.html">is_complete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is complete, false otherwise.  <a href="structentt_1_1is__complete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__complete_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html">is_complete&lt; Type, std::void_t&lt; decltype(sizeof(Type))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is complete, false otherwise.  <a href="structentt_1_1is__complete_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__empty.html">is_empty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is empty and the empty type optimization is enabled, false otherwise.  <a href="structentt_1_1is__empty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is equality comparable, false otherwise.  <a href="structentt_1_1is__equality__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__key__only__meta__associative__container.html">is_key_only_meta_associative_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a meta associative container claims to wrap a key-only type, false otherwise.  <a href="structentt_1_1is__key__only__meta__associative__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__key__only__meta__associative__container_3_01Type_00_01std_1_1void__t_3_01typen08c4aa5308e52cbb686af55767e67d40.html">is_key_only_meta_associative_container&lt; Type, std::void_t&lt; typename meta_associative_container_traits&lt; Type &gt;::type::mapped_type &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a meta associative container claims to wrap a key-only type, false otherwise.  <a href="structentt_1_1is__key__only__meta__associative__container_3_01Type_00_01std_1_1void__t_3_01typen08c4aa5308e52cbb686af55767e67d40.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is a pointer-like type from the point of view of the meta system, false otherwise.  <a href="structentt_1_1is__meta__pointer__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01const_01Type_01_4.html">is_meta_pointer_like&lt; const Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization to ensure that const pointer-like types are also accepted.  <a href="structentt_1_1is__meta__pointer__like_3_01const_01Type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01std_1_1shared__ptr_3_01Type_01_4_01_4.html">is_meta_pointer_like&lt; std::shared_ptr&lt; Type &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <code>std::shared_ptr</code>s of any type pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01std_1_1shared__ptr_3_01Type_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01std_1_1unique__ptr_3_01Type_00_01Args_8_8_8_01_4_01_4.html">is_meta_pointer_like&lt; std::unique_ptr&lt; Type, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <code>std::unique_ptr</code>s of any type pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01std_1_1unique__ptr_3_01Type_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__meta__pointer__like_3_01Type_01_5_01_4.html">is_meta_pointer_like&lt; Type * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes plain pointers pointer-like types for the meta system.  <a href="structentt_1_1is__meta__pointer__like_3_01Type_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__std__hashable.html">is_std_hashable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is hashable, false otherwise.  <a href="structentt_1_1is__std__hashable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1is__std__hashable_3_01Type_00_01std_1_1enable__if__t_3_01std_1_1is__convertible__v2db25a6fc70291b2836fc8dfe05b5c23.html">is_std_hashable&lt; Type, std::enable_if_t&lt; std::is_convertible_v&lt; decltype(std::declval&lt; std::hash&lt; Type &gt;&gt;()(std::declval&lt; Type &gt;())), std::size_t &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a given type is hashable, false otherwise.  <a href="structentt_1_1is__std__hashable_3_01Type_00_01std_1_1enable__if__t_3_01std_1_1is__convertible__v2db25a6fc70291b2836fc8dfe05b5c23.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1matcher.html">matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grouping matcher.  <a href="structentt_1_1matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1member__class.html">member_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the class of a non-static member object or function.  <a href="classentt_1_1member__class.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__any.html">meta_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for values of any type.  <a href="classentt_1_1meta__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__associative__container.html">meta_associative_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy object for associative containers.  <a href="classentt_1_1meta__associative__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits.html">meta_associative_container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta associative containers.  <a href="structentt_1_1meta__associative__container__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1map_3_01Key_00_01Value_00_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::map&lt; Key, Value, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::map</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1map_3_01Key_00_01Value_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1set_3_01Key_00_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::set&lt; Key, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::set</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1set_3_01Key_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__map_3_01Key_00_01Value_00_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::unordered_map&lt; Key, Value, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::unordered_map</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__map_3_01Key_00_01Value_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__set_3_01Key_00_01Args_8_8_8_01_4_01_4.html">meta_associative_container_traits&lt; std::unordered_set&lt; Key, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta associative container traits for <code>std::unordered_set</code>s of any type.  <a href="structentt_1_1meta__associative__container__traits_3_01std_1_1unordered__set_3_01Key_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__class__template__tag.html">meta_class_template_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to disambiguate class templates.  <a href="structentt_1_1meta__class__template__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__container__traits.html">meta_container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container traits.  <a href="structentt_1_1meta__container__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__ctor.html">meta_ctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for constructors.  <a href="structentt_1_1meta__ctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__ctx.html">meta_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque container for a meta context.  <a href="structentt_1_1meta__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__data.html">meta_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for data members.  <a href="structentt_1_1meta__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__factory.html">meta_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta factory to be used for reflection purposes.  <a href="structentt_1_1meta__factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__factory_3_01Type_01_4.html">meta_factory&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic meta factory to be used for reflection purposes.  <a href="structentt_1_1meta__factory_3_01Type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__factory_3_01Type_00_01Spec_8_8_8_01_4.html">meta_factory&lt; Type, Spec... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended meta factory to be used for reflection purposes.  <a href="structentt_1_1meta__factory_3_01Type_00_01Spec_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__func.html">meta_func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for member functions.  <a href="structentt_1_1meta__func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor.html">meta_function_descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1meta__function__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07Args_8_8_8_08_4.html">meta_function_descriptor&lt; Type, Ret(*)(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07_5_08_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_01const_01_4.html">meta_function_descriptor&lt; Type, Ret(Class::*)(Args...) const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_01const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_4.html">meta_function_descriptor&lt; Type, Ret(Class::*)(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function descriptor.  <a href="structentt_1_1meta__function__descriptor_3_01Type_00_01Ret_07Class_1_1_5_08_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function helper.  <a href="classentt_1_1meta__function__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__handle.html">meta_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque pointers to instances of any type.  <a href="structentt_1_1meta__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__prop.html">meta_prop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for properties of any type.  <a href="structentt_1_1meta__prop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__range.html">meta_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterable range to use to iterate all types of meta objects.  <a href="classentt_1_1meta__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__sequence__container.html">meta_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy object for sequence containers.  <a href="classentt_1_1meta__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits.html">meta_sequence_container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta sequence containers.  <a href="structentt_1_1meta__sequence__container__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits_3_01std_1_1array_3_01Type_00_01N_01_4_01_4.html">meta_sequence_container_traits&lt; std::array&lt; Type, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta sequence container traits for <code>std::array</code>s of any type.  <a href="structentt_1_1meta__sequence__container__traits_3_01std_1_1array_3_01Type_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__sequence__container__traits_3_01std_1_1vector_3_01Type_00_01Args_8_8_8_01_4_01_4.html">meta_sequence_container_traits&lt; std::vector&lt; Type, Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta sequence container traits for <code>std::vector</code>s of any type.  <a href="structentt_1_1meta__sequence__container__traits_3_01std_1_1vector_3_01Type_00_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__template__traits.html">meta_template_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class template to be specialized to enable support for meta template information.  <a href="structentt_1_1meta__template__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1meta__template__traits_3_01Clazz_3_01Args_8_8_8_01_4_01_4.html">meta_template_traits&lt; Clazz&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose traits class for generating meta template information.  <a href="structentt_1_1meta__template__traits_3_01Clazz_3_01Args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1meta__type.html">meta_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque wrapper for types.  <a href="classentt_1_1meta__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1monostate.html">monostate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal implementation of the monostate pattern.  <a href="structentt_1_1monostate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1null__t.html">null_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null object for all entity identifiers. <br  />
  <a href="structentt_1_1null__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1overloaded.html">overloaded</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for visitors.  <a href="structentt_1_1overloaded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1poly__base.html">poly_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poly base class used to inject functionalities into concepts.  <a href="structentt_1_1poly__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1poly__inspector.html">poly_inspector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspector class used to infer the type of the virtual table.  <a href="structentt_1_1poly__inspector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1poly__storage__traits.html">poly_storage_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the poly storage type associate with a given entity type.  <a href="structentt_1_1poly__storage__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1poly__vtable.html">poly_vtable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static virtual table factory.  <a href="classentt_1_1poly__vtable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1process.html">process</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for processes.  <a href="classentt_1_1process.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1process__adaptor.html">process_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor for lambdas and functors to turn them into processes.  <a href="structentt_1_1process__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1radix__sort.html">radix_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing LSD radix sort.  <a href="structentt_1_1radix__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1resource__cache.html">resource_cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple cache for resources of a given type.  <a href="structentt_1_1resource__cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1resource__handle.html">resource_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared resource handle.  <a href="structentt_1_1resource__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1resource__loader.html">resource_loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for resource loaders.  <a href="classentt_1_1resource__loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1scheduler.html">scheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooperative scheduler for processes.  <a href="classentt_1_1scheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1scoped__connection.html">scoped_connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scoped connection class.  <a href="structentt_1_1scoped__connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1service__locator.html">service_locator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Service locator, nothing more.  <a href="structentt_1_1service__locator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh.html">sigh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmanaged signal handler.  <a href="classentt_1_1sigh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh_3_01Ret_07Args_8_8_8_08_4.html">sigh&lt; Ret(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmanaged signal handler.  <a href="classentt_1_1sigh_3_01Ret_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sigh__storage__mixin.html">sigh_storage_mixin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin type to use to add signal support to storage types.  <a href="classentt_1_1sigh__storage__mixin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sink.html">sink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink class.  <a href="classentt_1_1sink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1sink_3_01Ret_07Args_8_8_8_08_4.html">sink&lt; Ret(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink class.  <a href="classentt_1_1sink_3_01Ret_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1size__of.html">size_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-only <code>sizeof</code> wrapper that returns 0 where <code>sizeof</code> complains.  <a href="structentt_1_1size__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1size__of_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html">size_of&lt; Type, std::void_t&lt; decltype(sizeof(Type))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-only <code>sizeof</code> wrapper that returns 0 where <code>sizeof</code> complains.  <a href="structentt_1_1size__of_3_01Type_00_01std_1_1void__t_3_01decltype_07sizeof_07Type_08_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1std__sort.html">std_sort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object to wrap <code>std::sort</code> in a class type.  <a href="structentt_1_1std__sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1Storage.html">Storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic poly storage implementation.  <a href="structentt_1_1Storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1storage__adapter__mixin.html">storage_adapter_mixin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin type to use to wrap basic storage classes.  <a href="structentt_1_1storage__adapter__mixin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1storage__traits.html">storage_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the component-to-storage conversion.  <a href="structentt_1_1storage__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__hash.html">type_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type hash.  <a href="structentt_1_1type__hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__identity.html">type_identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity type trait.  <a href="structentt_1_1type__identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1type__info.html">type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation specific information about a type.  <a href="classentt_1_1type__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list.html">type_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to use to push around lists of types, nothing more.  <a href="structentt_1_1type__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__cat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_01_4.html">type_list_cat&lt; type_list&lt; Type... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html">type_list_cat&lt; type_list&lt; Type... &gt;, type_list&lt; Other... &gt;, List... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__cat_3_4.html">type_list_cat&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="structentt_1_1type__list__cat_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a type list contains a given type, false otherwise.  <a href="structentt_1_1type__list__contains.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__contains_3_01type__list_3_01Type_8_8_8_01_4_00_01Other_01_4.html">type_list_contains&lt; type_list&lt; Type... &gt;, Other &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member constant <code>value</code> to true if a type list contains a given type, false otherwise.  <a href="structentt_1_1type__list__contains_3_01type__list_3_01Type_8_8_8_01_4_00_01Other_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__diff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__diff_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_01_4.html">type_list_diff&lt; type_list&lt; Type... &gt;, type_list&lt; Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the difference between two type lists.  <a href="structentt_1_1type__list__diff_3_01type__list_3_01Type_8_8_8_01_4_00_01type__list_3_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element.html">type_list_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element_3_010u_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html">type_list_element&lt; 0u, type_list&lt; Type, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1type__list__element_3_010u_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__element_3_01Index_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html">type_list_element&lt; Index, type_list&lt; Type, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1type__list__element_3_01Index_00_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1type__list__unique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique_3_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html">type_list_unique&lt; type_list&lt; Type, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates types from a type list.  <a href="structentt_1_1type__list__unique_3_01type__list_3_01Type_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__list__unique_3_01type__list_3_4_01_4.html">type_list_unique&lt; type_list&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicates types from a type list.  <a href="structentt_1_1type__list__unique_3_01type__list_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__name.html">type_name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type name.  <a href="structentt_1_1type__name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1type__seq.html">type_seq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type sequential identifier.  <a href="structentt_1_1type__seq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list.html">value_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to use to push around lists of constant values, nothing more.  <a href="structentt_1_1value__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1value__list__cat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_01_4.html">value_list_cat&lt; value_list&lt; Value... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_00_01value__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html">value_list_cat&lt; value_list&lt; Value... &gt;, value_list&lt; Other... &gt;, List... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_01value__list_3_01Value_8_8_8_01_4_00_01value__list_3_01Other_8_8_8_01_4_00_01List_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__cat_3_4.html">value_list_cat&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="structentt_1_1value__list__cat_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element.html">value_list_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template isn't defined on purpose.  <a href="structentt_1_1value__list__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element_3_010u_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html">value_list_element&lt; 0u, value_list&lt; Value, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of a type list.  <a href="structentt_1_1value__list__element_3_010u_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1value__list__element_3_01Index_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html">value_list_element&lt; Index, value_list&lt; Value, Other... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the values of a value list.  <a href="structentt_1_1value__list__element_3_01Index_00_01value__list_3_01Value_00_01Other_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structentt_1_1y__combinator.html">y_combinator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of a y-combinator.  <a href="structentt_1_1y__combinator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a13e040e7b38a8f86d1ab2f096f37b627"><td class="memItemLeft" align="right" valign="top"><a id="a13e040e7b38a8f86d1ab2f096f37b627"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> = std::uint32_t</td></tr>
<tr class="memdesc:a13e040e7b38a8f86d1ab2f096f37b627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for type identifiers. <br /></td></tr>
<tr class="separator:a13e040e7b38a8f86d1ab2f096f37b627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc3b1582213034f13e2afe5c475467a"><td class="memItemLeft" align="right" valign="top"><a id="a4dc3b1582213034f13e2afe5c475467a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4dc3b1582213034f13e2afe5c475467a">any</a> = <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; sizeof(double[2])&gt;</td></tr>
<tr class="memdesc:a4dc3b1582213034f13e2afe5c475467a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a4dc3b1582213034f13e2afe5c475467a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9dd22ce26cd7913a294b3fd520649b"><td class="memItemLeft" align="right" valign="top"><a id="a8f9dd22ce26cd7913a294b3fd520649b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">hashed_string</a> = <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a8f9dd22ce26cd7913a294b3fd520649b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases for common character types. <br /></td></tr>
<tr class="separator:a8f9dd22ce26cd7913a294b3fd520649b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2768719b1f5967caf5836b2656d0ed6"><td class="memItemLeft" align="right" valign="top"><a id="af2768719b1f5967caf5836b2656d0ed6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">hashed_wstring</a> = <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; wchar_t &gt;</td></tr>
<tr class="memdesc:af2768719b1f5967caf5836b2656d0ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases for common character types. <br /></td></tr>
<tr class="separator:af2768719b1f5967caf5836b2656d0ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a09f6bd6b4aebc03df720e7e69fdc6643">type_identity_t</a> = typename <a class="el" href="structentt_1_1type__identity.html">type_identity</a>&lt; Type &gt;::type</td></tr>
<tr class="memdesc:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a09f6bd6b4aebc03df720e7e69fdc6643">More...</a><br /></td></tr>
<tr class="separator:a09f6bd6b4aebc03df720e7e69fdc6643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a837a49598350009f463e37c86d322"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename &gt; </td></tr>
<tr class="memitem:a61a837a49598350009f463e37c86d322"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a61a837a49598350009f463e37c86d322">unpack_as_t</a> = Type</td></tr>
<tr class="memdesc:a61a837a49598350009f463e37c86d322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using declaration to be used to <em>repeat</em> the same type a number of times equal to the size of a given parameter pack.  <a href="namespaceentt.html#a61a837a49598350009f463e37c86d322">More...</a><br /></td></tr>
<tr class="separator:a61a837a49598350009f463e37c86d322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9fd5898acf13553bbcf14b99159f4d"><td class="memTemplParams" colspan="2">template&lt;auto Value&gt; </td></tr>
<tr class="memitem:a0d9fd5898acf13553bbcf14b99159f4d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">integral_constant</a> = std::integral_constant&lt; decltype(Value), Value &gt;</td></tr>
<tr class="memdesc:a0d9fd5898acf13553bbcf14b99159f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a static constant.  <a href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">More...</a><br /></td></tr>
<tr class="separator:a0d9fd5898acf13553bbcf14b99159f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="memTemplParams" colspan="2">template&lt;id_type Value&gt; </td></tr>
<tr class="memitem:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a9f7bb8c357f08a01ad9c8dab0ea40c1c">tag</a> = <a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">integral_constant</a>&lt; Value &gt;</td></tr>
<tr class="memdesc:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template to facilitate the creation of named values.  <a href="namespaceentt.html#a9f7bb8c357f08a01ad9c8dab0ea40c1c">More...</a><br /></td></tr>
<tr class="separator:a9f7bb8c357f08a01ad9c8dab0ea40c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac839c1a03dba2436791d0056d6d0d1b6"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename List &gt; </td></tr>
<tr class="memitem:ac839c1a03dba2436791d0056d6d0d1b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac839c1a03dba2436791d0056d6d0d1b6">type_list_element_t</a> = typename <a class="el" href="structentt_1_1type__list__element.html">type_list_element</a>&lt; Index, List &gt;::type</td></tr>
<tr class="memdesc:ac839c1a03dba2436791d0056d6d0d1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#ac839c1a03dba2436791d0056d6d0d1b6">More...</a><br /></td></tr>
<tr class="separator:ac839c1a03dba2436791d0056d6d0d1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546467a3662e9a915d5d519ad565e801"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:a546467a3662e9a915d5d519ad565e801"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">type_list_cat_t</a> = typename <a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a>&lt; List... &gt;::type</td></tr>
<tr class="memdesc:a546467a3662e9a915d5d519ad565e801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">More...</a><br /></td></tr>
<tr class="separator:a546467a3662e9a915d5d519ad565e801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a277a6037279d65cd3874b46ec7166"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a75a277a6037279d65cd3874b46ec7166"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">type_list_unique_t</a> = typename <a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a>&lt; Type &gt;::type</td></tr>
<tr class="memdesc:a75a277a6037279d65cd3874b46ec7166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">More...</a><br /></td></tr>
<tr class="separator:a75a277a6037279d65cd3874b46ec7166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2992fc009cb3199b0ef9a86bed2285c"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:af2992fc009cb3199b0ef9a86bed2285c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af2992fc009cb3199b0ef9a86bed2285c">type_list_diff_t</a> = typename <a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a>&lt; List... &gt;::type</td></tr>
<tr class="memdesc:af2992fc009cb3199b0ef9a86bed2285c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#af2992fc009cb3199b0ef9a86bed2285c">More...</a><br /></td></tr>
<tr class="separator:af2992fc009cb3199b0ef9a86bed2285c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1344cc62598091397018354e6905e431"><td class="memTemplParams" colspan="2">template&lt;typename... List&gt; </td></tr>
<tr class="memitem:a1344cc62598091397018354e6905e431"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a1344cc62598091397018354e6905e431">value_list_cat_t</a> = typename <a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a>&lt; List... &gt;::type</td></tr>
<tr class="memdesc:a1344cc62598091397018354e6905e431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a1344cc62598091397018354e6905e431">More...</a><br /></td></tr>
<tr class="separator:a1344cc62598091397018354e6905e431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b051461867d3c5c97f77f10b662c26b"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a7b051461867d3c5c97f77f10b662c26b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">constness_as_t</a> = typename <a class="el" href="structentt_1_1constness__as.html">constness_as</a>&lt; To, From &gt;::type</td></tr>
<tr class="memdesc:a7b051461867d3c5c97f77f10b662c26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template to facilitate the transcription of the constness.  <a href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">More...</a><br /></td></tr>
<tr class="separator:a7b051461867d3c5c97f77f10b662c26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="memTemplParams" colspan="2">template&lt;typename Member &gt; </td></tr>
<tr class="memitem:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a49f19d031690e5ebfffd6c7a4f6bd364">member_class_t</a> = typename <a class="el" href="classentt_1_1member__class.html">member_class</a>&lt; Member &gt;::type</td></tr>
<tr class="memdesc:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a49f19d031690e5ebfffd6c7a4f6bd364">More...</a><br /></td></tr>
<tr class="separator:a49f19d031690e5ebfffd6c7a4f6bd364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27c0013e504d544508cdacc01170b68"><td class="memItemLeft" align="right" valign="top"><a id="ac27c0013e504d544508cdacc01170b68"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac27c0013e504d544508cdacc01170b68">sparse_set</a> = <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:ac27c0013e504d544508cdacc01170b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:ac27c0013e504d544508cdacc01170b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcedb8f29753130e2bf3185bca211f05"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abcedb8f29753130e2bf3185bca211f05"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abcedb8f29753130e2bf3185bca211f05">storage</a> = <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args... &gt;</td></tr>
<tr class="memdesc:abcedb8f29753130e2bf3185bca211f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#abcedb8f29753130e2bf3185bca211f05">More...</a><br /></td></tr>
<tr class="separator:abcedb8f29753130e2bf3185bca211f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292643317d1dbb13e45824f757bd1086"><td class="memItemLeft" align="right" valign="top"><a id="a292643317d1dbb13e45824f757bd1086"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a292643317d1dbb13e45824f757bd1086">registry</a> = <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a292643317d1dbb13e45824f757bd1086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a292643317d1dbb13e45824f757bd1086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dfbb2991c5a19c6e2578830f7e3eda"><td class="memItemLeft" align="right" valign="top"><a id="a48dfbb2991c5a19c6e2578830f7e3eda"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a48dfbb2991c5a19c6e2578830f7e3eda">observer</a> = <a class="el" href="classentt_1_1basic__observer.html">basic_observer</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a48dfbb2991c5a19c6e2578830f7e3eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a48dfbb2991c5a19c6e2578830f7e3eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5870a148e25a503557bdd47327c7a05a"><td class="memItemLeft" align="right" valign="top"><a id="a5870a148e25a503557bdd47327c7a05a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5870a148e25a503557bdd47327c7a05a">organizer</a> = <a class="el" href="classentt_1_1basic__organizer.html">basic_organizer</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a5870a148e25a503557bdd47327c7a05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a5870a148e25a503557bdd47327c7a05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0027b922894421f703102c374c234c"><td class="memItemLeft" align="right" valign="top"><a id="a5a0027b922894421f703102c374c234c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5a0027b922894421f703102c374c234c">handle</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a5a0027b922894421f703102c374c234c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a5a0027b922894421f703102c374c234c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ab1aae5e5786a3ebb3b9bf1c7e82bd"><td class="memItemLeft" align="right" valign="top"><a id="a54ab1aae5e5786a3ebb3b9bf1c7e82bd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a54ab1aae5e5786a3ebb3b9bf1c7e82bd">const_handle</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; const <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a54ab1aae5e5786a3ebb3b9bf1c7e82bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a54ab1aae5e5786a3ebb3b9bf1c7e82bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5809ceb50ec17713e8690c20a79490"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aaa5809ceb50ec17713e8690c20a79490"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aaa5809ceb50ec17713e8690c20a79490">handle_view</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args... &gt;</td></tr>
<tr class="memdesc:aaa5809ceb50ec17713e8690c20a79490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#aaa5809ceb50ec17713e8690c20a79490">More...</a><br /></td></tr>
<tr class="separator:aaa5809ceb50ec17713e8690c20a79490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfeed27a790ac90eb5989da8a3ea860"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aedfeed27a790ac90eb5989da8a3ea860"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aedfeed27a790ac90eb5989da8a3ea860">const_handle_view</a> = <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; const <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args... &gt;</td></tr>
<tr class="memdesc:aedfeed27a790ac90eb5989da8a3ea860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#aedfeed27a790ac90eb5989da8a3ea860">More...</a><br /></td></tr>
<tr class="separator:aedfeed27a790ac90eb5989da8a3ea860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80012f9fa628920a3507ae947704d447"><td class="memItemLeft" align="right" valign="top"><a id="a80012f9fa628920a3507ae947704d447"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a80012f9fa628920a3507ae947704d447">snapshot</a> = <a class="el" href="classentt_1_1basic__snapshot.html">basic_snapshot</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a80012f9fa628920a3507ae947704d447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a80012f9fa628920a3507ae947704d447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e50fc296c4ea68183db332950b99f5"><td class="memItemLeft" align="right" valign="top"><a id="ae7e50fc296c4ea68183db332950b99f5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae7e50fc296c4ea68183db332950b99f5">snapshot_loader</a> = <a class="el" href="classentt_1_1basic__snapshot__loader.html">basic_snapshot_loader</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:ae7e50fc296c4ea68183db332950b99f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:ae7e50fc296c4ea68183db332950b99f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b5b489846f6f2a5d143db2b4aea5d0"><td class="memItemLeft" align="right" valign="top"><a id="a37b5b489846f6f2a5d143db2b4aea5d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a37b5b489846f6f2a5d143db2b4aea5d0">continuous_loader</a> = <a class="el" href="classentt_1_1basic__continuous__loader.html">basic_continuous_loader</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a37b5b489846f6f2a5d143db2b4aea5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a37b5b489846f6f2a5d143db2b4aea5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5a93cf82f9378248fe6385376cd943"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acc5a93cf82f9378248fe6385376cd943"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a> = <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args... &gt;</td></tr>
<tr class="memdesc:acc5a93cf82f9378248fe6385376cd943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">More...</a><br /></td></tr>
<tr class="separator:acc5a93cf82f9378248fe6385376cd943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d470a55d982d87388e899c322e9ddc"><td class="memItemLeft" align="right" valign="top"><a id="a85d470a55d982d87388e899c322e9ddc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a85d470a55d982d87388e899c322e9ddc">runtime_view</a> = <a class="el" href="classentt_1_1basic__runtime__view.html">basic_runtime_view</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> &gt;</td></tr>
<tr class="memdesc:a85d470a55d982d87388e899c322e9ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case. <br /></td></tr>
<tr class="separator:a85d470a55d982d87388e899c322e9ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2628e82fa8042f75d817c58fc09c7aaf"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2628e82fa8042f75d817c58fc09c7aaf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2628e82fa8042f75d817c58fc09c7aaf">group</a> = <a class="el" href="classentt_1_1basic__group.html">basic_group</a>&lt; <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args... &gt;</td></tr>
<tr class="memdesc:a2628e82fa8042f75d817c58fc09c7aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#a2628e82fa8042f75d817c58fc09c7aaf">More...</a><br /></td></tr>
<tr class="separator:a2628e82fa8042f75d817c58fc09c7aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692beabf853ee0f9dc68beab816a6b27"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Candidate &gt; </td></tr>
<tr class="memitem:a692beabf853ee0f9dc68beab816a6b27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a692beabf853ee0f9dc68beab816a6b27">meta_function_helper_t</a> = typename <a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a>&lt; Type, Candidate &gt;::type</td></tr>
<tr class="memdesc:a692beabf853ee0f9dc68beab816a6b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a692beabf853ee0f9dc68beab816a6b27">More...</a><br /></td></tr>
<tr class="separator:a692beabf853ee0f9dc68beab816a6b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3d1f1d0e83ad8f124155c9e511c2cd"><td class="memTemplParams" colspan="2">template&lt;typename Concept &gt; </td></tr>
<tr class="memitem:aad3d1f1d0e83ad8f124155c9e511c2cd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aad3d1f1d0e83ad8f124155c9e511c2cd">poly</a> = <a class="el" href="classentt_1_1basic__poly.html">basic_poly</a>&lt; Concept, sizeof(double[2])&gt;</td></tr>
<tr class="memdesc:aad3d1f1d0e83ad8f124155c9e511c2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias declaration for the most common use case.  <a href="namespaceentt.html#aad3d1f1d0e83ad8f124155c9e511c2cd">More...</a><br /></td></tr>
<tr class="separator:aad3d1f1d0e83ad8f124155c9e511c2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0b54e231d069e8a231e14b223388808a"><td class="memItemLeft" align="right" valign="top"><a id="a0b54e231d069e8a231e14b223388808a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a> : id_type </td></tr>
<tr class="memdesc:a0b54e231d069e8a231e14b223388808a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default entity identifier. <br /></td></tr>
<tr class="separator:a0b54e231d069e8a231e14b223388808a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad0e7f23a35b9c534a369321633876b31"><td class="memTemplParams" colspan="2">template&lt;std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:ad0e7f23a35b9c534a369321633876b31"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad0e7f23a35b9c534a369321633876b31">operator!=</a> (const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ad0e7f23a35b9c534a369321633876b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two wrappers differ in their content.  <a href="namespaceentt.html#ad0e7f23a35b9c534a369321633876b31">More...</a><br /></td></tr>
<tr class="separator:ad0e7f23a35b9c534a369321633876b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5824be13d8a7ef8976f580ab3ffeb2c"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:ab5824be13d8a7ef8976f580ab3ffeb2c"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab5824be13d8a7ef8976f580ab3ffeb2c">any_cast</a> (const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ab5824be13d8a7ef8976f580ab3ffeb2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#ab5824be13d8a7ef8976f580ab3ffeb2c">More...</a><br /></td></tr>
<tr class="separator:ab5824be13d8a7ef8976f580ab3ffeb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb671c6d5af5e797eca1fadb1980e72"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:abfb671c6d5af5e797eca1fadb1980e72"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abfb671c6d5af5e797eca1fadb1980e72">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:abfb671c6d5af5e797eca1fadb1980e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#abfb671c6d5af5e797eca1fadb1980e72">More...</a><br /></td></tr>
<tr class="separator:abfb671c6d5af5e797eca1fadb1980e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336c64e72007016b8c8dcb7ccc70468f"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:a336c64e72007016b8c8dcb7ccc70468f"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a336c64e72007016b8c8dcb7ccc70468f">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&amp;data) noexcept</td></tr>
<tr class="memdesc:a336c64e72007016b8c8dcb7ccc70468f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#a336c64e72007016b8c8dcb7ccc70468f">More...</a><br /></td></tr>
<tr class="separator:a336c64e72007016b8c8dcb7ccc70468f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5776fb961d750fcc9d9e5200527c4cf7"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:a5776fb961d750fcc9d9e5200527c4cf7"><td class="memTemplItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5776fb961d750fcc9d9e5200527c4cf7">any_cast</a> (const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *data) noexcept</td></tr>
<tr class="memdesc:a5776fb961d750fcc9d9e5200527c4cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#a5776fb961d750fcc9d9e5200527c4cf7">More...</a><br /></td></tr>
<tr class="separator:a5776fb961d750fcc9d9e5200527c4cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6c6ee982553a4522424c903df9fb78"><td class="memTemplParams" colspan="2">template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </td></tr>
<tr class="memitem:aeb6c6ee982553a4522424c903df9fb78"><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aeb6c6ee982553a4522424c903df9fb78">any_cast</a> (<a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *data) noexcept</td></tr>
<tr class="memdesc:aeb6c6ee982553a4522424c903df9fb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs type-safe access to the contained object.  <a href="namespaceentt.html#aeb6c6ee982553a4522424c903df9fb78">More...</a><br /></td></tr>
<tr class="separator:aeb6c6ee982553a4522424c903df9fb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3221623cd9ea8247dfe3512a40f7fb8a"><td class="memTemplParams" colspan="2">template&lt;typename Char , std::size_t N&gt; </td></tr>
<tr class="memitem:a3221623cd9ea8247dfe3512a40f7fb8a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3221623cd9ea8247dfe3512a40f7fb8a">basic_hashed_string</a> (const Char(&amp;str)[N]) noexcept -&gt; <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt;</td></tr>
<tr class="memdesc:a3221623cd9ea8247dfe3512a40f7fb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a3221623cd9ea8247dfe3512a40f7fb8a">More...</a><br /></td></tr>
<tr class="separator:a3221623cd9ea8247dfe3512a40f7fb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9accc71a383509ada028f7fa2b767bf"><td class="memTemplParams" colspan="2">template&lt;typename Char &gt; </td></tr>
<tr class="memitem:ad9accc71a383509ada028f7fa2b767bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad9accc71a383509ada028f7fa2b767bf">operator!=</a> (const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ad9accc71a383509ada028f7fa2b767bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two hashed strings.  <a href="namespaceentt.html#ad9accc71a383509ada028f7fa2b767bf">More...</a><br /></td></tr>
<tr class="separator:ad9accc71a383509ada028f7fa2b767bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82a1c228d600f6c48fb5ef28fde3161"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">entt::hashed_string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af82a1c228d600f6c48fb5ef28fde3161">operator&quot;&quot;_hs</a> (const char *str, std::size_t) noexcept</td></tr>
<tr class="memdesc:af82a1c228d600f6c48fb5ef28fde3161"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined literal for hashed strings.  <a href="namespaceentt.html#af82a1c228d600f6c48fb5ef28fde3161">More...</a><br /></td></tr>
<tr class="separator:af82a1c228d600f6c48fb5ef28fde3161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8643294b9892bb1342bf055a75047f06"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">entt::hashed_wstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8643294b9892bb1342bf055a75047f06">operator&quot;&quot;_hws</a> (const wchar_t *str, std::size_t) noexcept</td></tr>
<tr class="memdesc:a8643294b9892bb1342bf055a75047f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined literal for hashed wstrings.  <a href="namespaceentt.html#a8643294b9892bb1342bf055a75047f06">More...</a><br /></td></tr>
<tr class="separator:a8643294b9892bb1342bf055a75047f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7d9c84e9e3488ae011db3cfd53c280"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#acc7d9c84e9e3488ae011db3cfd53c280">operator!=</a> (const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;lhs, const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:acc7d9c84e9e3488ae011db3cfd53c280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two type info objects.  <a href="namespaceentt.html#acc7d9c84e9e3488ae011db3cfd53c280">More...</a><br /></td></tr>
<tr class="separator:acc7d9c84e9e3488ae011db3cfd53c280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03b2c2ea5e867fd6f43c0ac49149dea"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ab03b2c2ea5e867fd6f43c0ac49149dea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1type__info.html">type_info</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab03b2c2ea5e867fd6f43c0ac49149dea">type_id</a> () noexcept</td></tr>
<tr class="memdesc:ab03b2c2ea5e867fd6f43c0ac49149dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type info object for a given type.  <a href="namespaceentt.html#ab03b2c2ea5e867fd6f43c0ac49149dea">More...</a><br /></td></tr>
<tr class="separator:ab03b2c2ea5e867fd6f43c0ac49149dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6e966c8af5b1452811aa55adbbdf47"><td class="memTemplParams" colspan="2">template&lt;typename... Type, typename... Other&gt; </td></tr>
<tr class="memitem:a6c6e966c8af5b1452811aa55adbbdf47"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type..., Other... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6c6e966c8af5b1452811aa55adbbdf47">operator+</a> (<a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type... &gt;, <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Other... &gt;)</td></tr>
<tr class="memdesc:a6c6e966c8af5b1452811aa55adbbdf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple type lists.  <a href="namespaceentt.html#a6c6e966c8af5b1452811aa55adbbdf47">More...</a><br /></td></tr>
<tr class="separator:a6c6e966c8af5b1452811aa55adbbdf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc6dd5fb4d2bc92d9e5101b7b0bce1d"><td class="memTemplParams" colspan="2">template&lt;auto... Value, auto... Other&gt; </td></tr>
<tr class="memitem:aabc6dd5fb4d2bc92d9e5101b7b0bce1d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value..., Other... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aabc6dd5fb4d2bc92d9e5101b7b0bce1d">operator+</a> (<a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value... &gt;, <a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Other... &gt;)</td></tr>
<tr class="memdesc:aabc6dd5fb4d2bc92d9e5101b7b0bce1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple value lists.  <a href="namespaceentt.html#aabc6dd5fb4d2bc92d9e5101b7b0bce1d">More...</a><br /></td></tr>
<tr class="separator:aabc6dd5fb4d2bc92d9e5101b7b0bce1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5131df9ce458a6884c43595f501f916"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Class &gt; </td></tr>
<tr class="memitem:ac5131df9ce458a6884c43595f501f916"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac5131df9ce458a6884c43595f501f916">overload</a> (Type Class::*member) noexcept</td></tr>
<tr class="memdesc:ac5131df9ce458a6884c43595f501f916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant utility to disambiguate overloaded members of a class.  <a href="namespaceentt.html#ac5131df9ce458a6884c43595f501f916">More...</a><br /></td></tr>
<tr class="separator:ac5131df9ce458a6884c43595f501f916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267f6d6d3ea49bd36f7e8d2f002ec1d1"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a267f6d6d3ea49bd36f7e8d2f002ec1d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a267f6d6d3ea49bd36f7e8d2f002ec1d1">overload</a> (Func *func) noexcept</td></tr>
<tr class="memdesc:a267f6d6d3ea49bd36f7e8d2f002ec1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant utility to disambiguate overloaded functions.  <a href="namespaceentt.html#a267f6d6d3ea49bd36f7e8d2f002ec1d1">More...</a><br /></td></tr>
<tr class="separator:a267f6d6d3ea49bd36f7e8d2f002ec1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eb67ac302229374c5fb623d529f5eb"><td class="memTemplParams" colspan="2">template&lt;class... Func&gt; </td></tr>
<tr class="memitem:a26eb67ac302229374c5fb623d529f5eb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a26eb67ac302229374c5fb623d529f5eb">overloaded</a> (Func...) -&gt; <a class="el" href="structentt_1_1overloaded.html">overloaded</a>&lt; Func... &gt;</td></tr>
<tr class="memdesc:a26eb67ac302229374c5fb623d529f5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a26eb67ac302229374c5fb623d529f5eb">More...</a><br /></td></tr>
<tr class="separator:a26eb67ac302229374c5fb623d529f5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71abd3e36498ea599ce0abc367d7c3ae"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a71abd3e36498ea599ce0abc367d7c3ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a71abd3e36498ea599ce0abc367d7c3ae">to_integral</a> (const Entity <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>) noexcept</td></tr>
<tr class="memdesc:a71abd3e36498ea599ce0abc367d7c3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an entity type to its underlying type.  <a href="namespaceentt.html#a71abd3e36498ea599ce0abc367d7c3ae">More...</a><br /></td></tr>
<tr class="separator:a71abd3e36498ea599ce0abc367d7c3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad801f15accdf588b163ce48ce9209bf6"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:ad801f15accdf588b163ce48ce9209bf6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad801f15accdf588b163ce48ce9209bf6">operator==</a> (const Entity &amp;<a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, const <a class="el" href="structentt_1_1null__t.html">null_t</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:ad801f15accdf588b163ce48ce9209bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a null object and an entity identifier of any type.  <a href="namespaceentt.html#ad801f15accdf588b163ce48ce9209bf6">More...</a><br /></td></tr>
<tr class="separator:ad801f15accdf588b163ce48ce9209bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5bf9ffc5b47e91752c4362ffb261e2"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a2c5bf9ffc5b47e91752c4362ffb261e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2c5bf9ffc5b47e91752c4362ffb261e2">operator!=</a> (const Entity &amp;<a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, const <a class="el" href="structentt_1_1null__t.html">null_t</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a2c5bf9ffc5b47e91752c4362ffb261e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a null object and an entity identifier of any type.  <a href="namespaceentt.html#a2c5bf9ffc5b47e91752c4362ffb261e2">More...</a><br /></td></tr>
<tr class="separator:a2c5bf9ffc5b47e91752c4362ffb261e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fe21a1261b7ee705090e976b88d9b7"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Other &gt; </td></tr>
<tr class="memitem:a31fe21a1261b7ee705090e976b88d9b7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a31fe21a1261b7ee705090e976b88d9b7">operator!=</a> (const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Type &gt; &amp;lhs, const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Other &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a31fe21a1261b7ee705090e976b88d9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles.  <a href="namespaceentt.html#a31fe21a1261b7ee705090e976b88d9b7">More...</a><br /></td></tr>
<tr class="separator:a31fe21a1261b7ee705090e976b88d9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288ec07d4e87a28179d43b367ff11eab"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a288ec07d4e87a28179d43b367ff11eab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a288ec07d4e87a28179d43b367ff11eab">basic_handle</a> (<a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;, Entity) -&gt; <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Entity &gt;</td></tr>
<tr class="memdesc:a288ec07d4e87a28179d43b367ff11eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a288ec07d4e87a28179d43b367ff11eab">More...</a><br /></td></tr>
<tr class="separator:a288ec07d4e87a28179d43b367ff11eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de052205bafd99d67afde880b67a4e8"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a6de052205bafd99d67afde880b67a4e8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6de052205bafd99d67afde880b67a4e8">basic_handle</a> (const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;, Entity) -&gt; <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; const Entity &gt;</td></tr>
<tr class="memdesc:a6de052205bafd99d67afde880b67a4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a6de052205bafd99d67afde880b67a4e8">More...</a><br /></td></tr>
<tr class="separator:a6de052205bafd99d67afde880b67a4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c6e95072e8388155761aa1a24d1bc4"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a02c6e95072e8388155761aa1a24d1bc4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a02c6e95072e8388155761aa1a24d1bc4">as_view</a> (<a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) noexcept -&gt; <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; Entity &gt;</td></tr>
<tr class="memdesc:a02c6e95072e8388155761aa1a24d1bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a02c6e95072e8388155761aa1a24d1bc4">More...</a><br /></td></tr>
<tr class="separator:a02c6e95072e8388155761aa1a24d1bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf7822d817098d1d9e70a6f62dfad45"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a5cf7822d817098d1d9e70a6f62dfad45"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5cf7822d817098d1d9e70a6f62dfad45">as_view</a> (const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) noexcept -&gt; <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; const Entity &gt;</td></tr>
<tr class="memdesc:a5cf7822d817098d1d9e70a6f62dfad45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a5cf7822d817098d1d9e70a6f62dfad45">More...</a><br /></td></tr>
<tr class="separator:a5cf7822d817098d1d9e70a6f62dfad45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67521c81f5cd3582c6e8d00c03c909cd"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:a67521c81f5cd3582c6e8d00c03c909cd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a67521c81f5cd3582c6e8d00c03c909cd">as_group</a> (<a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) noexcept -&gt; <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; Entity &gt;</td></tr>
<tr class="memdesc:a67521c81f5cd3582c6e8d00c03c909cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a67521c81f5cd3582c6e8d00c03c909cd">More...</a><br /></td></tr>
<tr class="separator:a67521c81f5cd3582c6e8d00c03c909cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03bdf3829b777be58dea73dace36bae"><td class="memTemplParams" colspan="2">template&lt;typename Entity &gt; </td></tr>
<tr class="memitem:ac03bdf3829b777be58dea73dace36bae"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac03bdf3829b777be58dea73dace36bae">as_group</a> (const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;) noexcept -&gt; <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; const Entity &gt;</td></tr>
<tr class="memdesc:ac03bdf3829b777be58dea73dace36bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#ac03bdf3829b777be58dea73dace36bae">More...</a><br /></td></tr>
<tr class="separator:ac03bdf3829b777be58dea73dace36bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa512a354fe328df6be5a92eb43cd4d69"><td class="memTemplParams" colspan="2">template&lt;auto Member, typename Entity  = entity&gt; </td></tr>
<tr class="memitem:aa512a354fe328df6be5a92eb43cd4d69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aa512a354fe328df6be5a92eb43cd4d69">invoke</a> (<a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;reg, const Entity entt)</td></tr>
<tr class="memdesc:aa512a354fe328df6be5a92eb43cd4d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to create a listener that directly invokes a member function.  <a href="namespaceentt.html#aa512a354fe328df6be5a92eb43cd4d69">More...</a><br /></td></tr>
<tr class="separator:aa512a354fe328df6be5a92eb43cd4d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb31e9165a07456c03f8c64295117824"><td class="memTemplParams" colspan="2">template&lt;typename Entity , typename Component &gt; </td></tr>
<tr class="memitem:adb31e9165a07456c03f8c64295117824"><td class="memTemplItemLeft" align="right" valign="top">Entity&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#adb31e9165a07456c03f8c64295117824">to_entity</a> (const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;reg, const Component &amp;component)</td></tr>
<tr class="memdesc:adb31e9165a07456c03f8c64295117824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity associated with a given component.  <a href="namespaceentt.html#adb31e9165a07456c03f8c64295117824">More...</a><br /></td></tr>
<tr class="separator:adb31e9165a07456c03f8c64295117824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4a534b0b8ca5f5ffb5cea2c3523413"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ade4a534b0b8ca5f5ffb5cea2c3523413"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ade4a534b0b8ca5f5ffb5cea2c3523413">get_as_tuple</a> ([[maybe_unused]] Type &amp;container, [[maybe_unused]] const typename Type::entity_type <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>)</td></tr>
<tr class="memdesc:ade4a534b0b8ca5f5ffb5cea2c3523413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element assigned to an entity from a storage, if any.  <a href="namespaceentt.html#ade4a534b0b8ca5f5ffb5cea2c3523413">More...</a><br /></td></tr>
<tr class="separator:ade4a534b0b8ca5f5ffb5cea2c3523413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83181819c86fd37176b9894d833a572f"><td class="memTemplParams" colspan="2">template&lt;typename... Storage&gt; </td></tr>
<tr class="memitem:a83181819c86fd37176b9894d833a572f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a83181819c86fd37176b9894d833a572f">basic_view</a> (<a class="el" href="structentt_1_1Storage.html">Storage</a> &amp;... <a class="el" href="namespaceentt.html#abcedb8f29753130e2bf3185bca211f05">storage</a>) noexcept -&gt; <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; std::common_type_t&lt; typename Storage::entity_type... &gt;, <a class="el" href="structentt_1_1exclude__t.html">entt::exclude_t</a>&lt;&gt;, <a class="el" href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">constness_as_t</a>&lt; typename Storage::value_type, <a class="el" href="structentt_1_1Storage.html">Storage</a> &gt;... &gt;</td></tr>
<tr class="memdesc:a83181819c86fd37176b9894d833a572f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a83181819c86fd37176b9894d833a572f">More...</a><br /></td></tr>
<tr class="separator:a83181819c86fd37176b9894d833a572f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0174aa3efe81fb881deb652d4b6d233"><td class="memTemplParams" colspan="2">template&lt;typename Entity , typename... ELhs, typename... CLhs, typename... ERhs, typename... CRhs&gt; </td></tr>
<tr class="memitem:af0174aa3efe81fb881deb652d4b6d233"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af0174aa3efe81fb881deb652d4b6d233">operator|</a> (const <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; Entity, <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; ELhs... &gt;, CLhs... &gt; &amp;lhs, const <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; Entity, <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; ERhs... &gt;, CRhs... &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af0174aa3efe81fb881deb652d4b6d233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two views in a <em>more specific</em> one.  <a href="namespaceentt.html#af0174aa3efe81fb881deb652d4b6d233">More...</a><br /></td></tr>
<tr class="separator:af0174aa3efe81fb881deb652d4b6d233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab7b51802157a98106f238335fa7503"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a2ab7b51802157a98106f238335fa7503"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2ab7b51802157a98106f238335fa7503">dereference_meta_pointer_like</a> (const Type &amp;value)</td></tr>
<tr class="memdesc:a2ab7b51802157a98106f238335fa7503"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL based lookup function for dereferencing meta pointer-like types.  <a href="namespaceentt.html#a2ab7b51802157a98106f238335fa7503">More...</a><br /></td></tr>
<tr class="separator:a2ab7b51802157a98106f238335fa7503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78885d25ace657bedd664e3044152f03"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a78885d25ace657bedd664e3044152f03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a78885d25ace657bedd664e3044152f03">meta</a> () noexcept</td></tr>
<tr class="memdesc:a78885d25ace657bedd664e3044152f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to use for reflection.  <a href="namespaceentt.html#a78885d25ace657bedd664e3044152f03">More...</a><br /></td></tr>
<tr class="separator:a78885d25ace657bedd664e3044152f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf49974479c8ec5344afe078a997a8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a6bf49974479c8ec5344afe078a997a8d">operator!=</a> (const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;lhs, const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a6bf49974479c8ec5344afe078a997a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two wrappers differ in their content.  <a href="namespaceentt.html#a6bf49974479c8ec5344afe078a997a8d">More...</a><br /></td></tr>
<tr class="separator:a6bf49974479c8ec5344afe078a997a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b862c2db6e5771fb95d7a7930e9b18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a85b862c2db6e5771fb95d7a7930e9b18">operator!=</a> (const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;lhs, const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a85b862c2db6e5771fb95d7a7930e9b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two objects refer to the same type.  <a href="namespaceentt.html#a85b862c2db6e5771fb95d7a7930e9b18">More...</a><br /></td></tr>
<tr class="separator:a85b862c2db6e5771fb95d7a7930e9b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af786b2fb9c4667924bbed3b0bcb83cac"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:af786b2fb9c4667924bbed3b0bcb83cac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af786b2fb9c4667924bbed3b0bcb83cac">resolve</a> () noexcept</td></tr>
<tr class="memdesc:af786b2fb9c4667924bbed3b0bcb83cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type.  <a href="namespaceentt.html#af786b2fb9c4667924bbed3b0bcb83cac">More...</a><br /></td></tr>
<tr class="separator:af786b2fb9c4667924bbed3b0bcb83cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4493a8ed8dc4bc71b11058973c0fd9aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4493a8ed8dc4bc71b11058973c0fd9aa">resolve</a> (const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a> id) noexcept</td></tr>
<tr class="memdesc:a4493a8ed8dc4bc71b11058973c0fd9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given identifier, if any.  <a href="namespaceentt.html#a4493a8ed8dc4bc71b11058973c0fd9aa">More...</a><br /></td></tr>
<tr class="separator:a4493a8ed8dc4bc71b11058973c0fd9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629a71c04515885738cbb406fb81e08d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__type.html">meta_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a629a71c04515885738cbb406fb81e08d">resolve</a> (const <a class="el" href="classentt_1_1type__info.html">type_info</a> info) noexcept</td></tr>
<tr class="memdesc:a629a71c04515885738cbb406fb81e08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meta type associated with a given type info object, if any.  <a href="namespaceentt.html#a629a71c04515885738cbb406fb81e08d">More...</a><br /></td></tr>
<tr class="separator:a629a71c04515885738cbb406fb81e08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0861c2878957a89499b0ca0801f7eeff"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Args, std::size_t... Index&gt; </td></tr>
<tr class="memitem:a0861c2878957a89499b0ca0801f7eeff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a0861c2878957a89499b0ca0801f7eeff">meta_construct</a> (<a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const args, std::index_sequence&lt; Index... &gt;)</td></tr>
<tr class="memdesc:a0861c2878957a89499b0ca0801f7eeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance given a list of erased parameters, if possible.  <a href="namespaceentt.html#a0861c2878957a89499b0ca0801f7eeff">More...</a><br /></td></tr>
<tr class="separator:a0861c2878957a89499b0ca0801f7eeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe109e5134bae55cb519799acbed732"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Data&gt; </td></tr>
<tr class="memitem:adbe109e5134bae55cb519799acbed732"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#adbe109e5134bae55cb519799acbed732">meta_setter</a> ([[maybe_unused]] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, [[maybe_unused]] <a class="el" href="classentt_1_1meta__any.html">meta_any</a> value)</td></tr>
<tr class="memdesc:adbe109e5134bae55cb519799acbed732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of a given variable.  <a href="namespaceentt.html#adbe109e5134bae55cb519799acbed732">More...</a><br /></td></tr>
<tr class="separator:adbe109e5134bae55cb519799acbed732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe26d091f302630470004fe314a6a8d"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Data, typename Policy  = as_is_t&gt; </td></tr>
<tr class="memitem:a3fe26d091f302630470004fe314a6a8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a3fe26d091f302630470004fe314a6a8d">meta_getter</a> ([[maybe_unused]] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance)</td></tr>
<tr class="memdesc:a3fe26d091f302630470004fe314a6a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a given variable.  <a href="namespaceentt.html#a3fe26d091f302630470004fe314a6a8d">More...</a><br /></td></tr>
<tr class="separator:a3fe26d091f302630470004fe314a6a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ab280279554979b88da3c693e8a5ec"><td class="memTemplParams" colspan="2">template&lt;typename Type , auto Candidate, typename Policy  = as_is_t, std::size_t... Index&gt; </td></tr>
<tr class="memitem:ab4ab280279554979b88da3c693e8a5ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab4ab280279554979b88da3c693e8a5ec">meta_invoke</a> ([[maybe_unused]] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a> instance, <a class="el" href="classentt_1_1meta__any.html">meta_any</a> *args, std::index_sequence&lt; Index... &gt;)</td></tr>
<tr class="memdesc:ab4ab280279554979b88da3c693e8a5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a function given a list of erased parameters, if possible.  <a href="namespaceentt.html#ab4ab280279554979b88da3c693e8a5ec">More...</a><br /></td></tr>
<tr class="separator:ab4ab280279554979b88da3c693e8a5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaec3476b637deea0ca553427175664f"><td class="memTemplParams" colspan="2">template&lt;auto Member, typename Poly , typename... Args&gt; </td></tr>
<tr class="memitem:abaec3476b637deea0ca553427175664f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#abaec3476b637deea0ca553427175664f">poly_call</a> (Poly &amp;&amp;self, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abaec3476b637deea0ca553427175664f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for calling <code><a class="el" href="structentt_1_1poly__base.html" title="Poly base class used to inject functionalities into concepts.">poly_base</a>&lt;Type&gt;<a class="el" href="namespaceentt.html#aa512a354fe328df6be5a92eb43cd4d69" title="Helper to create a listener that directly invokes a member function.">invoke</a></code>.  <a href="namespaceentt.html#abaec3476b637deea0ca553427175664f">More...</a><br /></td></tr>
<tr class="separator:abaec3476b637deea0ca553427175664f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae663976796b773780f6136606c1a3f31"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename... Args&gt; </td></tr>
<tr class="memitem:ae663976796b773780f6136606c1a3f31"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ae663976796b773780f6136606c1a3f31">operator!=</a> (const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;lhs, const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae663976796b773780f6136606c1a3f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two delegates.  <a href="namespaceentt.html#ae663976796b773780f6136606c1a3f31">More...</a><br /></td></tr>
<tr class="separator:ae663976796b773780f6136606c1a3f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865c97b32a0858165d34ed9820cbdef1"><td class="memTemplParams" colspan="2">template&lt;auto Candidate&gt; </td></tr>
<tr class="memitem:a865c97b32a0858165d34ed9820cbdef1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a865c97b32a0858165d34ed9820cbdef1">delegate</a> (<a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;) noexcept -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate)&gt;&gt;&gt;</td></tr>
<tr class="memdesc:a865c97b32a0858165d34ed9820cbdef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a865c97b32a0858165d34ed9820cbdef1">More...</a><br /></td></tr>
<tr class="separator:a865c97b32a0858165d34ed9820cbdef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4796d34a9000c5c471b95a9eee4da1"><td class="memTemplParams" colspan="2">template&lt;auto Candidate, typename Type &gt; </td></tr>
<tr class="memitem:a5f4796d34a9000c5c471b95a9eee4da1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5f4796d34a9000c5c471b95a9eee4da1">delegate</a> (<a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;, Type &amp;&amp;) noexcept -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate), Type &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a5f4796d34a9000c5c471b95a9eee4da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a5f4796d34a9000c5c471b95a9eee4da1">More...</a><br /></td></tr>
<tr class="separator:a5f4796d34a9000c5c471b95a9eee4da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad125386ca0a0050b8a24ce3d8fc3db30"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename... Args&gt; </td></tr>
<tr class="memitem:ad125386ca0a0050b8a24ce3d8fc3db30"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad125386ca0a0050b8a24ce3d8fc3db30">delegate</a> (Ret(*)(const void *, Args...), const void *=nullptr) noexcept -&gt; <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt;</td></tr>
<tr class="memdesc:ad125386ca0a0050b8a24ce3d8fc3db30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#ad125386ca0a0050b8a24ce3d8fc3db30">More...</a><br /></td></tr>
<tr class="separator:ad125386ca0a0050b8a24ce3d8fc3db30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1367d938e16a6c5b6aaedab5cf10f295"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename... Args&gt; </td></tr>
<tr class="memitem:a1367d938e16a6c5b6aaedab5cf10f295"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a1367d938e16a6c5b6aaedab5cf10f295">sink</a> (<a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...)&gt; &amp;) noexcept -&gt; <a class="el" href="classentt_1_1sink.html">sink</a>&lt; Ret(Args...)&gt;</td></tr>
<tr class="memdesc:a1367d938e16a6c5b6aaedab5cf10f295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="namespaceentt.html#a1367d938e16a6c5b6aaedab5cf10f295">More...</a><br /></td></tr>
<tr class="separator:a1367d938e16a6c5b6aaedab5cf10f295"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memTemplParams" colspan="2">template&lt;id_type Value&gt; </td></tr>
<tr class="memitem:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structentt_1_1monostate.html">monostate</a>&lt; Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ab43a13f7ee60bcb0d04a001f92b86fa2">monostate_v</a> = {}</td></tr>
<tr class="memdesc:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ab43a13f7ee60bcb0d04a001f92b86fa2">More...</a><br /></td></tr>
<tr class="separator:ab43a13f7ee60bcb0d04a001f92b86fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089f75043b082abca3ea144bce44e9ae"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a089f75043b082abca3ea144bce44e9ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1choice__t.html">choice_t</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a089f75043b082abca3ea144bce44e9ae">choice</a> {}</td></tr>
<tr class="memdesc:a089f75043b082abca3ea144bce44e9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for the choice trick.  <a href="namespaceentt.html#a089f75043b082abca3ea144bce44e9ae">More...</a><br /></td></tr>
<tr class="separator:a089f75043b082abca3ea144bce44e9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aec80af8bb10dcc2e289c91903433b"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:aa4aec80af8bb10dcc2e289c91903433b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aa4aec80af8bb10dcc2e289c91903433b">size_of_v</a> = <a class="el" href="structentt_1_1size__of.html">size_of</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:aa4aec80af8bb10dcc2e289c91903433b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#aa4aec80af8bb10dcc2e289c91903433b">More...</a><br /></td></tr>
<tr class="separator:aa4aec80af8bb10dcc2e289c91903433b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447c782d9f4f5332dfd4dde6f03d4a4e"><td class="memTemplParams" colspan="2">template&lt;auto Value, typename &gt; </td></tr>
<tr class="memitem:a447c782d9f4f5332dfd4dde6f03d4a4e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a447c782d9f4f5332dfd4dde6f03d4a4e">unpack_as_v</a> = Value</td></tr>
<tr class="memdesc:a447c782d9f4f5332dfd4dde6f03d4a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template to be used to <em>repeat</em> the same value a number of times equal to the size of a given parameter pack.  <a href="namespaceentt.html#a447c782d9f4f5332dfd4dde6f03d4a4e">More...</a><br /></td></tr>
<tr class="separator:a447c782d9f4f5332dfd4dde6f03d4a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56a88b7c6d0f691dd1e3d844bb41980"><td class="memTemplParams" colspan="2">template&lt;class List , typename Type &gt; </td></tr>
<tr class="memitem:ac56a88b7c6d0f691dd1e3d844bb41980"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ac56a88b7c6d0f691dd1e3d844bb41980">type_list_contains_v</a> = <a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a>&lt;List, Type&gt;::value</td></tr>
<tr class="memdesc:ac56a88b7c6d0f691dd1e3d844bb41980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ac56a88b7c6d0f691dd1e3d844bb41980">More...</a><br /></td></tr>
<tr class="separator:ac56a88b7c6d0f691dd1e3d844bb41980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbfb162708696f9c1497d61573b540f"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename List &gt; </td></tr>
<tr class="memitem:a4bbfb162708696f9c1497d61573b540f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a4bbfb162708696f9c1497d61573b540f">value_list_element_v</a> = <a class="el" href="structentt_1_1value__list__element.html">value_list_element</a>&lt;Index, List&gt;::value</td></tr>
<tr class="memdesc:a4bbfb162708696f9c1497d61573b540f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type.  <a href="namespaceentt.html#a4bbfb162708696f9c1497d61573b540f">More...</a><br /></td></tr>
<tr class="separator:a4bbfb162708696f9c1497d61573b540f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2c2c940fcfd655abaa24489471dad8"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:aff2c2c940fcfd655abaa24489471dad8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aff2c2c940fcfd655abaa24489471dad8">is_equality_comparable_v</a> = <a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:aff2c2c940fcfd655abaa24489471dad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#aff2c2c940fcfd655abaa24489471dad8">More...</a><br /></td></tr>
<tr class="separator:aff2c2c940fcfd655abaa24489471dad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4012f88fe8b134ce1e37491bce21dd3"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename Args &gt; </td></tr>
<tr class="memitem:af4012f88fe8b134ce1e37491bce21dd3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af4012f88fe8b134ce1e37491bce21dd3">is_applicable_v</a> = <a class="el" href="structentt_1_1is__applicable.html">is_applicable</a>&lt;Func, Args&gt;::value</td></tr>
<tr class="memdesc:af4012f88fe8b134ce1e37491bce21dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#af4012f88fe8b134ce1e37491bce21dd3">More...</a><br /></td></tr>
<tr class="separator:af4012f88fe8b134ce1e37491bce21dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affced7f7dba6f59b6b1adbf39d1087ca"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Func , typename Args &gt; </td></tr>
<tr class="memitem:affced7f7dba6f59b6b1adbf39d1087ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#affced7f7dba6f59b6b1adbf39d1087ca">is_applicable_r_v</a> = <a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a>&lt;Ret, Func, Args&gt;::value</td></tr>
<tr class="memdesc:affced7f7dba6f59b6b1adbf39d1087ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#affced7f7dba6f59b6b1adbf39d1087ca">More...</a><br /></td></tr>
<tr class="separator:affced7f7dba6f59b6b1adbf39d1087ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ca667fdc396b9d92418f588a539dec"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a27ca667fdc396b9d92418f588a539dec"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a27ca667fdc396b9d92418f588a539dec">is_complete_v</a> = <a class="el" href="structentt_1_1is__complete.html">is_complete</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a27ca667fdc396b9d92418f588a539dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a27ca667fdc396b9d92418f588a539dec">More...</a><br /></td></tr>
<tr class="separator:a27ca667fdc396b9d92418f588a539dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302633f8a2e49f936505c0612fc8b9bb"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a302633f8a2e49f936505c0612fc8b9bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a302633f8a2e49f936505c0612fc8b9bb">is_std_hashable_v</a> = <a class="el" href="structentt_1_1is__std__hashable.html">is_std_hashable</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a302633f8a2e49f936505c0612fc8b9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a302633f8a2e49f936505c0612fc8b9bb">More...</a><br /></td></tr>
<tr class="separator:a302633f8a2e49f936505c0612fc8b9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8055bbf0ea80cb29a994e753ff12e1b0"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a8055bbf0ea80cb29a994e753ff12e1b0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8055bbf0ea80cb29a994e753ff12e1b0">is_empty_v</a> = <a class="el" href="structentt_1_1is__empty.html">is_empty</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:a8055bbf0ea80cb29a994e753ff12e1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#a8055bbf0ea80cb29a994e753ff12e1b0">More...</a><br /></td></tr>
<tr class="separator:a8055bbf0ea80cb29a994e753ff12e1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0c0a1c1d953ea991591748744cdd8b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1null__t.html">null_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a2f0c0a1c1d953ea991591748744cdd8b">null</a> {}</td></tr>
<tr class="memdesc:a2f0c0a1c1d953ea991591748744cdd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time constant for null entities.  <a href="namespaceentt.html#a2f0c0a1c1d953ea991591748744cdd8b">More...</a><br /></td></tr>
<tr class="separator:a2f0c0a1c1d953ea991591748744cdd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8b073b774362fe800d9cce3542927a"><td class="memItemLeft" align="right" valign="top"><a id="aea8b073b774362fe800d9cce3542927a"></a>
constexpr <a class="el" href="structentt_1_1basic__collector.html">basic_collector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aea8b073b774362fe800d9cce3542927a">collector</a> {}</td></tr>
<tr class="memdesc:aea8b073b774362fe800d9cce3542927a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template used to ease the definition of collectors. <br /></td></tr>
<tr class="separator:aea8b073b774362fe800d9cce3542927a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a5b73210cef43c4db35ef8ce477cc38a6">exclude</a> {}</td></tr>
<tr class="memdesc:a5b73210cef43c4db35ef8ce477cc38a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for exclusion lists.  <a href="namespaceentt.html#a5b73210cef43c4db35ef8ce477cc38a6">More...</a><br /></td></tr>
<tr class="separator:a5b73210cef43c4db35ef8ce477cc38a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memTemplParams" colspan="2">template&lt;typename... Type&gt; </td></tr>
<tr class="memitem:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt; Type... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#a8c24ecc5ab0055f9f2a4725c95afb29e">get</a> {}</td></tr>
<tr class="memdesc:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for lists of observed components.  <a href="namespaceentt.html#a8c24ecc5ab0055f9f2a4725c95afb29e">More...</a><br /></td></tr>
<tr class="separator:a8c24ecc5ab0055f9f2a4725c95afb29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49b2ea24586994d23d6d837a550867a"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ad49b2ea24586994d23d6d837a550867a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#ad49b2ea24586994d23d6d837a550867a">is_key_only_meta_associative_container_v</a> = <a class="el" href="structentt_1_1is__key__only__meta__associative__container.html">is_key_only_meta_associative_container</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:ad49b2ea24586994d23d6d837a550867a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#ad49b2ea24586994d23d6d837a550867a">More...</a><br /></td></tr>
<tr class="separator:ad49b2ea24586994d23d6d837a550867a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8c390cfe71301a0c10f4844e98424c"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:aaa8c390cfe71301a0c10f4844e98424c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#aaa8c390cfe71301a0c10f4844e98424c">is_meta_pointer_like_v</a> = <a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a>&lt;Type&gt;::value</td></tr>
<tr class="memdesc:aaa8c390cfe71301a0c10f4844e98424c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template.  <a href="namespaceentt.html#aaa8c390cfe71301a0c10f4844e98424c">More...</a><br /></td></tr>
<tr class="separator:aaa8c390cfe71301a0c10f4844e98424c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e73acd6f3d892955819677dc2664b7"><td class="memTemplParams" colspan="2"><a id="af1e73acd6f3d892955819677dc2664b7"></a>
template&lt;auto Func&gt; </td></tr>
<tr class="memitem:af1e73acd6f3d892955819677dc2664b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Func &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceentt.html#af1e73acd6f3d892955819677dc2664b7">connect_arg</a> {}</td></tr>
<tr class="memdesc:af1e73acd6f3d892955819677dc2664b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant of type <a class="el" href="structentt_1_1connect__arg__t.html" title="Used to wrap a function or a member of a specified type.">connect_arg_t</a> used to disambiguate calls. <br /></td></tr>
<tr class="separator:af1e73acd6f3d892955819677dc2664b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><code>EnTT</code> default namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aedfeed27a790ac90eb5989da8a3ea860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfeed27a790ac90eb5989da8a3ea860">&#9670;&nbsp;</a></span>const_handle_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#aedfeed27a790ac90eb5989da8a3ea860">entt::const_handle_view</a> = typedef <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt;const <a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00108">108</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a7b051461867d3c5c97f77f10b662c26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b051461867d3c5c97f77f10b662c26b">&#9670;&nbsp;</a></span>constness_as_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">entt::constness_as_t</a> = typedef typename <a class="el" href="structentt_1_1constness__as.html">constness_as</a>&lt;To, From&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template to facilitate the transcription of the constness. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The type to which to transcribe the constness. </td></tr>
    <tr><td class="paramname">From</td><td>The type from which to transcribe the constness. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00632">632</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a2628e82fa8042f75d817c58fc09c7aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2628e82fa8042f75d817c58fc09c7aaf">&#9670;&nbsp;</a></span>group</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a2628e82fa8042f75d817c58fc09c7aaf">entt::group</a> = typedef <a class="el" href="classentt_1_1basic__group.html">basic_group</a>&lt;<a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00140">140</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="aaa5809ceb50ec17713e8690c20a79490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5809ceb50ec17713e8690c20a79490">&#9670;&nbsp;</a></span>handle_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#aaa5809ceb50ec17713e8690c20a79490">entt::handle_view</a> = typedef <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt;<a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00100">100</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a0d9fd5898acf13553bbcf14b99159f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9fd5898acf13553bbcf14b99159f4d">&#9670;&nbsp;</a></span>integral_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">entt::integral_constant</a> = typedef std::integral_constant&lt;decltype(Value), Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a static constant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A static constant. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00111">111</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a49f19d031690e5ebfffd6c7a4f6bd364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f19d031690e5ebfffd6c7a4f6bd364">&#9670;&nbsp;</a></span>member_class_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Member &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a49f19d031690e5ebfffd6c7a4f6bd364">entt::member_class_t</a> = typedef typename <a class="el" href="classentt_1_1member__class.html">member_class</a>&lt;Member&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>A pointer to a non-static member object or function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00663">663</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a692beabf853ee0f9dc68beab816a6b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692beabf853ee0f9dc68beab816a6b27">&#9670;&nbsp;</a></span>meta_function_helper_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Candidate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a692beabf853ee0f9dc68beab816a6b27">entt::meta_function_helper_t</a> = typedef typename <a class="el" href="classentt_1_1meta__function__helper.html">meta_function_helper</a>&lt;Type, Candidate&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the meta function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to associate with the reflected type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00119">119</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="aad3d1f1d0e83ad8f124155c9e511c2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3d1f1d0e83ad8f124155c9e511c2cd">&#9670;&nbsp;</a></span>poly</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Concept &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#aad3d1f1d0e83ad8f124155c9e511c2cd">entt::poly</a> = typedef <a class="el" href="classentt_1_1basic__poly.html">basic_poly</a>&lt;Concept, sizeof(double[2])&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Concept</td><td>Concept descriptor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="poly_2fwd_8hpp_source.html#l00020">20</a> of file <a class="el" href="poly_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="abcedb8f29753130e2bf3185bca211f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcedb8f29753130e2bf3185bca211f05">&#9670;&nbsp;</a></span>storage</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#abcedb8f29753130e2bf3185bca211f05">entt::storage</a> = typedef <a class="el" href="classentt_1_1basic__storage.html">basic_storage</a>&lt;<a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00072">72</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<a id="a9f7bb8c357f08a01ad9c8dab0ea40c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7bb8c357f08a01ad9c8dab0ea40c1c">&#9670;&nbsp;</a></span>tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;id_type Value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a9f7bb8c357f08a01ad9c8dab0ea40c1c">entt::tag</a> = typedef <a class="el" href="namespaceentt.html#a0d9fd5898acf13553bbcf14b99159f4d">integral_constant</a>&lt;Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template to facilitate the creation of named values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A constant value at least convertible to <code>id_type</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00119">119</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a09f6bd6b4aebc03df720e7e69fdc6643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f6bd6b4aebc03df720e7e69fdc6643">&#9670;&nbsp;</a></span>type_identity_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a09f6bd6b4aebc03df720e7e69fdc6643">entt::type_identity_t</a> = typedef typename <a class="el" href="structentt_1_1type__identity.html">type_identity</a>&lt;Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00061">61</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a546467a3662e9a915d5d519ad565e801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546467a3662e9a915d5d519ad565e801">&#9670;&nbsp;</a></span>type_list_cat_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a546467a3662e9a915d5d519ad565e801">entt::type_list_cat_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__cat.html">type_list_cat</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type lists to concatenate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00225">225</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="af2992fc009cb3199b0ef9a86bed2285c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2992fc009cb3199b0ef9a86bed2285c">&#9670;&nbsp;</a></span>type_list_diff_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#af2992fc009cb3199b0ef9a86bed2285c">entt::type_list_diff_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__diff.html">type_list_diff</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type lists between which to compute the difference. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00315">315</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ac839c1a03dba2436791d0056d6d0d1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac839c1a03dba2436791d0056d6d0d1b6">&#9670;&nbsp;</a></span>type_list_element_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename List &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#ac839c1a03dba2436791d0056d6d0d1b6">entt::type_list_element_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__element.html">type_list_element</a>&lt;Index, List&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index of the type to return. </td></tr>
    <tr><td class="paramname">List</td><td>Type list to search into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00170">170</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a75a277a6037279d65cd3874b46ec7166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a277a6037279d65cd3874b46ec7166">&#9670;&nbsp;</a></span>type_list_unique_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a75a277a6037279d65cd3874b46ec7166">entt::type_list_unique_t</a> = typedef typename <a class="el" href="structentt_1_1type__list__unique.html">type_list_unique</a>&lt;Type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00262">262</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a61a837a49598350009f463e37c86d322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a837a49598350009f463e37c86d322">&#9670;&nbsp;</a></span>unpack_as_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a61a837a49598350009f463e37c86d322">entt::unpack_as_t</a> = typedef Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using declaration to be used to <em>repeat</em> the same type a number of times equal to the size of a given parameter pack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A type to repeat. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00094">94</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a1344cc62598091397018354e6905e431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1344cc62598091397018354e6905e431">&#9670;&nbsp;</a></span>value_list_cat_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... List&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#a1344cc62598091397018354e6905e431">entt::value_list_cat_t</a> = typedef typename <a class="el" href="structentt_1_1value__list__cat.html">value_list_cat</a>&lt;List...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Value lists to concatenate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00421">421</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="acc5a93cf82f9378248fe6385376cd943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5a93cf82f9378248fe6385376cd943">&#9670;&nbsp;</a></span>view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">entt::view</a> = typedef <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt;<a class="el" href="namespaceentt.html#a0b54e231d069e8a231e14b223388808a">entity</a>, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias declaration for the most common use case. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Other template parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2fwd_8hpp_source.html#l00128">128</a> of file <a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a336c64e72007016b8c8dcb7ccc70468f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336c64e72007016b8c8dcb7ccc70468f">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00381">381</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="abfb671c6d5af5e797eca1fadb1980e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb671c6d5af5e797eca1fadb1980e72">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00371">371</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="aeb6c6ee982553a4522424c903df9fb78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6c6ee982553a4522424c903df9fb78">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* entt::any_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00398">398</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="ab5824be13d8a7ef8976f580ab3ffeb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5824be13d8a7ef8976f580ab3ffeb2c">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type entt::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00362">362</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a5776fb961d750fcc9d9e5200527c4cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5776fb961d750fcc9d9e5200527c4cf7">&#9670;&nbsp;</a></span>any_cast() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type* entt::any_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs type-safe access to the contained object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to which conversion is required. </td></tr>
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Target any object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element converted to the requested type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00391">391</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a67521c81f5cd3582c6e8d00c03c909cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67521c81f5cd3582c6e8d00c03c909cd">&#9670;&nbsp;</a></span>as_group() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__group.html">entt::as_group</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; Entity &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the constness of a registry directly from the instance provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac03bdf3829b777be58dea73dace36bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03bdf3829b777be58dea73dace36bae">&#9670;&nbsp;</a></span>as_group() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__group.html">entt::as_group</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__group.html">as_group</a>&lt; const Entity &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the constness of a registry directly from the instance provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c6e95072e8388155761aa1a24d1bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c6e95072e8388155761aa1a24d1bc4">&#9670;&nbsp;</a></span>as_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__view.html">entt::as_view</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; Entity &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the constness of a registry directly from the instance provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cf7822d817098d1d9e70a6f62dfad45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf7822d817098d1d9e70a6f62dfad45">&#9670;&nbsp;</a></span>as_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1as__view.html">entt::as_view</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1as__view.html">as_view</a>&lt; const Entity &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the constness of a registry directly from the instance provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a288ec07d4e87a28179d43b367ff11eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288ec07d4e87a28179d43b367ff11eab">&#9670;&nbsp;</a></span>basic_handle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1basic__handle.html">entt::basic_handle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Entity&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6de052205bafd99d67afde880b67a4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de052205bafd99d67afde880b67a4e8">&#9670;&nbsp;</a></span>basic_handle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1basic__handle.html">entt::basic_handle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Entity&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; const Entity &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3221623cd9ea8247dfe3512a40f7fb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3221623cd9ea8247dfe3512a40f7fb8a">&#9670;&nbsp;</a></span>basic_hashed_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__hashed__string.html">entt::basic_hashed_string</a> </td>
          <td>(</td>
          <td class="paramtype">const Char(&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[N]</td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the character type of the hashed string directly from a human-readable identifer provided to the constructor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of characters of the identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Human-readable identifer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83181819c86fd37176b9894d833a572f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83181819c86fd37176b9894d833a572f">&#9670;&nbsp;</a></span>basic_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Storage&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__view.html">entt::basic_view</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1Storage.html">Storage</a> &amp;...&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; std::common_type_t&lt; typename Storage::entity_type... &gt;, <a class="el" href="structentt_1_1exclude__t.html">entt::exclude_t</a>&lt;&gt;, <a class="el" href="namespaceentt.html#a7b051461867d3c5c97f77f10b662c26b">constness_as_t</a>&lt; typename Storage::value_type, <a class="el" href="structentt_1_1Storage.html">Storage</a> &gt;... &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structentt_1_1Storage.html" title="Basic poly storage implementation.">Storage</a></td><td>Type of storage classes used to create the view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>The storage for the types to iterate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a865c97b32a0858165d34ed9820cbdef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865c97b32a0858165d34ed9820cbdef1">&#9670;&nbsp;</a></span>delegate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Candidate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate)&gt;&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>Function or member to connect to the delegate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f4796d34a9000c5c471b95a9eee4da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4796d34a9000c5c471b95a9eee4da1">&#9670;&nbsp;</a></span>delegate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Candidate, typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1connect__arg__t.html">connect_arg_t</a>&lt; Candidate &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; std::remove_pointer_t&lt; internal::function_pointer_t&lt; decltype(Candidate), Type &gt;&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Candidate</td><td>Function or member to connect to the delegate. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of class or type of payload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad125386ca0a0050b8a24ce3d8fc3db30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad125386ca0a0050b8a24ce3d8fc3db30">&#9670;&nbsp;</a></span>delegate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1delegate.html">entt::delegate</a> </td>
          <td>(</td>
          <td class="paramtype">Ret(*)(const void *, Args...)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ab7b51802157a98106f238335fa7503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab7b51802157a98106f238335fa7503">&#9670;&nbsp;</a></span>dereference_meta_pointer_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) entt::dereference_meta_pointer_like </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ADL based lookup function for dereferencing meta pointer-like types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A pointer-like object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value returned from the dereferenced pointer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adl__pointer_8hpp_source.html#l00015">15</a> of file <a class="el" href="adl__pointer_8hpp_source.html">adl_pointer.hpp</a>.</p>

</div>
</div>
<a id="ade4a534b0b8ca5f5ffb5cea2c3523413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4a534b0b8ca5f5ffb5cea2c3523413">&#9670;&nbsp;</a></span>get_as_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto entt::get_as_tuple </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] Type &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const typename Type::entity_type&#160;</td>
          <td class="paramname"><em>entity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the element assigned to an entity from a storage, if any. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td><a class="el" href="structentt_1_1Storage.html" title="Basic poly storage implementation.">Storage</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>A valid instance of a storage class. </td></tr>
    <tr><td class="paramname">entity</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A possibly empty tuple containing the requested element. </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_8hpp_source.html#l00806">806</a> of file <a class="el" href="storage_8hpp_source.html">storage.hpp</a>.</p>

</div>
</div>
<a id="aa512a354fe328df6be5a92eb43cd4d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa512a354fe328df6be5a92eb43cd4d69">&#9670;&nbsp;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Member, typename Entity  = entity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void entt::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to create a listener that directly invokes a member function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>Member function to invoke on a component of the given type. </td></tr>
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>A registry that contains the given entity and its components. </td></tr>
    <tr><td class="paramname">entt</td><td>Entity from which to get the component. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="helper_8hpp_source.html#l00130">130</a> of file <a class="el" href="helper_8hpp_source.html">helper.hpp</a>.</p>

</div>
</div>
<a id="a78885d25ace657bedd664e3044152f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78885d25ace657bedd664e3044152f03">&#9670;&nbsp;</a></span>meta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto entt::meta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to use for reflection. </p>
<p>This is the point from which everything starts.<br  />
 By invoking this function with a type that is not yet reflected, a meta type is created to which it will be possible to attach meta objects through a dedicated factory.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to reflect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta factory for the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="factory_8hpp_source.html#l00564">564</a> of file <a class="el" href="factory_8hpp_source.html">factory.hpp</a>.</p>

</div>
</div>
<a id="a0861c2878957a89499b0ca0801f7eeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0861c2878957a89499b0ca0801f7eeff">&#9670;&nbsp;</a></span>meta_construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Args, std::size_t... Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *const&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance given a list of erased parameters, if possible. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Actual type of the instance to construct. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments expected. </td></tr>
    <tr><td class="paramname">Index</td><td>Indexes to use to extract erased arguments from their list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters to use to construct the instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the new instance, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00142">142</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a3fe26d091f302630470004fe314a6a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe26d091f302630470004fe314a6a8d">&#9670;&nbsp;</a></span>meta_getter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Data, typename Policy  = as_is_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_getter </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value of a given variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the variable is associated. </td></tr>
    <tr><td class="paramname">Data</td><td>The actual variable to get. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the value of the underlying variable. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00208">208</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="ab4ab280279554979b88da3c693e8a5ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ab280279554979b88da3c693e8a5ec">&#9670;&nbsp;</a></span>meta_invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Candidate, typename Policy  = as_is_t, std::size_t... Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> entt::meta_invoke </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classentt_1_1meta__any.html">meta_any</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Index... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes a function given a list of erased parameters, if possible. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the function is associated. </td></tr>
    <tr><td class="paramname">Candidate</td><td>The actual function to invoke. </td></tr>
    <tr><td class="paramname">Policy</td><td>Optional policy (no policy set by default). </td></tr>
    <tr><td class="paramname">Index</td><td>Indexes to use to extract erased arguments from their list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">args</td><td>Parameters to use to invoke the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A meta any containing the returned value, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00259">259</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="adbe109e5134bae55cb519799acbed732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe109e5134bae55cb519799acbed732">&#9670;&nbsp;</a></span>meta_setter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , auto Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool entt::meta_setter </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structentt_1_1meta__handle.html">meta_handle</a>&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="classentt_1_1meta__any.html">meta_any</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of a given variable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Reflected type to which the variable is associated. </td></tr>
    <tr><td class="paramname">Data</td><td>The actual variable to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>An opaque instance of the underlying type, if required. </td></tr>
    <tr><td class="paramname">value</td><td>Parameter to use to set the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_2utility_8hpp_source.html#l00160">160</a> of file <a class="el" href="meta_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="ad0e7f23a35b9c534a369321633876b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e7f23a35b9c534a369321633876b31">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Len, std::size_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__any.html">basic_any</a>&lt; Len, Align &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two wrappers differ in their content. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Len</td><td>Size of the storage reserved for the small buffer optimization. </td></tr>
    <tr><td class="paramname">Align</td><td>Alignment requirement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A wrapper, either empty or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A wrapper, either empty or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two wrappers differ in their content, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="any_8hpp_source.html#l00348">348</a> of file <a class="el" href="any_8hpp_source.html">any.hpp</a>.</p>

</div>
</div>
<a id="a31fe21a1261b7ee705090e976b88d9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fe21a1261b7ee705090e976b88d9b7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1basic__handle.html">basic_handle</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two handles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
    <tr><td class="paramname">Other</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid handle. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if both handles refer to the same registry and the same entity, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_2handle_8hpp_source.html#l00317">317</a> of file <a class="el" href="entity_2handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="ad9accc71a383509ada028f7fa2b767bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9accc71a383509ada028f7fa2b767bf">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; Char &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two hashed strings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Char</td><td>Character type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid hashed string. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid hashed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two hashed strings are identical, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00227">227</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="ae663976796b773780f6136606c1a3f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae663976796b773780f6136606c1a3f31">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1delegate.html">delegate</a>&lt; Ret(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two delegates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid delegate object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid delegate object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two contents differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="delegate_8hpp_source.html#l00328">328</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a id="a2c5bf9ffc5b47e91752c4362ffb261e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5bf9ffc5b47e91752c4362ffb261e2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Entity &amp;&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1null__t.html">null_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a null object and an entity identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Entity identifier with which to compare. </td></tr>
    <tr><td class="paramname">other</td><td>A null object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two elements differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00171">171</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="a6bf49974479c8ec5344afe078a997a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf49974479c8ec5344afe078a997a8d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__any.html">meta_any</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two wrappers differ in their content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A meta any object, either empty or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>A meta any object, either empty or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two wrappers differ in their content, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l00576">576</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="a85b862c2db6e5771fb95d7a7930e9b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b862c2db6e5771fb95d7a7930e9b18">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two objects refer to the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>An object, either valid or not. </td></tr>
    <tr><td class="paramname">rhs</td><td>An object, either valid or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the objects refer to the same node, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="meta_8hpp_source.html#l01569">1569</a> of file <a class="el" href="meta_8hpp_source.html">meta.hpp</a>.</p>

</div>
</div>
<a id="acc7d9c84e9e3488ae011db3cfd53c280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7d9c84e9e3488ae011db3cfd53c280">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool entt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two type info objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A type info object. </td></tr>
    <tr><td class="paramname">rhs</td><td>A type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two contents differ, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00237">237</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<a id="af82a1c228d600f6c48fb5ef28fde3161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82a1c228d600f6c48fb5ef28fde3161">&#9670;&nbsp;</a></span>operator&quot;&quot;_hs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceentt.html#a8f9dd22ce26cd7913a294b3fd520649b">entt::hashed_string</a> entt::literals::operator&quot;&quot;_hs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined literal for hashed strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The literal without its suffix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized hashed string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00248">248</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a8643294b9892bb1342bf055a75047f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8643294b9892bb1342bf055a75047f06">&#9670;&nbsp;</a></span>operator&quot;&quot;_hws()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceentt.html#af2768719b1f5967caf5836b2656d0ed6">entt::hashed_wstring</a> entt::literals::operator&quot;&quot;_hws </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User defined literal for hashed wstrings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The literal without its suffix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A properly initialized hashed wstring. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hashed__string_8hpp_source.html#l00258">258</a> of file <a class="el" href="hashed__string_8hpp_source.html">hashed_string.hpp</a>.</p>

</div>
</div>
<a id="a6c6e966c8af5b1452811aa55adbbdf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6e966c8af5b1452811aa55adbbdf47">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type, typename... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1type__list.html">type_list</a>&lt;Type..., Other...&gt; entt::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Type... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1type__list.html">type_list</a>&lt; Other... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates multiple type lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Types provided by the first type list. </td></tr>
    <tr><td class="paramname">Other</td><td>Types provided by the second type list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type list composed by the types of both the type lists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00180">180</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aabc6dd5fb4d2bc92d9e5101b7b0bce1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc6dd5fb4d2bc92d9e5101b7b0bce1d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto... Value, auto... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1value__list.html">value_list</a>&lt;Value..., Other...&gt; entt::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Value... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structentt_1_1value__list.html">value_list</a>&lt; Other... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates multiple value lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Values provided by the first value list. </td></tr>
    <tr><td class="paramname">Other</td><td>Values provided by the second value list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value list composed by the values of both the value lists. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00376">376</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ad801f15accdf588b163ce48ce9209bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad801f15accdf588b163ce48ce9209bf6">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool entt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Entity &amp;&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structentt_1_1null__t.html">null_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a null object and an entity identifier of any type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>Type of entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Entity identifier with which to compare. </td></tr>
    <tr><td class="paramname">other</td><td>A null object yet to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the two elements differ, true otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00158">158</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="af0174aa3efe81fb881deb652d4b6d233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0174aa3efe81fb881deb652d4b6d233">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename... ELhs, typename... CLhs, typename... ERhs, typename... CRhs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto entt::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; Entity, <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; ELhs... &gt;, CLhs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__view.html">basic_view</a>&lt; Entity, <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt; ERhs... &gt;, CRhs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines two views in a <em>more specific</em> one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
    <tr><td class="paramname">ELhs</td><td>Filter list of the first view. </td></tr>
    <tr><td class="paramname">CLhs</td><td>Component list of the first view. </td></tr>
    <tr><td class="paramname">ERhs</td><td>Filter list of the second view. </td></tr>
    <tr><td class="paramname">CRhs</td><td>Component list of the second view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid reference to the first view. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid reference to the second view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A more specific view. </dd></dl>

<p class="definition">Definition at line <a class="el" href="view_8hpp_source.html#l00975">975</a> of file <a class="el" href="view_8hpp_source.html">view.hpp</a>.</p>

</div>
</div>
<a id="a267f6d6d3ea49bd36f7e8d2f002ec1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267f6d6d3ea49bd36f7e8d2f002ec1d1">&#9670;&nbsp;</a></span>overload() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::overload </td>
          <td>(</td>
          <td class="paramtype">Func *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant utility to disambiguate overloaded functions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Function type of the desired overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A valid pointer to a function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2utility_8hpp_source.html#l00045">45</a> of file <a class="el" href="core_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="ac5131df9ce458a6884c43595f501f916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5131df9ce458a6884c43595f501f916">&#9670;&nbsp;</a></span>overload() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::overload </td>
          <td>(</td>
          <td class="paramtype">Type Class::*&#160;</td>
          <td class="paramname"><em>member</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant utility to disambiguate overloaded members of a class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type of the desired overload. </td></tr>
    <tr><td class="paramname">Class</td><td>Type of class to which the member belongs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">member</td><td>A valid pointer to a member. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the member. </dd></dl>

<p class="definition">Definition at line <a class="el" href="core_2utility_8hpp_source.html#l00035">35</a> of file <a class="el" href="core_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a26eb67ac302229374c5fb623d529f5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26eb67ac302229374c5fb623d529f5eb">&#9670;&nbsp;</a></span>overloaded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Func&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1overloaded.html">entt::overloaded</a> </td>
          <td>(</td>
          <td class="paramtype">Func...&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structentt_1_1overloaded.html">overloaded</a>&lt; Func... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Types of function objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaec3476b637deea0ca553427175664f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaec3476b637deea0ca553427175664f">&#9670;&nbsp;</a></span>poly_call()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Member, typename Poly , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) entt::poly_call </td>
          <td>(</td>
          <td class="paramtype">Poly &amp;&amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcut for calling <code><a class="el" href="structentt_1_1poly__base.html" title="Poly base class used to inject functionalities into concepts.">poly_base</a>&lt;Type&gt;<a class="el" href="namespaceentt.html#aa512a354fe328df6be5a92eb43cd4d69" title="Helper to create a listener that directly invokes a member function.">invoke</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Member</td><td>Index of the function to invoke. </td></tr>
    <tr><td class="paramname">Poly</td><td>A fully defined poly object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>A reference to the poly object that made the call. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the invoked function, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="poly_8hpp_source.html#l00160">160</a> of file <a class="el" href="poly_8hpp_source.html">poly.hpp</a>.</p>

</div>
</div>
<a id="af786b2fb9c4667924bbed3b0bcb83cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af786b2fb9c4667924bbed3b0bcb83cac">&#9670;&nbsp;</a></span>resolve() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__range.html">meta_range</a>&lt; <a class="el" href="classentt_1_1meta__type.html">meta_type</a> &gt; entt::resolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type. </p>
<p>Returns a range to use to visit all meta types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type to use to search for a meta type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type, if any.</dd>
<dd>
An iterable range to use to visit all meta types. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00022">22</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a4493a8ed8dc4bc71b11058973c0fd9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4493a8ed8dc4bc71b11058973c0fd9aa">&#9670;&nbsp;</a></span>resolve() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceentt.html#a13e040e7b38a8f86d1ab2f096f37b627">id_type</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given identifier, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given identifier, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00041">41</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a629a71c04515885738cbb406fb81e08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629a71c04515885738cbb406fb81e08d">&#9670;&nbsp;</a></span>resolve() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1meta__type.html">meta_type</a> entt::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1type__info.html">type_info</a>&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the meta type associated with a given type info object, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The type info object of the requested type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The meta type associated with the given type info object, if any. </dd></dl>

<p class="definition">Definition at line <a class="el" href="resolve_8hpp_source.html#l00058">58</a> of file <a class="el" href="resolve_8hpp_source.html">resolve.hpp</a>.</p>

</div>
</div>
<a id="a1367d938e16a6c5b6aaedab5cf10f295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1367d938e16a6c5b6aaedab5cf10f295">&#9670;&nbsp;</a></span>sink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1sink.html">entt::sink</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1sigh.html">sigh</a>&lt; Ret(Args...)&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classentt_1_1sink.html">sink</a>&lt; Ret(Args...)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduction guide. </p>
<p>It allows to deduce the function type of a sink directly from the signal it refers to.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>Return type of a function type. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments of a function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb31e9165a07456c03f8c64295117824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb31e9165a07456c03f8c64295117824">&#9670;&nbsp;</a></span>to_entity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Component &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Entity entt::to_entity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__registry.html">basic_registry</a>&lt; Entity &gt; &amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Component &amp;&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the entity associated with a given component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="structentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
    <tr><td class="paramname">Component</td><td>Type of component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>A registry that contains the given entity and its components. </td></tr>
    <tr><td class="paramname">component</td><td>A valid component instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entity associated with the given component. </dd></dl>

<p class="definition">Definition at line <a class="el" href="helper_8hpp_source.html#l00147">147</a> of file <a class="el" href="helper_8hpp_source.html">helper.hpp</a>.</p>

</div>
</div>
<a id="a71abd3e36498ea599ce0abc367d7c3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71abd3e36498ea599ce0abc367d7c3ae">&#9670;&nbsp;</a></span>to_integral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::to_integral </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an entity type to its underlying type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>The value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>The value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral representation of the given value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00093">93</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="ab03b2c2ea5e867fd6f43c0ac49149dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03b2c2ea5e867fd6f43c0ac49149dea">&#9670;&nbsp;</a></span>type_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1type__info.html">type_info</a> entt::type_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type info object for a given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Type for which to generate a type info object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type info object for the given type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type__info_8hpp_source.html#l00248">248</a> of file <a class="el" href="type__info_8hpp_source.html">type_info.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a089f75043b082abca3ea144bce44e9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089f75043b082abca3ea144bce44e9ae">&#9670;&nbsp;</a></span>choice</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1choice__t.html">choice_t</a>&lt;N&gt; entt::choice {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for the choice trick. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Number of choices available. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00038">38</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a5b73210cef43c4db35ef8ce477cc38a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b73210cef43c4db35ef8ce477cc38a6">&#9670;&nbsp;</a></span>exclude</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1exclude__t.html">exclude_t</a>&lt;Type...&gt; entt::exclude {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for exclusion lists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2utility_8hpp_source.html#l00024">24</a> of file <a class="el" href="entity_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="a8c24ecc5ab0055f9f2a4725c95afb29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c24ecc5ab0055f9f2a4725c95afb29e">&#9670;&nbsp;</a></span>get</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1get__t.html">get_t</a>&lt;Type...&gt; entt::get {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable template for lists of observed components. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>List of types. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="entity_2utility_8hpp_source.html#l00040">40</a> of file <a class="el" href="entity_2utility_8hpp_source.html">utility.hpp</a>.</p>

</div>
</div>
<a id="affced7f7dba6f59b6b1adbf39d1087ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affced7f7dba6f59b6b1adbf39d1087ca">&#9670;&nbsp;</a></span>is_applicable_r_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ret , typename Func , typename Args &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::is_applicable_r_v = <a class="el" href="structentt_1_1is__applicable__r.html">is_applicable_r</a>&lt;Ret, Func, Args&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ret</td><td>The type to which the return type of the function should be convertible. </td></tr>
    <tr><td class="paramname">Func</td><td>A valid function type. </td></tr>
    <tr><td class="paramname">Args</td><td>The list of arguments to use to probe the function type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00540">540</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="af4012f88fe8b134ce1e37491bce21dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4012f88fe8b134ce1e37491bce21dd3">&#9670;&nbsp;</a></span>is_applicable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename Args &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::is_applicable_v = <a class="el" href="structentt_1_1is__applicable.html">is_applicable</a>&lt;Func, Args&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>A valid function type. </td></tr>
    <tr><td class="paramname">Args</td><td>The list of arguments to use to probe the function type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00513">513</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a27ca667fdc396b9d92418f588a539dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ca667fdc396b9d92418f588a539dec">&#9670;&nbsp;</a></span>is_complete_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::is_complete_v = <a class="el" href="structentt_1_1is__complete.html">is_complete</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potential complete type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00562">562</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a8055bbf0ea80cb29a994e753ff12e1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8055bbf0ea80cb29a994e753ff12e1b0">&#9670;&nbsp;</a></span>is_empty_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::is_empty_v = <a class="el" href="structentt_1_1is__empty.html">is_empty</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potential empty type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00603">603</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aff2c2c940fcfd655abaa24489471dad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2c2c940fcfd655abaa24489471dad8">&#9670;&nbsp;</a></span>is_equality_comparable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::is_equality_comparable_v = <a class="el" href="structentt_1_1is__equality__comparable.html">is_equality_comparable</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potentially equality comparable type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00479">479</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ad49b2ea24586994d23d6d837a550867a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49b2ea24586994d23d6d837a550867a">&#9670;&nbsp;</a></span>is_key_only_meta_associative_container_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::is_key_only_meta_associative_container_v = <a class="el" href="structentt_1_1is__key__only__meta__associative__container.html">is_key_only_meta_associative_container</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potentially key-only meta associative container type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="meta_2type__traits_8hpp_source.html#l00056">56</a> of file <a class="el" href="meta_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="aaa8c390cfe71301a0c10f4844e98424c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8c390cfe71301a0c10f4844e98424c">&#9670;&nbsp;</a></span>is_meta_pointer_like_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::is_meta_pointer_like_v = <a class="el" href="structentt_1_1is__meta__pointer__like.html">is_meta_pointer_like</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potentially pointer-like type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="meta_2type__traits_8hpp_source.html#l00082">82</a> of file <a class="el" href="meta_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a302633f8a2e49f936505c0612fc8b9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302633f8a2e49f936505c0612fc8b9bb">&#9670;&nbsp;</a></span>is_std_hashable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::is_std_hashable_v = <a class="el" href="structentt_1_1is__std__hashable.html">is_std_hashable</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>Potentially hashable type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00586">586</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ab43a13f7ee60bcb0d04a001f92b86fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43a13f7ee60bcb0d04a001f92b86fa2">&#9670;&nbsp;</a></span>monostate_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;id_type Value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structentt_1_1monostate.html">monostate</a>&lt;Value&gt; entt::monostate_v = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>Value used to differentiate between different variables. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="monostate_8hpp_source.html#l00056">56</a> of file <a class="el" href="monostate_8hpp_source.html">monostate.hpp</a>.</p>

</div>
</div>
<a id="a2f0c0a1c1d953ea991591748744cdd8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0c0a1c1d953ea991591748744cdd8b">&#9670;&nbsp;</a></span>null</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structentt_1_1null__t.html">null_t</a> entt::null {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time constant for null entities. </p>
<p>Internal details not to be documented.</p>
<p>There exist implicit conversions from this variable to entity identifiers of any allowed type. Similarly, there exist comparision operators between the null entity and any other entity identifier. </p>

<p class="definition">Definition at line <a class="el" href="entity_8hpp_source.html#l00189">189</a> of file <a class="el" href="entity_8hpp_source.html">entity.hpp</a>.</p>

</div>
</div>
<a id="aa4aec80af8bb10dcc2e289c91903433b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4aec80af8bb10dcc2e289c91903433b">&#9670;&nbsp;</a></span>size_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::size_of_v = <a class="el" href="structentt_1_1size__of.html">size_of</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The type of which to return the size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00085">85</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="ac56a88b7c6d0f691dd1e3d844bb41980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56a88b7c6d0f691dd1e3d844bb41980">&#9670;&nbsp;</a></span>type_list_contains_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class List , typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::type_list_contains_v = <a class="el" href="structentt_1_1type__list__contains.html">type_list_contains</a>&lt;List, Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">List</td><td>Type list. </td></tr>
    <tr><td class="paramname">Type</td><td>Type to look for. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00290">290</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a447c782d9f4f5332dfd4dde6f03d4a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447c782d9f4f5332dfd4dde6f03d4a4e">&#9670;&nbsp;</a></span>unpack_as_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Value, typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::unpack_as_v = Value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template to be used to <em>repeat</em> the same value a number of times equal to the size of a given parameter pack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>A value to repeat. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00103">103</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
<a id="a4bbfb162708696f9c1497d61573b540f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbfb162708696f9c1497d61573b540f">&#9670;&nbsp;</a></span>value_list_element_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename List &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto entt::value_list_element_v = <a class="el" href="structentt_1_1value__list__element.html">value_list_element</a>&lt;Index, List&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Index of the value to return. </td></tr>
    <tr><td class="paramname">List</td><td>Value list to search into. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="core_2type__traits_8hpp_source.html#l00366">366</a> of file <a class="el" href="core_2type__traits_8hpp_source.html">type_traits.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
