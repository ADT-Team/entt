<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: Crash Course: runtime reflection system</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EnTT
   &#160;<span id="projectnumber">3.7.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Crash Course: runtime reflection system </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md101"></a>
Introduction</h1>
<p>Reflection (or rather, its lack) is a trending topic in the C++ world and a tool that can unlock a lot of interesting feature in the specific case of <code>EnTT</code>. I looked for a third-party library that met my needs on the subject, but I always came across some details that I didn't like: macros, being intrusive, too many allocations, and so on.<br  />
 I finally decided to write a built-in, non-intrusive and macro-free runtime reflection system for <code>EnTT</code>. Maybe I didn't do better than others or maybe yes, time will tell me, but at least I can model this tool around the library to which it belongs and not the opposite.</p>
<h1><a class="anchor" id="autotoc_md102"></a>
Names and identifiers</h1>
<p>The meta system doesn't force users to rely on the tools provided by the library when it comes to working with names and identifiers. It does this by offering an API that works with opaque identifiers that may or may not be generated by means of a hashed string.<br  />
 This means that users can assign any type of identifier to the meta objects, as long as they are numeric. It doesn't matter if they are generated at runtime, at compile-time or with custom functions.</p>
<p>That being said, the examples in the following sections are all based on the <code>hashed_string</code> class as provided by this library. Therefore, where an identifier is required, it's likely that an user defined literal is used as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> factory = entt::meta&lt;my_type&gt;().type(<span class="stringliteral">&quot;reflected_type&quot;</span>_hs);</div>
</div><!-- fragment --><p>For what it's worth, this is likely completely equivalent to:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> factory = entt::meta&lt;my_type&gt;().type(42);</div>
</div><!-- fragment --><p>Obviously, human-readable identifiers are more convenient to use and highly recommended.</p>
<h1><a class="anchor" id="autotoc_md103"></a>
Reflection in a nutshell</h1>
<p>Reflection always starts from real types (users cannot reflect imaginary types and it would not make much sense, we wouldn't be talking about reflection anymore).<br  />
 To create a meta node, the library provides the <code>meta</code> function that accepts a type to reflect as a template parameter:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> factory = entt::meta&lt;my_type&gt;();</div>
</div><!-- fragment --><p>This isn't enough to <em>export</em> the given type and make it visible though.<br  />
 The returned value is a factory object to use to continue building the meta type. In order to make the type <em>visible</em>, users can assign it an identifier:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> factory = entt::meta&lt;my_type&gt;().type(<span class="stringliteral">&quot;reflected_type&quot;</span>_hs);</div>
</div><!-- fragment --><p>Or use the default one, that is, the built-in identifier for the given type:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> factory = entt::meta&lt;my_type&gt;().type();</div>
</div><!-- fragment --><p>Identifiers are important because users can retrieve meta types at runtime by searching for them by <em>name</em> other than by type.<br  />
 On the other hand, there are cases in which users can be interested in adding features to a reflected type so that the reflection system can use it correctly under the hood, but they don't want to also make the type <em>searchable</em>. In this case, it's sufficient not to invoke <code>type</code>.</p>
<p>A factory is such that all its member functions return the factory itself or a decorated version of it. This object can be used to add the following:</p>
<ul>
<li><em>Constructors</em>. Actual constructors can be assigned to a reflected type by specifying their list of arguments. Free functions (namely, factories) can be used as well, as long as the return type is the expected one. From a client's point of view, nothing changes if a constructor is a free function or an actual constructor.<br  />
 Use the <code>ctor</code> member function for this purpose:</li>
</ul>
<div class="fragment"><div class="line">entt::meta&lt;my_type&gt;().ctor&lt;int, <span class="keywordtype">char</span>&gt;().ctor&lt;&amp;factory&gt;();</div>
</div><!-- fragment --><ul>
<li><em>Destructors</em>. Free functions can be set as destructors of reflected types. The purpose is to give users the ability to free up resources that require special treatment before an object is actually destroyed.<br  />
 Use the <code>dtor</code> member function for this purpose:</li>
</ul>
<div class="fragment"><div class="line">entt::meta&lt;my_type&gt;().dtor&lt;&amp;destroy&gt;();</div>
</div><!-- fragment --><p>A function should neither delete nor explicitly invoke the destructor of a given instance.</p>
<ul>
<li><em>Data members</em>. Both real data members of the underlying type and static and global variables, as well as constants of any kind, can be attached to a meta type. From the point of view of the client, all the variables associated with the reflected type will appear as if they were part of the type itself.<br  />
 Use the <code>data</code> member function for this purpose:</li>
</ul>
<div class="fragment"><div class="line">entt::meta&lt;my_type&gt;()</div>
<div class="line">    .data&lt;&amp;my_type::static_variable&gt;(<span class="stringliteral">&quot;static&quot;</span>_hs)</div>
<div class="line">    .data&lt;&amp;my_type::data_member&gt;(<span class="stringliteral">&quot;member&quot;</span>_hs)</div>
<div class="line">    .data&lt;&amp;global_variable&gt;(<span class="stringliteral">&quot;global&quot;</span>_hs);</div>
</div><!-- fragment --><p>The function requires as an argument the identifier to give to the meta data once created. Users can then access meta data at runtime by searching for them by <em>name</em>.<br  />
 Data members can also be defined by means of a setter and getter pair. Setters and getters can be either free functions, class members or a mix of them, as long as they respect the required signatures. This approach is also convenient to create a read-only variable from a non-const data member:</p>
<div class="fragment"><div class="line">entt::meta&lt;my_type&gt;().data&lt;<span class="keyword">nullptr</span>, &amp;my_type::data_member&gt;(<span class="stringliteral">&quot;member&quot;</span>_hs);</div>
</div><!-- fragment --><p>Refer to the inline documentation for all the details.</p>
<ul>
<li><em>Member functions</em>. Both real member functions of the underlying type and free functions can be attached to a meta type. From the point of view of the client, all the functions associated with the reflected type will appear as if they were part of the type itself.<br  />
 Use the <code>func</code> member function for this purpose:</li>
</ul>
<div class="fragment"><div class="line">entt::meta&lt;my_type&gt;()</div>
<div class="line">    .func&lt;&amp;my_type::static_function&gt;(<span class="stringliteral">&quot;static&quot;</span>_hs)</div>
<div class="line">    .func&lt;&amp;my_type::member_function&gt;(<span class="stringliteral">&quot;member&quot;</span>_hs)</div>
<div class="line">    .func&lt;&amp;free_function&gt;(<span class="stringliteral">&quot;free&quot;</span>_hs);</div>
</div><!-- fragment --><p>The function requires as an argument the identifier to give to the meta function once created. Users can then access meta functions at runtime by searching for them by <em>name</em>.<br  />
 Overloading of meta functions is supported. Overloaded functions are resolved at runtime by the reflection system according to the types of the arguments.</p>
<ul>
<li><em>Base classes</em>. A base class is such that the underlying type is actually derived from it. In this case, the reflection system tracks the relationship and allows for implicit casts at runtime when required.<br  />
 Use the <code>base</code> member function for this purpose:</li>
</ul>
<div class="fragment"><div class="line">entt::meta&lt;derived_type&gt;().base&lt;base_type&gt;();</div>
</div><!-- fragment --><p>From now on, wherever a <code>base_type</code> is required, an instance of <code>derived_type</code> will also be accepted.</p>
<ul>
<li><em>Conversion functions</em>. Actual types can be converted, this is a fact. Just think of the relationship between a <code>double</code> and an <code>int</code> to see it. Similar to bases, conversion functions allow users to define conversions that will be implicitly performed by the reflection system when required.<br  />
 Use the <code>conv</code> member function for this purpose:</li>
</ul>
<div class="fragment"><div class="line">entt::meta&lt;double&gt;().conv&lt;<span class="keywordtype">int</span>&gt;();</div>
</div><!-- fragment --><p>That's all, everything users need to create meta types and enjoy the reflection system. At first glance it may not seem that much, but users usually learn to appreciate it over time.<br  />
 Also, do not forget what these few lines hide under the hood: a built-in, non-intrusive and macro-free system for reflection in C++. Features that are definitely worth the price, at least for me.</p>
<h2><a class="anchor" id="autotoc_md104"></a>
Any to the rescue</h2>
<p>The reflection system offers a kind of <em>extended version</em> of the <code><a class="el" href="namespaceentt.html#a4dc3b1582213034f13e2afe5c475467a" title="Alias declaration for the most common use case.">entt::any</a></code> class (see the core module for more details).<br  />
 The purpose is to add some feature on top of those already present, so as to integrate it with the meta type system without having to duplicate the code.</p>
<p>The API is very similar to that of the <code>any</code> type. The class <code>meta_any</code> <em>wraps</em> many of the feature to infer a meta node, before forwarding some or all of the arguments to the underlying storage.<br  />
 Among the few relevant differences, <code>meta_any</code> adds support for containers and pointer-like types (see the following sections for more details), while <code>any</code> does not.<br  />
 Similar to <code>any</code>, this class can also be used to create <em>aliases</em> for unmanaged objects either upon construction using <code>std::ref</code> and <code>std::cref</code> or from an existing instance by means of the <code>as_ref</code> function. However, unlike <code>any</code>, <code>meta_any</code> treats an empty instance and one initialized with <code>void</code> differently:</p>
<div class="fragment"><div class="line"><a class="code" href="classentt_1_1meta__any.html">entt::meta_any</a> empty{};</div>
<div class="line"><a class="code" href="classentt_1_1meta__any.html">entt::meta_any</a> other{std::in_place_type&lt;void&gt;};</div>
</div><!-- fragment --><p>While <code>any</code> considers both as empty, <code>meta_any</code> treats objects initialized with <code>void</code> as if they were <em>valid</em> ones. This allows to differentiate between failed function calls and function calls that are successful but return nothing.<br  />
 Finally, the member functions <code>try_cast</code>, <code>cast</code> and <code>allow_cast</code> are used to cast the underlying object to a given type (either a reference or a value type) or to <em>convert</em> a <code>meta_any</code> in such a way that a cast becomes viable for the resulting object. There is in fact no <code>any_cast</code> equivalent for <code>meta_any</code>.</p>
<h2><a class="anchor" id="autotoc_md105"></a>
Enjoy the runtime</h2>
<p>Once the web of reflected types has been constructed, it's a matter of using it at runtime where required.<br  />
 All this has the great merit that the reflection system stands in fact as a non-intrusive tool for the runtime, unlike the vast majority of the things offered by this library and closely linked to the compile-time.</p>
<p>To search for a reflected type there are a few options:</p>
<div class="fragment"><div class="line"><span class="comment">// direct access to a reflected type</span></div>
<div class="line"><span class="keyword">auto</span> by_type = entt::resolve&lt;my_type&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// look up a reflected type by identifier</span></div>
<div class="line"><span class="keyword">auto</span> by_id = <a class="code" href="namespaceentt.html#af786b2fb9c4667924bbed3b0bcb83cac">entt::resolve</a>(<span class="stringliteral">&quot;reflected_type&quot;</span>_hs);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// look up a reflected type by type info</span></div>
<div class="line"><span class="keyword">auto</span> by_type_id = <a class="code" href="namespaceentt.html#af786b2fb9c4667924bbed3b0bcb83cac">entt::resolve</a>(entt::type_id&lt;my_type&gt;());</div>
</div><!-- fragment --><p>There exits also an overload of the <code>resolve</code> function to use to iterate all the reflected types at once. It returns an iterable object that can be used in a range-for loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> type: <a class="code" href="namespaceentt.html#af786b2fb9c4667924bbed3b0bcb83cac">entt::resolve</a>()) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In all cases, the returned value is an instance of <code>meta_type</code>. This kind of objects offer an API to know their <em>runtime identifiers</em>, to iterate all the meta objects associated with them and even to build instances of the underlying type.<br  />
 Refer to the inline documentation for all the details.</p>
<p>The meta objects that compose a meta type are accessed in the following ways:</p>
<ul>
<li><em>Meta constructors</em>. They are accessed by types of arguments:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> ctor = entt::resolve&lt;my_type&gt;().ctor&lt;int, <span class="keywordtype">char</span>&gt;();</div>
</div><!-- fragment --><p>The returned type is <code>meta_ctor</code> and may be invalid if there is no constructor that accepts the supplied arguments or at least some types from which they are derived or to which they can be converted.<br  />
 A meta constructor offers an API to know the number of its arguments and their expected meta types. Furthermor, it's possible to invoke it and therefore to construct new instances of the underlying type.</p>
<ul>
<li><em>Meta data</em>. They are accessed by <em>name</em>:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> data = entt::resolve&lt;my_type&gt;().data(<span class="stringliteral">&quot;member&quot;</span>_hs);</div>
</div><!-- fragment --><p>The returned type is <code>meta_data</code> and may be invalid if there is no meta data object associated with the given identifier.<br  />
 A meta data object offers an API to query the underlying type (for example, to know if it's a const or a static one), to get the meta type of the variable and to set or get the contained value.</p>
<ul>
<li><em>Meta functions</em>. They are accessed by <em>name</em>:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> func = entt::resolve&lt;my_type&gt;().func(<span class="stringliteral">&quot;member&quot;</span>_hs);</div>
</div><!-- fragment --><p>The returned type is <code>meta_func</code> and may be invalid if there is no meta function object associated with the given identifier.<br  />
 A meta function object offers an API to query the underlying type (for example, to know if it's a const or a static function), to know the number of arguments, the meta return type and the meta types of the parameters. In addition, a meta function object can be used to invoke the underlying function and then get the return value in the form of a <code>meta_any</code> object.</p>
<ul>
<li><em>Meta bases</em>. They are accessed through the <em>name</em> of the base types:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> base = entt::resolve&lt;derived_type&gt;().base(<span class="stringliteral">&quot;base&quot;</span>_hs);</div>
</div><!-- fragment --><p>The returned type is <code>meta_type</code> and may be invalid if there is no meta base object associated with the given identifier.</p>
<p>All the objects thus obtained as well as the meta types can be explicitly converted to a boolean value to check if they are valid:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(<span class="keyword">auto</span> func = entt::resolve&lt;my_type&gt;().func(<span class="stringliteral">&quot;member&quot;</span>_hs); func) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Furthermore, all them are also returned by specific overloads that provide the caller with iterable ranges of top-level elements. As an example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> data = entt::resolve&lt;my_type&gt;().data()) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>A meta type can be used to <code>construct</code> actual instances of the underlying type.<br  />
 In particular, the <code>construct</code> member function accepts a variable number of arguments and searches for a match. It then returns a <code>meta_any</code> object that may or may not be initialized, depending on whether a suitable constructor has been found or not.</p>
<p>There is no object that wraps the destructor of a meta type nor a <code>destroy</code> member function in its API. Destructors are invoked implicitly by <code>meta_any</code> behind the scenes and users have not to deal with them explicitly. Furthermore, they have no name, cannot be searched and wouldn't have member functions to expose anyway.<br  />
 Similarly, conversion functions aren't directly accessible. They are used internally by <code>meta_any</code> and the meta objects when needed.</p>
<p>Meta types and meta objects in general contain much more than what is said: a plethora of functions in addition to those listed whose purposes and uses go unfortunately beyond the scope of this document.<br  />
 I invite anyone interested in the subject to look at the code, experiment and read the inline documentation to get the best out of this powerful tool.</p>
<h2><a class="anchor" id="autotoc_md106"></a>
Container support</h2>
<p>The runtime reflection system also supports containers of all types.<br  />
 Moreover, <em>containers</em> doesn't necessarily mean those offered by the C++ standard library. In fact, user defined data structures can also work with the meta system in many cases.</p>
<p>To make a container be recognized as such by the meta system, users are required to provide specializations for either the <code>meta_sequence_container_traits</code> class or the <code>meta_associative_container_traits</code> class, according with the actual type of the container.<br  />
 <code>EnTT</code> already exports the specializations for some common classes. In particular:</p>
<ul>
<li><code>std::vector</code> and <code>std::array</code> are exported as <em>sequence containers</em>.</li>
<li><code>std::map</code>, <code>std::set</code> and their unordered counterparts are exported as <em>associative containers</em>.</li>
</ul>
<p>It's important to include the header file <code><a class="el" href="container_8hpp_source.html">container.hpp</a></code> to make these specializations available to the compiler when needed.<br  />
 The same file also contains many examples for the users that are interested in making their own containers available to the meta system.</p>
<p>When a specialization of the <code>meta_sequence_container_traits</code> class exists, the meta system treats the wrapped type as a sequence container. In a similar way, a type is treated as an associative container if a specialization of the <code>meta_associative_container_traits</code> class is found for it.<br  />
 Proxy objects are returned by dedicated members of the <code>meta_any</code> class. The following is a deliberately verbose example of how users can access a proxy object for a sequence container:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec{1, 2, 3};</div>
<div class="line"><a class="code" href="classentt_1_1meta__any.html">entt::meta_any</a> <a class="code" href="namespaceentt.html#a4dc3b1582213034f13e2afe5c475467a">any</a>{std::ref(vec)};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code" href="namespaceentt.html#a4dc3b1582213034f13e2afe5c475467a">any</a>.<a class="code" href="classentt_1_1basic__any.html#abb89f095185e223b2b69533af4446baf">type</a>().is_sequence_container()) {</div>
<div class="line">    <span class="keywordflow">if</span>(<span class="keyword">auto</span> view = <a class="code" href="namespaceentt.html#a4dc3b1582213034f13e2afe5c475467a">any</a>.as_sequence_container(); view) {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The method to use to get a proxy object for associative containers is <code>as_associative_container</code> instead.<br  />
 It goes without saying that it's not necessary to perform a double check. Instead, it's sufficient to query the meta type or verify that the proxy object is valid. In fact, proxies are contextually convertible to bool to know if they are valid. For example, invalid proxies are returned when the wrapped object isn't a container.<br  />
 In all cases, users aren't expected to <em>reflect</em> containers explicitly. It's sufficient to assign a container for which a specialization of the traits classes exists to a <code>meta_any</code> object to be able to get its proxy object.</p>
<p>The interface of the <code>meta_sequence_container</code> proxy object is the same for all types of sequence containers, although the available features differ from case to case. In particular:</p>
<ul>
<li>The <code>value_type</code> member function returns the meta type of the elements.</li>
<li>The <code>size</code> member function returns the number of elements in the container as an unsigned integer value:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> size = <a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>.size();</div>
</div><!-- fragment --><ul>
<li>The <code>resize</code> member function allows to resize the wrapped container and returns true in case of succes:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> ok = <a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>.resize(3u);</div>
</div><!-- fragment --><p>For example, it's not possible to resize fixed size containers.</p>
<ul>
<li>The <code>clear</code> member function allows to clear the wrapped container and returns true in case of success:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> ok = <a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>.clear();</div>
</div><!-- fragment --><p>For example, it's not possible to clear fixed size containers.</p>
<ul>
<li>The <code>begin</code> and <code>end</code> member functions return opaque iterators that can be used to iterate the container directly:</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<a class="code" href="classentt_1_1meta__any.html">entt::meta_any</a> element: view) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In all cases, given an underlying container of type <code>C</code>, the returned element contains an object of type <code>C::value_type</code> which therefore depends on the actual container.<br  />
 All meta iterators are input iterators and don't offer an indirection operator on purpose.</p>
<ul>
<li>The <code>insert</code> member function can be used to add elements to the container. It accepts a meta iterator and the element to insert:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> last = <a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>.end();</div>
<div class="line"><span class="comment">// appends an integer to the container</span></div>
<div class="line"><a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>.insert(last, 42);</div>
</div><!-- fragment --><p>This function returns a meta iterator pointing to the inserted element and a boolean value to indicate whether the operation was successful or not. Note that a call to <code>insert</code> may silently fail in case of fixed size containers or whether the arguments aren't at least convertible to the required types.<br  />
 Since the meta iterators are contextually convertible to bool, users can rely on them to know if the operation has failed on the actual container or upstream, for example for an argument conversion problem.</p>
<ul>
<li>The <code>erase</code> member function can be used to remove elements from the container. It accepts a meta iterator to the element to remove:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> first = <a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>.begin();</div>
<div class="line"><span class="comment">// removes the first element from the container</span></div>
<div class="line"><a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>.erase(first);</div>
</div><!-- fragment --><p>This function returns a meta iterator following the last removed element and a boolean value to indicate whether the operation was successful or not. Note that a call to <code>erase</code> may silently fail in case of fixed size containers.</p>
<ul>
<li>The <code>operator[]</code> can be used to access elements in a container. It accepts a single argument, that is the position of the element to return:</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(std::size_t pos{}, last = <a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>.size(); pos &lt; last; ++pos) {</div>
<div class="line">    <a class="code" href="classentt_1_1meta__any.html">entt::meta_any</a> value = <a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>[pos];</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The function returns instances of <code>meta_any</code> that directly refer to the actual elements. Modifying the returned object will then directly modify the element inside the container.</p>
<p>Similarly, also the interface of the <code>meta_associative_container</code> proxy object is the same for all types of associative containers. However, there are some differences in behavior in the case of key-only containers. In particular:</p>
<ul>
<li>The <code>key_only</code> member function returns true if the wrapped container is a key-only one.</li>
<li>The <code>key_type</code> member function returns the meta type of the keys.</li>
<li>The <code>mapped_type</code> member function returns an invalid meta type for key-only containers and the meta type of the mapped values for all other types of containers.</li>
<li>The <code>value_type</code> member function returns the meta type of the elements.<br  />
 For example, it returns the meta type of <code>int</code> for <code>std::set&lt;int&gt;</code> while it returns the meta type of <code>std::pair&lt;const int, char&gt;</code> for <code>std::map&lt;int, char&gt;</code>.</li>
<li>The <code>size</code> member function returns the number of elements in the container as an unsigned integer value:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> size = <a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>.size();</div>
</div><!-- fragment --><ul>
<li>The <code>clear</code> member function allows to clear the wrapped container and returns true in case of success:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> ok = <a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>.clear();</div>
</div><!-- fragment --><ul>
<li>The <code>begin</code> and <code>end</code> member functions return opaque iterators that can be used to iterate the container directly:</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(std::pair&lt;entt::meta_any, entt::meta_any&gt; element: view) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In all cases, given an underlying container of type <code>C</code>, the returned element is a key-value pair where the key has type <code>C::key_type</code> and the value has type <code>C::mapped_type</code>. Since key-only containers don't have a mapped type, their <em>value</em> is nothing more than an invalid <code>meta_any</code> object.<br  />
 All meta iterators are input iterators and don't offer an indirection operator on purpose.</p>
<p>While the accessed key is usually constant in the associative containers and is therefore returned by copy, the value (if any) is wrapped by an instance of <code>meta_any</code> that directly refers to the actual element. Modifying it will then directly modify the element inside the container.</p>
<ul>
<li>The <code>insert</code> member function can be used to add elements to the container. It accepts two arguments, respectively the key and the value to be inserted:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> last = <a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>.end();</div>
<div class="line"><span class="comment">// appends an integer to the container</span></div>
<div class="line"><a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>.insert(last.handle(), 42, <span class="charliteral">&#39;c&#39;</span>);</div>
</div><!-- fragment --><p>This function returns a boolean value to indicate whether the operation was successful or not. Note that a call to <code>insert</code> may fail when the arguments aren't at least convertible to the required types.</p>
<ul>
<li>The <code>erase</code> member function can be used to remove elements from the container. It accepts a single argument, that is the key to be removed:</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>.erase(42);</div>
</div><!-- fragment --><p>This function returns a boolean value to indicate whether the operation was successful or not. Note that a call to <code>erase</code> may fail when the argument isn't at least convertible to the required type.</p>
<ul>
<li>The <code>operator[]</code> can be used to access elements in a container. It accepts a single argument, that is the key of the element to return:</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classentt_1_1meta__any.html">entt::meta_any</a> value = <a class="code" href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">view</a>[42];</div>
</div><!-- fragment --><p>The function returns instances of <code>meta_any</code> that directly refer to the actual elements. Modifying the returned object will then directly modify the element inside the container.</p>
<p>Container support is minimal but likely sufficient to satisfy all needs.</p>
<h2><a class="anchor" id="autotoc_md107"></a>
Pointer-like types</h2>
<p>As with containers, it's also possible to communicate to the meta system which types to consider <em>pointers</em>. This will allow to dereference instances of <code>meta_any</code>, thus obtaining light <em>references</em> to the pointed objects that are also correctly associated with their meta types.<br  />
 To make the meta system recognize a type as <em>pointer-like</em>, users can specialize the <code>is_meta_pointer_like</code> class. <code>EnTT</code> already exports the specializations for some common classes. In particular:</p>
<ul>
<li>All types of raw pointers.</li>
<li><code>std::unique_ptr</code> and <code>std::shared_ptr</code>.</li>
</ul>
<p>It's important to include the header file <code><a class="el" href="pointer_8hpp_source.html">pointer.hpp</a></code> to make these specializations available to the compiler when needed.<br  />
 The same file also contains many examples for the users that are interested in making their own pointer-like types available to the meta system.</p>
<p>When a type is recognized as a pointer-like one by the meta system, it's possible to dereference the instances of <code>meta_any</code> that contain these objects. The following is a deliberately verbose example to show how to use this feature:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> value = 42;</div>
<div class="line"><span class="comment">// meta type equivalent to that of int *</span></div>
<div class="line"><a class="code" href="classentt_1_1meta__any.html">entt::meta_any</a> <a class="code" href="namespaceentt.html#a4dc3b1582213034f13e2afe5c475467a">any</a>{&amp;value};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(<a class="code" href="namespaceentt.html#a4dc3b1582213034f13e2afe5c475467a">any</a>.<a class="code" href="classentt_1_1basic__any.html#abb89f095185e223b2b69533af4446baf">type</a>().is_pointer_like()) {</div>
<div class="line">    <span class="comment">// meta type equivalent to that of int</span></div>
<div class="line">    <span class="keywordflow">if</span>(<a class="code" href="classentt_1_1meta__any.html">entt::meta_any</a> ref = *any; ref) {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Of course, it's not necessary to perform a double check. Instead, it's enough to query the meta type or verify that the returned object is valid. For example, invalid instances are returned when the wrapped object isn't a pointer-like type.<br  />
 Note that dereferencing a pointer-like object returns an instance of <code>meta_any</code> which refers to the pointed object and allows users to modify it directly (unless the returned element is const, of course).</p>
<p>In general, <em>dereferencing</em> a pointer-like type boils down to a <code>*ptr</code>. However, <code>EnTT</code> also supports classes that don't offer an <code>operator*</code>. In particular:</p>
<ul>
<li>It's possible to exploit a solution based on ADL lookup by offering a function (also a template one) named <code>dereference_meta_pointer_like</code>:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</div>
<div class="line">Type &amp; <a class="code" href="namespaceentt.html#a2ab7b51802157a98106f238335fa7503">dereference_meta_pointer_like</a>(<span class="keyword">const</span> custom_pointer_type&lt;Type&gt; &amp;ptr) {</div>
<div class="line">    <span class="keywordflow">return</span> ptr.deref();</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>When not in control of the type's namespace, it's possible to inject into the <code>entt</code> namespace a specialization of the <code>adl_meta_pointer_like</code> class template to bypass the adl lookup as a whole:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structentt_1_1adl__meta__pointer__like.html">entt::adl_meta_pointer_like</a>&lt;custom_pointer_type&lt;Type&gt;&gt; {</div>
<div class="line">    <span class="keyword">static</span> decltype(<span class="keyword">auto</span>) <a class="code" href="structentt_1_1adl__meta__pointer__like.html#afa27f416e32b351d85ab1a061c4597bd">dereference</a>(const custom_pointer_type&lt;Type&gt; &amp;ptr) {</div>
<div class="line">        <span class="keywordflow">return</span> ptr.deref();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>In all other cases, that is, when dereferencing a pointer works as expected and regardless of the pointed type, no user intervention is required.</p>
<h2><a class="anchor" id="autotoc_md108"></a>
Template information</h2>
<p>Meta types also provide a minimal set of information about the nature of the original type in case it's a class template.<br  />
 By default, this works out of the box and requires no user action. However, it's important to include the header file <code><a class="el" href="template_8hpp_source.html">template.hpp</a></code> to make these information available to the compiler when needed.</p>
<p>Meta template information are easily found:</p>
<div class="fragment"><div class="line"><span class="comment">// this method returns true if the type is recognized as a class template specialization</span></div>
<div class="line"><span class="keywordflow">if</span>(<span class="keyword">auto</span> type = <a class="code" href="namespaceentt.html#af786b2fb9c4667924bbed3b0bcb83cac">entt::resolve</a>&lt;std::shared_ptr&lt;my_type&gt;&gt;(); type.<a class="code" href="classentt_1_1meta__type.html#ad837ecee0d13f2291c715d62bf642353">is_template_specialization</a>()) {</div>
<div class="line">    <span class="comment">// meta type of the class template conveniently wrapped by entt::meta_class_template_tag</span></div>
<div class="line">    <span class="keyword">auto</span> class_type = type.template_type();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// number of template arguments</span></div>
<div class="line">    std::size_t arity = type.template_arity();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// meta type of the i-th argument</span></div>
<div class="line">    <span class="keyword">auto</span> arg_type = type.template_arg(0u);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Typically, when template information for a type are required, what the library provides is sufficient. However, there are some cases where a user may want more details or a different set of information.<br  />
 Consider the case of a class template that is meant to wrap function types:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div>
<div class="line"><span class="keyword">struct </span>function_type;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</div>
<div class="line"><span class="keyword">struct </span>function_type&lt;Ret(Args...)&gt; {};</div>
</div><!-- fragment --><p>In this case, rather than the function type, the user might want the return type and unpacked arguments as if they were different template parameters for the original class template.<br  />
 To achieve this, users must enter the library internals and provide their own specialization for the class template <code><a class="el" href="structentt_1_1meta__template__traits.html" title="Traits class template to be specialized to enable support for meta template information.">entt::meta_template_traits</a></code>, such as:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structentt_1_1meta__template__traits.html">entt::meta_template_traits</a>&lt;function_type&lt;Ret(Args...)&gt;&gt; {</div>
<div class="line">    <span class="keyword">using</span> class_type = meta_class_template_tag&lt;function_type&gt;;</div>
<div class="line">    <span class="keyword">using</span> args_type = type_list&lt;Ret, Args...&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The reflection system doesn't verify the accuracy of the information nor infer a correspondence between real types and meta types.<br  />
 Therefore, the specialization will be used as is and the information it contains will be associated with the appropriate type when required.</p>
<h2><a class="anchor" id="autotoc_md109"></a>
Implicitly generated default constructor</h2>
<p>In many cases, it's useful to be able to create objects of default constructible types through the reflection system, while not having to explicitly register the meta type or the default constructor.<br  />
 For example, in the case of primitive types like <code>int</code> or <code>char</code>, but not just them.</p>
<p>For this reason and only for default constructible types, default constructors are automatically defined and associated with their meta types, whether they are explicitly or implicitly generated.<br  />
 Therefore, it won't be necessary to do this in order to construct an integer from its meta type:</p>
<div class="fragment"><div class="line">entt::meta&lt;int&gt;().ctor&lt;&gt;();</div>
</div><!-- fragment --><p>Instead, just do this:</p>
<div class="fragment"><div class="line">entt::resolve&lt;int&gt;().construct();</div>
</div><!-- fragment --><p>Where the meta type can be for example the one returned from a meta container, useful for building keys without knowing or having to register the actual types.</p>
<p>In all cases, when users register custom defaul constructors, they are preferred both during searches and when the <code>construct</code> member function is invoked.<br  />
 However, the implicitly generated default constructor will always be returned, either if one is not explicitly specified or if all constructors are iterated for some reason (in this case, it will always be the last element).</p>
<h2><a class="anchor" id="autotoc_md110"></a>
Policies: the more, the less</h2>
<p>Policies are a kind of compile-time directives that can be used when registering reflection information.<br  />
 Their purpose is to require slightly different behavior than the default in some specific cases. For example, when reading a given data member, its value is returned wrapped in a <code>meta_any</code> object which, by default, makes a copy of it. For large objects or if the caller wants to access the original instance, this behavior isn't desirable. Policies are there to offer a solution to this and other problems.</p>
<p>There are a few alternatives available at the moment:</p>
<ul>
<li>The <em>as-is</em> policy, associated with the type <code><a class="el" href="structentt_1_1as__is__t.html" title="Empty class type used to request the as-is policy.">entt::as_is_t</a></code>.<br  />
 This is the default policy. In general, it should never be used explicitly, since it's implicitly selected if no other policy is specified.<br  />
 In this case, the return values of the functions as well as the properties exposed as data members are always returned by copy in a dedicated wrapper and therefore associated with their original meta types.</li>
<li><p class="startli">The <em>as-void</em> policy, associated with the type <code><a class="el" href="structentt_1_1as__void__t.html" title="Empty class type used to request the as void policy.">entt::as_void_t</a></code>.<br  />
 Its purpose is to discard the return value of a meta object, whatever it is, thus making it appear as if its type were <code>void</code>: </p><div class="fragment"><div class="line">entt::meta&lt;my_type&gt;().func&lt;&amp;my_type::member_function, <a class="code" href="structentt_1_1as__void__t.html">entt::as_void_t</a>&gt;(<span class="stringliteral">&quot;member&quot;</span>_hs);</div>
</div><!-- fragment --><p class="startli">If the use with functions is obvious, it must be said that it's also possible to use this policy with constructors and data members. In the first case, the constructor will be invoked but the returned wrapper will actually be empty. In the second case, instead, the property will not be accessible for reading.</p>
</li>
<li><p class="startli">The <em>as-ref</em> and <em>as-cref</em> policies, associated with the types <code><a class="el" href="structentt_1_1as__ref__t.html" title="Empty class type used to request the as ref policy.">entt::as_ref_t</a></code> and <code><a class="el" href="structentt_1_1as__cref__t.html" title="Empty class type used to request the as cref policy.">entt::as_cref_t</a></code>.<br  />
 They allow to build wrappers that act as references to unmanaged objects. Accessing the object contained in the wrapper for which the <em>reference</em> was requested will make it possible to directly access the instance used to initialize the wrapper itself: </p><div class="fragment"><div class="line">entt::meta&lt;my_type&gt;().data&lt;&amp;my_type::data_member, <a class="code" href="structentt_1_1as__ref__t.html">entt::as_ref_t</a>&gt;(<span class="stringliteral">&quot;member&quot;</span>_hs);</div>
</div><!-- fragment --><p class="startli">These policies work with constructors (for example, when objects are taken from an external container rather than created on demand), data members and functions in general.<br  />
 If on the one hand <code>as_cref_t</code> always forces the return type to be const, <code>as_ref_t</code> <em>adapts</em> to the constness of the passed object and to that of the return type if any.</p>
</li>
</ul>
<p>Some uses are rather trivial, but it's useful to note that there are some less obvious corner cases that can in turn be solved with the use of policies.</p>
<h2><a class="anchor" id="autotoc_md111"></a>
Named constants and enums</h2>
<p>A special mention should be made for constant values and enums. It wouldn't be necessary, but it will help distracted readers.</p>
<p>As mentioned, the <code>data</code> member function can be used to reflect constants of any type among the other things.<br  />
 This allows users to create meta types for enums that will work exactly like any other meta type built from a class. Similarly, arithmetic types can be enriched with constants of special meaning where required.<br  />
 Personally, I find it very useful not to export what is the difference between enums and classes in C++ directly in the space of the reflected types.</p>
<p>All the values thus exported will appear to users as if they were constant data members of the reflected types.</p>
<p>Exporting constant values or elements from an enum is as simple as ever:</p>
<div class="fragment"><div class="line">entt::meta&lt;my_enum&gt;()</div>
<div class="line">    .data&lt;my_enum::a_value&gt;(<span class="stringliteral">&quot;a_value&quot;</span>_hs)</div>
<div class="line">    .data&lt;my_enum::another_value&gt;(<span class="stringliteral">&quot;another_value&quot;</span>_hs);</div>
<div class="line"> </div>
<div class="line">entt::meta&lt;int&gt;().data&lt;2048&gt;(<span class="stringliteral">&quot;max_int&quot;</span>_hs);</div>
</div><!-- fragment --><p>It goes without saying that accessing them is trivial as well. It's a matter of doing the following, as with any other data member of a meta type:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> value = entt::resolve&lt;my_enum&gt;().data(<span class="stringliteral">&quot;a_value&quot;</span>_hs).get({}).cast&lt;my_enum&gt;();</div>
<div class="line"><span class="keyword">auto</span> max = entt::resolve&lt;int&gt;().data(<span class="stringliteral">&quot;max_int&quot;</span>_hs).get({}).cast&lt;int&gt;();</div>
</div><!-- fragment --><p>As a side note, remember that all this happens behind the scenes without any allocation because of the small object optimization performed by the <code>meta_any</code> class.</p>
<h2><a class="anchor" id="autotoc_md112"></a>
Properties and meta objects</h2>
<p>Sometimes (for example, when it comes to creating an editor) it might be useful to attach properties to the meta objects created. Fortunately, this is possible for most of them.<br  />
 For the meta objects that support properties, the member functions of the factory used for registering them will return a decorated version of the factory itself. The latter can be used to attach properties to the last created meta object.<br  />
 Apparently, it's more difficult to say than to do:</p>
<div class="fragment"><div class="line">entt::meta&lt;my_type&gt;().type(<span class="stringliteral">&quot;reflected_type&quot;</span>_hs).prop(<span class="stringliteral">&quot;tooltip&quot;</span>_hs, <span class="stringliteral">&quot;message&quot;</span>);</div>
</div><!-- fragment --><p>Properties are always in the key/value form. There are no restrictions on the type of the key or value, as long as they are copy constructible objects.<br  />
 Multiple formats are supported when it comes to defining a property:</p>
<ul>
<li>Properties as key/value pairs:</li>
</ul>
<div class="fragment"><div class="line">entt::meta&lt;my_type&gt;().type(<span class="stringliteral">&quot;reflected_type&quot;</span>_hs).prop(<span class="stringliteral">&quot;tooltip&quot;</span>_hs, <span class="stringliteral">&quot;message&quot;</span>);</div>
</div><!-- fragment --><ul>
<li>Properties as <code>std::pair</code>s:</li>
</ul>
<div class="fragment"><div class="line">entt::meta&lt;my_type&gt;().type(<span class="stringliteral">&quot;reflected_type&quot;</span>_hs).prop(std::make_pair(<span class="stringliteral">&quot;tooltip&quot;</span>_hs, <span class="stringliteral">&quot;message&quot;</span>));</div>
</div><!-- fragment --><ul>
<li>Key only properties:</li>
</ul>
<div class="fragment"><div class="line">entt::meta&lt;my_type&gt;().type(<span class="stringliteral">&quot;reflected_type&quot;</span>_hs).prop(my_enum::key_only);</div>
</div><!-- fragment --><ul>
<li>Properties as <code>std::tuple</code>s:</li>
</ul>
<div class="fragment"><div class="line">entt::meta&lt;my_type&gt;().type(<span class="stringliteral">&quot;reflected_type&quot;</span>_hs).prop(std::make_tuple(std::make_pair(<span class="stringliteral">&quot;tooltip&quot;</span>_hs, <span class="stringliteral">&quot;message&quot;</span>), my_enum::key_only));</div>
</div><!-- fragment --><p>A tuple contains one or more properties. All of them are treated individually.</p>
<ul>
<li>Annotations:</li>
</ul>
<div class="fragment"><div class="line">entt::meta&lt;my_type&gt;().type(<span class="stringliteral">&quot;reflected_type&quot;</span>_hs).prop(&amp;property_generator);</div>
</div><!-- fragment --><p>An annotation is an invocable object that returns one or more properties. All of them are treated individually.</p>
<p>It's possible to invoke the <code>prop</code> function several times if needed, one for each property to associate with the last meta object created:</p>
<div class="fragment"><div class="line">entt::meta&lt;my_type&gt;()</div>
<div class="line">    .type(<span class="stringliteral">&quot;reflected_type&quot;</span>_hs)</div>
<div class="line">        .prop(<a class="code" href="classentt_1_1basic__hashed__string.html">entt::hashed_string</a>{<span class="stringliteral">&quot;Name&quot;</span>}, <span class="stringliteral">&quot;Reflected Type&quot;</span>)</div>
<div class="line">    .data&lt;&amp;my_type::data_member&gt;(<span class="stringliteral">&quot;member&quot;</span>_hs)</div>
<div class="line">        .prop(std::make_pair(<span class="stringliteral">&quot;tooltip&quot;</span>_hs, <span class="stringliteral">&quot;Member&quot;</span>))</div>
<div class="line">        .prop(my_enum::a_value, 42);</div>
</div><!-- fragment --><p>Alternatively, the <code>props</code> function is available to associate several properties at a time. However, in this case properties in the key/value form aren't allowed, since they would be interpreted as two different properties rather than a single one.</p>
<p>The meta objects for which properties are supported are currently the meta types, meta constructors, meta data and meta functions. It's not possible to attach properties to other types of meta objects and the factory returned as a result of their construction won't allow such an operation.</p>
<p>These types offer a couple of member functions named <code>prop</code> to iterate all properties at once or to search a specific property by key:</p>
<div class="fragment"><div class="line"><span class="comment">// iterate all properties of a meta type</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> prop: entt::resolve&lt;my_type&gt;().prop()) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// search for a given property by name</span></div>
<div class="line"><span class="keyword">auto</span> prop = entt::resolve&lt;my_type&gt;().prop(<span class="stringliteral">&quot;tooltip&quot;</span>_hs);</div>
</div><!-- fragment --><p>Meta properties are objects having a fairly poor interface, all in all. They only provide the <code>key</code> and the <code>value</code> member functions to be used to retrieve the key and the value contained in the form of <code>meta_any</code> objects, respectively.</p>
<h2><a class="anchor" id="autotoc_md113"></a>
Unregister types</h2>
<p>A type registered with the reflection system can also be unregistered. This means unregistering all its data members, member functions, conversion functions and so on. However, base classes aren't unregistered as well, since they don't necessarily depend on it. Similarly, implicitly generated types (as an example, the meta types implicitly generated for function parameters when needed) aren't unregistered.<br  />
 Roughly speaking, unregistering a type means disconnecting all associated meta objects from it and making its identifier no longer visible. The underlying node will remain available though, as if it were implicitly generated:</p>
<div class="fragment"><div class="line">entt::resolve&lt;my_type&gt;().reset();</div>
</div><!-- fragment --><p>The type can be re-registered later with a completely different name and form. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclassentt_1_1meta__type_html_ad837ecee0d13f2291c715d62bf642353"><div class="ttname"><a href="classentt_1_1meta__type.html#ad837ecee0d13f2291c715d62bf642353">entt::meta_type::is_template_specialization</a></div><div class="ttdeci">bool is_template_specialization() const noexcept</div><div class="ttdoc">Checks whether a type refers to a recognized class template specialization or not.</div><div class="ttdef"><b>Definition:</b> <a href="meta_8hpp_source.html#l01204">meta.hpp:1204</a></div></div>
<div class="ttc" id="aclassentt_1_1meta__any_html"><div class="ttname"><a href="classentt_1_1meta__any.html">entt::meta_any</a></div><div class="ttdoc">Opaque wrapper for values of any type.</div><div class="ttdef"><b>Definition:</b> <a href="meta_8hpp_source.html#l00159">meta.hpp:159</a></div></div>
<div class="ttc" id="astructentt_1_1as__void__t_html"><div class="ttname"><a href="structentt_1_1as__void__t.html">entt::as_void_t</a></div><div class="ttdoc">Empty class type used to request the as void policy.</div><div class="ttdef"><b>Definition:</b> <a href="policy_8hpp_source.html#l00021">policy.hpp:21</a></div></div>
<div class="ttc" id="anamespaceentt_html_acc5a93cf82f9378248fe6385376cd943"><div class="ttname"><a href="namespaceentt.html#acc5a93cf82f9378248fe6385376cd943">entt::view</a></div><div class="ttdeci">basic_view&lt; entity, Args... &gt; view</div><div class="ttdoc">Alias declaration for the most common use case.</div><div class="ttdef"><b>Definition:</b> <a href="entity_2fwd_8hpp_source.html#l00128">fwd.hpp:128</a></div></div>
<div class="ttc" id="aclassentt_1_1basic__any_html_abb89f095185e223b2b69533af4446baf"><div class="ttname"><a href="classentt_1_1basic__any.html#abb89f095185e223b2b69533af4446baf">entt::basic_any::type</a></div><div class="ttdeci">type_info type() const noexcept</div><div class="ttdoc">Returns the type of the contained object.</div><div class="ttdef"><b>Definition:</b> <a href="any_8hpp_source.html#l00251">any.hpp:251</a></div></div>
<div class="ttc" id="astructentt_1_1adl__meta__pointer__like_html_afa27f416e32b351d85ab1a061c4597bd"><div class="ttname"><a href="structentt_1_1adl__meta__pointer__like.html#afa27f416e32b351d85ab1a061c4597bd">entt::adl_meta_pointer_like::dereference</a></div><div class="ttdeci">static decltype(auto) dereference(const Type &amp;value)</div><div class="ttdoc">Uses the default ADL based lookup method to resolve the call.</div><div class="ttdef"><b>Definition:</b> <a href="adl__pointer_8hpp_source.html#l00031">adl_pointer.hpp:31</a></div></div>
<div class="ttc" id="astructentt_1_1meta__template__traits_html"><div class="ttname"><a href="structentt_1_1meta__template__traits.html">entt::meta_template_traits</a></div><div class="ttdoc">Traits class template to be specialized to enable support for meta template information.</div><div class="ttdef"><b>Definition:</b> <a href="meta_2type__traits_8hpp_source.html#l00016">type_traits.hpp:16</a></div></div>
<div class="ttc" id="astructentt_1_1adl__meta__pointer__like_html"><div class="ttname"><a href="structentt_1_1adl__meta__pointer__like.html">entt::adl_meta_pointer_like</a></div><div class="ttdoc">Fake ADL based lookup function for meta pointer-like types.</div><div class="ttdef"><b>Definition:</b> <a href="adl__pointer_8hpp_source.html#l00025">adl_pointer.hpp:25</a></div></div>
<div class="ttc" id="astructentt_1_1as__ref__t_html"><div class="ttname"><a href="structentt_1_1as__ref__t.html">entt::as_ref_t</a></div><div class="ttdoc">Empty class type used to request the as ref policy.</div><div class="ttdef"><b>Definition:</b> <a href="policy_8hpp_source.html#l00009">policy.hpp:9</a></div></div>
<div class="ttc" id="aclassentt_1_1basic__hashed__string_html"><div class="ttname"><a href="classentt_1_1basic__hashed__string.html">entt::basic_hashed_string</a></div><div class="ttdoc">Zero overhead unique identifier.</div><div class="ttdef"><b>Definition:</b> <a href="hashed__string_8hpp_source.html#l00064">hashed_string.hpp:64</a></div></div>
<div class="ttc" id="anamespaceentt_html_af786b2fb9c4667924bbed3b0bcb83cac"><div class="ttname"><a href="namespaceentt.html#af786b2fb9c4667924bbed3b0bcb83cac">entt::resolve</a></div><div class="ttdeci">meta_type resolve() noexcept</div><div class="ttdoc">Returns the meta type associated with a given type.</div><div class="ttdef"><b>Definition:</b> <a href="resolve_8hpp_source.html#l00022">resolve.hpp:22</a></div></div>
<div class="ttc" id="anamespaceentt_html_a2ab7b51802157a98106f238335fa7503"><div class="ttname"><a href="namespaceentt.html#a2ab7b51802157a98106f238335fa7503">entt::dereference_meta_pointer_like</a></div><div class="ttdeci">decltype(auto) dereference_meta_pointer_like(const Type &amp;value)</div><div class="ttdoc">ADL based lookup function for dereferencing meta pointer-like types.</div><div class="ttdef"><b>Definition:</b> <a href="adl__pointer_8hpp_source.html#l00015">adl_pointer.hpp:15</a></div></div>
<div class="ttc" id="anamespaceentt_html_a4dc3b1582213034f13e2afe5c475467a"><div class="ttname"><a href="namespaceentt.html#a4dc3b1582213034f13e2afe5c475467a">entt::any</a></div><div class="ttdeci">basic_any&lt; sizeof(double[2])&gt; any</div><div class="ttdoc">Alias declaration for the most common use case.</div><div class="ttdef"><b>Definition:</b> <a href="core_2fwd_8hpp_source.html#l00021">fwd.hpp:21</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
