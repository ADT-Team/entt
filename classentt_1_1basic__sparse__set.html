<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EnTT: entt::basic_sparse_set&lt; Entity, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EnTT
   &#160;<span id="projectnumber">3.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceentt.html">entt</a></li><li class="navelem"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classentt_1_1basic__sparse__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">entt::basic_sparse_set&lt; Entity, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic sparse set implementation.  
 <a href="classentt_1_1basic__sparse__set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:affeea7652305dc33f0944256b38ee6cd"><td class="memItemLeft" align="right" valign="top"><a id="affeea7652305dc33f0944256b38ee6cd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#affeea7652305dc33f0944256b38ee6cd">allocator_type</a> = typename alloc_traits::allocator_type</td></tr>
<tr class="memdesc:affeea7652305dc33f0944256b38ee6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type. <br /></td></tr>
<tr class="separator:affeea7652305dc33f0944256b38ee6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c6508fa13b0b3e27679c3c814e6148"><td class="memItemLeft" align="right" valign="top"><a id="a91c6508fa13b0b3e27679c3c814e6148"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a> = Entity</td></tr>
<tr class="memdesc:a91c6508fa13b0b3e27679c3c814e6148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying entity identifier. <br /></td></tr>
<tr class="separator:a91c6508fa13b0b3e27679c3c814e6148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec9530d8aa9ac94d421b27eb6998edb"><td class="memItemLeft" align="right" valign="top"><a id="a2ec9530d8aa9ac94d421b27eb6998edb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a2ec9530d8aa9ac94d421b27eb6998edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type. <br /></td></tr>
<tr class="separator:a2ec9530d8aa9ac94d421b27eb6998edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e28c975fd3fe863b0c4367bd83646d"><td class="memItemLeft" align="right" valign="top"><a id="a32e28c975fd3fe863b0c4367bd83646d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a32e28c975fd3fe863b0c4367bd83646d">pointer</a> = alloc_const_pointer</td></tr>
<tr class="memdesc:a32e28c975fd3fe863b0c4367bd83646d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type to contained entities. <br /></td></tr>
<tr class="separator:a32e28c975fd3fe863b0c4367bd83646d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d4952c840039abce101f46df065c62"><td class="memItemLeft" align="right" valign="top"><a id="a06d4952c840039abce101f46df065c62"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a06d4952c840039abce101f46df065c62">iterator</a> = sparse_set_iterator</td></tr>
<tr class="memdesc:a06d4952c840039abce101f46df065c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator type. <br /></td></tr>
<tr class="separator:a06d4952c840039abce101f46df065c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe62c143e816cf5e12078a607966c003"><td class="memItemLeft" align="right" valign="top"><a id="afe62c143e816cf5e12078a607966c003"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#afe62c143e816cf5e12078a607966c003">reverse_iterator</a> = std::reverse_iterator&lt; <a class="el" href="classentt_1_1basic__sparse__set.html#a06d4952c840039abce101f46df065c62">iterator</a> &gt;</td></tr>
<tr class="memdesc:afe62c143e816cf5e12078a607966c003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator type. <br /></td></tr>
<tr class="separator:afe62c143e816cf5e12078a607966c003"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a65d0be14197c4d2309edf2a533ebab0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a65d0be14197c4d2309edf2a533ebab0a">basic_sparse_set</a> (<a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a> pol, const <a class="el" href="classentt_1_1basic__sparse__set.html#affeea7652305dc33f0944256b38ee6cd">allocator_type</a> &amp;alloc={})</td></tr>
<tr class="memdesc:a65d0be14197c4d2309edf2a533ebab0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with the given policy and allocator.  <a href="classentt_1_1basic__sparse__set.html#a65d0be14197c4d2309edf2a533ebab0a">More...</a><br /></td></tr>
<tr class="separator:a65d0be14197c4d2309edf2a533ebab0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723398ba989c23e035ce4c36d16678d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a723398ba989c23e035ce4c36d16678d0">basic_sparse_set</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#affeea7652305dc33f0944256b38ee6cd">allocator_type</a> &amp;alloc={})</td></tr>
<tr class="memdesc:a723398ba989c23e035ce4c36d16678d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container with the given allocator.  <a href="classentt_1_1basic__sparse__set.html#a723398ba989c23e035ce4c36d16678d0">More...</a><br /></td></tr>
<tr class="separator:a723398ba989c23e035ce4c36d16678d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba22aad9557f355b657798a1e2fd9aad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#aba22aad9557f355b657798a1e2fd9aad">basic_sparse_set</a> (<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aba22aad9557f355b657798a1e2fd9aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classentt_1_1basic__sparse__set.html#aba22aad9557f355b657798a1e2fd9aad">More...</a><br /></td></tr>
<tr class="separator:aba22aad9557f355b657798a1e2fd9aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56f048f614c38f14b19ba9cb27faa94"><td class="memItemLeft" align="right" valign="top"><a id="ac56f048f614c38f14b19ba9cb27faa94"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ac56f048f614c38f14b19ba9cb27faa94">~basic_sparse_set</a> ()</td></tr>
<tr class="memdesc:ac56f048f614c38f14b19ba9cb27faa94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:ac56f048f614c38f14b19ba9cb27faa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd87d086a1b895ac6253c311eb90affb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#afd87d086a1b895ac6253c311eb90affb">operator=</a> (<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:afd87d086a1b895ac6253c311eb90affb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classentt_1_1basic__sparse__set.html#afd87d086a1b895ac6253c311eb90affb">More...</a><br /></td></tr>
<tr class="separator:afd87d086a1b895ac6253c311eb90affb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c273b23bb87b33e04dc598409eeede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a02c273b23bb87b33e04dc598409eeede">policy</a> () const</td></tr>
<tr class="memdesc:a02c273b23bb87b33e04dc598409eeede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the deletion policy of a sparse set.  <a href="classentt_1_1basic__sparse__set.html#a02c273b23bb87b33e04dc598409eeede">More...</a><br /></td></tr>
<tr class="separator:a02c273b23bb87b33e04dc598409eeede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfe17211583fcac905a462dbe2d1c09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a3cfe17211583fcac905a462dbe2d1c09">slot</a> () const</td></tr>
<tr class="memdesc:a3cfe17211583fcac905a462dbe2d1c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next slot available for insertion.  <a href="classentt_1_1basic__sparse__set.html#a3cfe17211583fcac905a462dbe2d1c09">More...</a><br /></td></tr>
<tr class="separator:a3cfe17211583fcac905a462dbe2d1c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1456831942d287bd0abb2e0fb6f5a8d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1456831942d287bd0abb2e0fb6f5a8d9">reserve</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> cap)</td></tr>
<tr class="memdesc:a1456831942d287bd0abb2e0fb6f5a8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the capacity of a sparse set.  <a href="classentt_1_1basic__sparse__set.html#a1456831942d287bd0abb2e0fb6f5a8d9">More...</a><br /></td></tr>
<tr class="separator:a1456831942d287bd0abb2e0fb6f5a8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb10d09946d3b458b34529c75fb85f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1bb10d09946d3b458b34529c75fb85f5">capacity</a> () const</td></tr>
<tr class="memdesc:a1bb10d09946d3b458b34529c75fb85f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that a sparse set has currently allocated space for.  <a href="classentt_1_1basic__sparse__set.html#a1bb10d09946d3b458b34529c75fb85f5">More...</a><br /></td></tr>
<tr class="separator:a1bb10d09946d3b458b34529c75fb85f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f9cfcadf89b90e97ece65b739aeb75"><td class="memItemLeft" align="right" valign="top"><a id="a23f9cfcadf89b90e97ece65b739aeb75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a23f9cfcadf89b90e97ece65b739aeb75">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a23f9cfcadf89b90e97ece65b739aeb75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity. <br /></td></tr>
<tr class="separator:a23f9cfcadf89b90e97ece65b739aeb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df44971fcaba319e05955a2943baa14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a9df44971fcaba319e05955a2943baa14">extent</a> () const</td></tr>
<tr class="memdesc:a9df44971fcaba319e05955a2943baa14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extent of a sparse set.  <a href="classentt_1_1basic__sparse__set.html#a9df44971fcaba319e05955a2943baa14">More...</a><br /></td></tr>
<tr class="separator:a9df44971fcaba319e05955a2943baa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781b6cee81c02b5dd601d0c808cf97a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a781b6cee81c02b5dd601d0c808cf97a8">size</a> () const</td></tr>
<tr class="memdesc:a781b6cee81c02b5dd601d0c808cf97a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a sparse set.  <a href="classentt_1_1basic__sparse__set.html#a781b6cee81c02b5dd601d0c808cf97a8">More...</a><br /></td></tr>
<tr class="separator:a781b6cee81c02b5dd601d0c808cf97a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3617c860500230b880f07215f21cb496"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a3617c860500230b880f07215f21cb496">empty</a> () const</td></tr>
<tr class="memdesc:a3617c860500230b880f07215f21cb496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a sparse set is empty.  <a href="classentt_1_1basic__sparse__set.html#a3617c860500230b880f07215f21cb496">More...</a><br /></td></tr>
<tr class="separator:a3617c860500230b880f07215f21cb496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa8a3f16cdaa2d85316683d008bf8c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a32e28c975fd3fe863b0c4367bd83646d">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#adaa8a3f16cdaa2d85316683d008bf8c5">data</a> () const</td></tr>
<tr class="memdesc:adaa8a3f16cdaa2d85316683d008bf8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the internal packed array.  <a href="classentt_1_1basic__sparse__set.html#adaa8a3f16cdaa2d85316683d008bf8c5">More...</a><br /></td></tr>
<tr class="separator:adaa8a3f16cdaa2d85316683d008bf8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1465b127e3c50e654f04c6da4965f147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a06d4952c840039abce101f46df065c62">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1465b127e3c50e654f04c6da4965f147">begin</a> () const</td></tr>
<tr class="memdesc:a1465b127e3c50e654f04c6da4965f147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="classentt_1_1basic__sparse__set.html#a1465b127e3c50e654f04c6da4965f147">More...</a><br /></td></tr>
<tr class="separator:a1465b127e3c50e654f04c6da4965f147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c40a25499f47f87e13591aa378a0fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a06d4952c840039abce101f46df065c62">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a34c40a25499f47f87e13591aa378a0fb">end</a> () const</td></tr>
<tr class="memdesc:a34c40a25499f47f87e13591aa378a0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <a href="classentt_1_1basic__sparse__set.html#a34c40a25499f47f87e13591aa378a0fb">More...</a><br /></td></tr>
<tr class="separator:a34c40a25499f47f87e13591aa378a0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c990b5d9720d9a3b29466756aaa42e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#afe62c143e816cf5e12078a607966c003">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a7c990b5d9720d9a3b29466756aaa42e1">rbegin</a> () const</td></tr>
<tr class="memdesc:a7c990b5d9720d9a3b29466756aaa42e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="classentt_1_1basic__sparse__set.html#a7c990b5d9720d9a3b29466756aaa42e1">More...</a><br /></td></tr>
<tr class="separator:a7c990b5d9720d9a3b29466756aaa42e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc1fee7c920941ac936ed7df9207343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#afe62c143e816cf5e12078a607966c003">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1bc1fee7c920941ac936ed7df9207343">rend</a> () const</td></tr>
<tr class="memdesc:a1bc1fee7c920941ac936ed7df9207343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <a href="classentt_1_1basic__sparse__set.html#a1bc1fee7c920941ac936ed7df9207343">More...</a><br /></td></tr>
<tr class="separator:a1bc1fee7c920941ac936ed7df9207343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ea72545db86b1c25a790772d015c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a06d4952c840039abce101f46df065c62">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a82ea72545db86b1c25a790772d015c3d">find</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a> entt) const</td></tr>
<tr class="memdesc:a82ea72545db86b1c25a790772d015c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an entity.  <a href="classentt_1_1basic__sparse__set.html#a82ea72545db86b1c25a790772d015c3d">More...</a><br /></td></tr>
<tr class="separator:a82ea72545db86b1c25a790772d015c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c7f1ac19e1040c2c2d2245f521f291"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ad2c7f1ac19e1040c2c2d2245f521f291">contains</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a> entt) const</td></tr>
<tr class="memdesc:ad2c7f1ac19e1040c2c2d2245f521f291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a sparse set contains an entity.  <a href="classentt_1_1basic__sparse__set.html#ad2c7f1ac19e1040c2c2d2245f521f291">More...</a><br /></td></tr>
<tr class="separator:ad2c7f1ac19e1040c2c2d2245f521f291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af775539f37a31b1da7254491a53b1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1af775539f37a31b1da7254491a53b1f">index</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a> entt) const</td></tr>
<tr class="memdesc:a1af775539f37a31b1da7254491a53b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of an entity in a sparse set.  <a href="classentt_1_1basic__sparse__set.html#a1af775539f37a31b1da7254491a53b1f">More...</a><br /></td></tr>
<tr class="separator:a1af775539f37a31b1da7254491a53b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d4efaf22f43c1a8573e50c7460299a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#aa0d4efaf22f43c1a8573e50c7460299a">at</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> pos) const</td></tr>
<tr class="memdesc:aa0d4efaf22f43c1a8573e50c7460299a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity at specified location, with bounds checking.  <a href="classentt_1_1basic__sparse__set.html#aa0d4efaf22f43c1a8573e50c7460299a">More...</a><br /></td></tr>
<tr class="separator:aa0d4efaf22f43c1a8573e50c7460299a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f88e4df5066e55ebfba192a85050553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a3f88e4df5066e55ebfba192a85050553">operator[]</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> pos) const</td></tr>
<tr class="memdesc:a3f88e4df5066e55ebfba192a85050553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity at specified location, without bounds checking.  <a href="classentt_1_1basic__sparse__set.html#a3f88e4df5066e55ebfba192a85050553">More...</a><br /></td></tr>
<tr class="separator:a3f88e4df5066e55ebfba192a85050553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc550073edf12594bc9a6a6528b7adcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#abc550073edf12594bc9a6a6528b7adcd">emplace_back</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a> entt)</td></tr>
<tr class="memdesc:abc550073edf12594bc9a6a6528b7adcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends an entity to a sparse set.  <a href="classentt_1_1basic__sparse__set.html#abc550073edf12594bc9a6a6528b7adcd">More...</a><br /></td></tr>
<tr class="separator:abc550073edf12594bc9a6a6528b7adcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcb8298dba48d35d2d432edafd601de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a2bcb8298dba48d35d2d432edafd601de">emplace</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a> entt)</td></tr>
<tr class="memdesc:a2bcb8298dba48d35d2d432edafd601de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an entity to a sparse set.  <a href="classentt_1_1basic__sparse__set.html#a2bcb8298dba48d35d2d432edafd601de">More...</a><br /></td></tr>
<tr class="separator:a2bcb8298dba48d35d2d432edafd601de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3903daddc7ec0a8260d8828b009402"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a1a3903daddc7ec0a8260d8828b009402"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1a3903daddc7ec0a8260d8828b009402">insert</a> (It first, It last)</td></tr>
<tr class="memdesc:a1a3903daddc7ec0a8260d8828b009402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns one or more entities to a sparse set.  <a href="classentt_1_1basic__sparse__set.html#a1a3903daddc7ec0a8260d8828b009402">More...</a><br /></td></tr>
<tr class="separator:a1a3903daddc7ec0a8260d8828b009402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65d65a79a310182de30de7e2650451a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#af65d65a79a310182de30de7e2650451a">erase</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a> entt, void *ud=nullptr)</td></tr>
<tr class="memdesc:af65d65a79a310182de30de7e2650451a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases an entity from a sparse set.  <a href="classentt_1_1basic__sparse__set.html#af65d65a79a310182de30de7e2650451a">More...</a><br /></td></tr>
<tr class="separator:af65d65a79a310182de30de7e2650451a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c565519a89dbc5c30bc98bf5e3b7be"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:ac4c565519a89dbc5c30bc98bf5e3b7be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ac4c565519a89dbc5c30bc98bf5e3b7be">erase</a> (It first, It last, void *ud=nullptr)</td></tr>
<tr class="memdesc:ac4c565519a89dbc5c30bc98bf5e3b7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases entities from a set.  <a href="classentt_1_1basic__sparse__set.html#ac4c565519a89dbc5c30bc98bf5e3b7be">More...</a><br /></td></tr>
<tr class="separator:ac4c565519a89dbc5c30bc98bf5e3b7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9863afe50a42c7c3ff820b16ce5b517d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a9863afe50a42c7c3ff820b16ce5b517d">remove</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a> entt, void *ud=nullptr)</td></tr>
<tr class="memdesc:a9863afe50a42c7c3ff820b16ce5b517d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an entity from a sparse set if it exists.  <a href="classentt_1_1basic__sparse__set.html#a9863afe50a42c7c3ff820b16ce5b517d">More...</a><br /></td></tr>
<tr class="separator:a9863afe50a42c7c3ff820b16ce5b517d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0232f804145aa29d256bbce5944354f3"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a0232f804145aa29d256bbce5944354f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a0232f804145aa29d256bbce5944354f3">remove</a> (It first, It last, void *ud=nullptr)</td></tr>
<tr class="memdesc:a0232f804145aa29d256bbce5944354f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes entities from a sparse set if they exist.  <a href="classentt_1_1basic__sparse__set.html#a0232f804145aa29d256bbce5944354f3">More...</a><br /></td></tr>
<tr class="separator:a0232f804145aa29d256bbce5944354f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4979ce48546cfcc705c4d23654faef2"><td class="memItemLeft" align="right" valign="top"><a id="af4979ce48546cfcc705c4d23654faef2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#af4979ce48546cfcc705c4d23654faef2">compact</a> ()</td></tr>
<tr class="memdesc:af4979ce48546cfcc705c4d23654faef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all tombstones from the packed array of a sparse set. <br /></td></tr>
<tr class="separator:af4979ce48546cfcc705c4d23654faef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f188dbfbf2dc3d85df9776578d6e14b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a8f188dbfbf2dc3d85df9776578d6e14b">swap</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a> lhs, const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a> rhs)</td></tr>
<tr class="memdesc:a8f188dbfbf2dc3d85df9776578d6e14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two entities in the internal packed array.  <a href="classentt_1_1basic__sparse__set.html#a8f188dbfbf2dc3d85df9776578d6e14b">More...</a><br /></td></tr>
<tr class="separator:a8f188dbfbf2dc3d85df9776578d6e14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b7b5e9f1da7e1b887125c6f88b4b9a"><td class="memTemplParams" colspan="2">template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </td></tr>
<tr class="memitem:a69b7b5e9f1da7e1b887125c6f88b4b9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a69b7b5e9f1da7e1b887125c6f88b4b9a">sort_n</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> length, Compare compare, Sort algo=Sort{}, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a69b7b5e9f1da7e1b887125c6f88b4b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the first count elements according to the given comparison function.  <a href="classentt_1_1basic__sparse__set.html#a69b7b5e9f1da7e1b887125c6f88b4b9a">More...</a><br /></td></tr>
<tr class="separator:a69b7b5e9f1da7e1b887125c6f88b4b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb106e820264d3632c676cc9b6c2fff"><td class="memTemplParams" colspan="2">template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </td></tr>
<tr class="memitem:abeb106e820264d3632c676cc9b6c2fff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#abeb106e820264d3632c676cc9b6c2fff">sort</a> (Compare compare, Sort algo=Sort{}, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abeb106e820264d3632c676cc9b6c2fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all elements according to the given comparison function.  <a href="classentt_1_1basic__sparse__set.html#abeb106e820264d3632c676cc9b6c2fff">More...</a><br /></td></tr>
<tr class="separator:abeb106e820264d3632c676cc9b6c2fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b9f10f5212846bfea6e4fd0ba7a1e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#ad6b9f10f5212846bfea6e4fd0ba7a1e4">respect</a> (const <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> &amp;other)</td></tr>
<tr class="memdesc:ad6b9f10f5212846bfea6e4fd0ba7a1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort entities according to their order in another sparse set.  <a href="classentt_1_1basic__sparse__set.html#ad6b9f10f5212846bfea6e4fd0ba7a1e4">More...</a><br /></td></tr>
<tr class="separator:ad6b9f10f5212846bfea6e4fd0ba7a1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19320f0dea455f067afd834781cbffbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a19320f0dea455f067afd834781cbffbd">clear</a> (void *ud=nullptr)</td></tr>
<tr class="memdesc:a19320f0dea455f067afd834781cbffbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a sparse set.  <a href="classentt_1_1basic__sparse__set.html#a19320f0dea455f067afd834781cbffbd">More...</a><br /></td></tr>
<tr class="separator:a19320f0dea455f067afd834781cbffbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af6702bf5e5e616eb732a864bebc3818b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#af6702bf5e5e616eb732a864bebc3818b">swap_at</a> ([[maybe_unused]] const std::size_t lhs, [[maybe_unused]] const std::size_t rhs)</td></tr>
<tr class="memdesc:af6702bf5e5e616eb732a864bebc3818b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two entities in the internal packed array.  <a href="classentt_1_1basic__sparse__set.html#af6702bf5e5e616eb732a864bebc3818b">More...</a><br /></td></tr>
<tr class="separator:af6702bf5e5e616eb732a864bebc3818b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150e6ee07f7a6866a0a34f7b3fc44a80"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a150e6ee07f7a6866a0a34f7b3fc44a80">move_and_pop</a> ([[maybe_unused]] const std::size_t from, [[maybe_unused]] const std::size_t to)</td></tr>
<tr class="memdesc:a150e6ee07f7a6866a0a34f7b3fc44a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves an entity in the internal packed array.  <a href="classentt_1_1basic__sparse__set.html#a150e6ee07f7a6866a0a34f7b3fc44a80">More...</a><br /></td></tr>
<tr class="separator:a150e6ee07f7a6866a0a34f7b3fc44a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0215c705dc46b380e2eb50177380e71d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a0215c705dc46b380e2eb50177380e71d">swap_and_pop</a> (const Entity entt, [[maybe_unused]] void *ud)</td></tr>
<tr class="memdesc:a0215c705dc46b380e2eb50177380e71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to erase an entity from the internal packed array.  <a href="classentt_1_1basic__sparse__set.html#a0215c705dc46b380e2eb50177380e71d">More...</a><br /></td></tr>
<tr class="separator:a0215c705dc46b380e2eb50177380e71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b75ce8202fd9859829f3152d6243a50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classentt_1_1basic__sparse__set.html#a1b75ce8202fd9859829f3152d6243a50">in_place_pop</a> (const Entity entt, [[maybe_unused]] void *ud)</td></tr>
<tr class="memdesc:a1b75ce8202fd9859829f3152d6243a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to erase an entity from the internal packed array.  <a href="classentt_1_1basic__sparse__set.html#a1b75ce8202fd9859829f3152d6243a50">More...</a><br /></td></tr>
<tr class="separator:a1b75ce8202fd9859829f3152d6243a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Entity, typename Allocator&gt;<br />
class entt::basic_sparse_set&lt; Entity, Allocator &gt;</h3>

<p>Basic sparse set implementation. </p>
<p>Sparse set or packed array or whatever is the name users give it.<br  />
 Two arrays: an <em>external</em> one and an <em>internal</em> one; a <em>sparse</em> one and a <em>packed</em> one; one used for direct access through contiguous memory, the other one used to get the data through an extra level of indirection.<br  />
 This is largely used by the registry to offer users the fastest access ever to the components. Views and groups in general are almost entirely designed around sparse sets.</p>
<p>This type of data structure is widely documented in the literature and on the web. This is nothing more than a customized implementation suitable for the purpose of the framework.</p>
<dl class="section note"><dt>Note</dt><dd>Internal data structures arrange elements to maximize performance. There are no guarantees that entities are returned in the insertion order when iterate a sparse set. Do not make assumption on the order in any case.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Entity</td><td>A valid entity type (see <a class="el" href="classentt_1_1entt__traits.html" title="Entity traits.">entt_traits</a> for more details). </td></tr>
    <tr><td class="paramname">Allocator</td><td>Type of allocator used to manage memory and elements. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00053">53</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a65d0be14197c4d2309edf2a533ebab0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d0be14197c4d2309edf2a533ebab0a">&#9670;&nbsp;</a></span>basic_sparse_set() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a>&#160;</td>
          <td class="paramname"><em>pol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#affeea7652305dc33f0944256b38ee6cd">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with the given policy and allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pol</td><td>Type of deletion policy. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use (possibly default-constructed). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00295">295</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a723398ba989c23e035ce4c36d16678d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723398ba989c23e035ce4c36d16678d0">&#9670;&nbsp;</a></span>basic_sparse_set() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#affeea7652305dc33f0944256b38ee6cd">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container with the given allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>Allocator to use (possibly default-constructed). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00311">311</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="aba22aad9557f355b657798a1e2fd9aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba22aad9557f355b657798a1e2fd9aad">&#9670;&nbsp;</a></span>basic_sparse_set() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::<a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to move from. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00319">319</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa0d4efaf22f43c1a8573e50c7460299a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d4efaf22f43c1a8573e50c7460299a">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entity at specified location, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position for which to return the entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entity at specified location if any, a null entity otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00544">544</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a1465b127e3c50e654f04c6da4965f147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1465b127e3c50e654f04c6da4965f147">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a06d4952c840039abce101f46df065c62">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<p>The returned iterator points to the first entity of the internal packed array. If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="classentt_1_1basic__sparse__set.html#a34c40a25499f47f87e13591aa378a0fb" title="Returns an iterator to the end.">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the internal packed array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00456">456</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a1bb10d09946d3b458b34529c75fb85f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb10d09946d3b458b34529c75fb85f5">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that a sparse set has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of the sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00392">392</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a19320f0dea455f067afd834781cbffbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19320f0dea455f067afd834781cbffbd">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a sparse set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ud</td><td>Optional user data that are forwarded as-is to derived classes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00843">843</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ad2c7f1ac19e1040c2c2d2245f521f291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c7f1ac19e1040c2c2d2245f521f291">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a sparse set contains an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sparse set contains the entity, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00517">517</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="adaa8a3f16cdaa2d85316683d008bf8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa8a3f16cdaa2d85316683d008bf8c5">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a32e28c975fd3fe863b0c4367bd83646d">pointer</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the internal packed array. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the internal packed array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00443">443</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a2bcb8298dba48d35d2d432edafd601de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bcb8298dba48d35d2d432edafd601de">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns an entity to a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to assign an entity that already belongs to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The slot used for insertion. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00591">591</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="abc550073edf12594bc9a6a6528b7adcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc550073edf12594bc9a6a6528b7adcd">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends an entity to a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to assign an entity that already belongs to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The slot used for insertion. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00568">568</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a3617c860500230b880f07215f21cb496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3617c860500230b880f07215f21cb496">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a sparse set is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the sparse set is empty, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00435">435</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a34c40a25499f47f87e13591aa378a0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c40a25499f47f87e13591aa378a0fb">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a06d4952c840039abce101f46df065c62">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end. </p>
<p>The returned iterator points to the element following the last entity in the internal packed array. Attempting to dereference the returned iterator results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of the internal packed array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00470">470</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="af65d65a79a310182de30de7e2650451a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65d65a79a310182de30de7e2650451a">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an entity from a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to erase an entity that doesn't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
    <tr><td class="paramname">ud</td><td>Optional user data that are forwarded as-is to derived classes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00636">636</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ac4c565519a89dbc5c30bc98bf5e3b7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c565519a89dbc5c30bc98bf5e3b7be">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases entities from a set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classentt_1_1basic__sparse__set.html#af65d65a79a310182de30de7e2650451a" title="Erases an entity from a sparse set.">erase</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
    <tr><td class="paramname">ud</td><td>Optional user data that are forwarded as-is to derived classes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00652">652</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a9df44971fcaba319e05955a2943baa14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df44971fcaba319e05955a2943baa14">&#9670;&nbsp;</a></span>extent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::extent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the extent of a sparse set. </p>
<p>The extent of a sparse set is also the size of the internal sparse array. There is no guarantee that the internal packed array has the same size. Usually the size of the internal sparse array is equal or greater than the one of the internal packed array.</p>
<dl class="section return"><dt>Returns</dt><dd>Extent of the sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00413">413</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a82ea72545db86b1c25a790772d015c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ea72545db86b1c25a790772d015c3d">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a06d4952c840039abce101f46df065c62">iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the given entity if it's found, past the end iterator otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00508">508</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a1b75ce8202fd9859829f3152d6243a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b75ce8202fd9859829f3152d6243a50">&#9670;&nbsp;</a></span>in_place_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::in_place_pop </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] void *&#160;</td>
          <td class="paramname"><em>ud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to erase an entity from the internal packed array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
    <tr><td class="paramname">ud</td><td>Optional user data that are forwarded as-is to derived classes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00266">266</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a1af775539f37a31b1da7254491a53b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af775539f37a31b1da7254491a53b1f">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of an entity in a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to get the position of an entity that doesn't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the entity in the sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00534">534</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a1a3903daddc7ec0a8260d8828b009402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3903daddc7ec0a8260d8828b009402">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns one or more entities to a sparse set. </p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to assign an entity that already belongs to the sparse set results in undefined behavior.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00615">615</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a150e6ee07f7a6866a0a34f7b3fc44a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150e6ee07f7a6866a0a34f7b3fc44a80">&#9670;&nbsp;</a></span>move_and_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::move_and_pop </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const std::size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const std::size_t&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves an entity in the internal packed array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>A valid position of an entity within storage. </td></tr>
    <tr><td class="paramname">to</td><td>A valid position of an entity within storage. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00240">240</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="afd87d086a1b895ac6253c311eb90affb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd87d086a1b895ac6253c311eb90affb">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&amp; <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The instance to move from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00341">341</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a3f88e4df5066e55ebfba192a85050553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f88e4df5066e55ebfba192a85050553">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entity at specified location, without bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position for which to return the entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entity at specified location. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00553">553</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a02c273b23bb87b33e04dc598409eeede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c273b23bb87b33e04dc598409eeede">&#9670;&nbsp;</a></span>policy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceentt.html#abc4d0fa77fae26e7c01793990996c581">deletion_policy</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::policy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the deletion policy of a sparse set. </p>
<dl class="section return"><dt>Returns</dt><dd>The deletion policy of the sparse set. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00361">361</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a7c990b5d9720d9a3b29466756aaa42e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c990b5d9720d9a3b29466756aaa42e1">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#afe62c143e816cf5e12078a607966c003">reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the beginning. </p>
<p>The returned iterator points to the first entity of the reversed internal packed array. If the sparse set is empty, the returned iterator will be equal to <code><a class="el" href="classentt_1_1basic__sparse__set.html#a1bc1fee7c920941ac936ed7df9207343" title="Returns a reverse iterator to the end.">rend()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first entity of the reversed internal packed array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00484">484</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a9863afe50a42c7c3ff820b16ce5b517d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9863afe50a42c7c3ff820b16ce5b517d">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a>&#160;</td>
          <td class="paramname"><em>entt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an entity from a sparse set if it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
    <tr><td class="paramname">ud</td><td>Optional user data that are forwarded as-is to derived classes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the entity is actually removed, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00664">664</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a0232f804145aa29d256bbce5944354f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0232f804145aa29d256bbce5944354f3">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes entities from a sparse set if they exist. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Type of input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator to the first element of the range of entities. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator past the last element of the range of entities. </td></tr>
    <tr><td class="paramname">ud</td><td>Optional user data that are forwarded as-is to derived classes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of entities actually removed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00677">677</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a1bc1fee7c920941ac936ed7df9207343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc1fee7c920941ac936ed7df9207343">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#afe62c143e816cf5e12078a607966c003">reverse_iterator</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the end. </p>
<p>The returned iterator points to the element following the last entity in the reversed internal packed array. Attempting to dereference the returned iterator results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element following the last entity of the reversed internal packed array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00498">498</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a1456831942d287bd0abb2e0fb6f5a8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1456831942d287bd0abb2e0fb6f5a8d9">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases the capacity of a sparse set. </p>
<p>If the new capacity is greater than the current capacity, new storage is allocated, otherwise the method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cap</td><td>Desired capacity. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00381">381</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="ad6b9f10f5212846bfea6e4fd0ba7a1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b9f10f5212846bfea6e4fd0ba7a1e4">&#9670;&nbsp;</a></span>respect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::respect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html">basic_sparse_set</a>&lt; Entity, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort entities according to their order in another sparse set. </p>
<p>Entities that are part of both the sparse sets are ordered internally according to the order they have in <code>other</code>. All the other entities goes to the end of the list and there are no guarantees on their order.<br  />
 In other terms, this function can be used to impose the same order on two sets by using one of them as a master and the other one as a slave.</p>
<p>Iterating the sparse set with a couple of iterators returns elements in the expected order after a call to <code>respect</code>. See <code>begin</code> and <code>end</code> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The sparse sets that imposes the order of the entities. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00821">821</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a781b6cee81c02b5dd601d0c808cf97a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781b6cee81c02b5dd601d0c808cf97a8">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in a sparse set. </p>
<p>The number of elements is also the size of the internal packed array. There is no guarantee that the internal sparse array has the same size. Usually the size of the internal sparse array is equal or greater than the one of the internal packed array.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00427">427</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a3cfe17211583fcac905a462dbe2d1c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfe17211583fcac905a462dbe2d1c09">&#9670;&nbsp;</a></span>slot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a> <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::slot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next slot available for insertion. </p>
<dl class="section return"><dt>Returns</dt><dd>The next slot available for insertion. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00369">369</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="abeb106e820264d3632c676cc9b6c2fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb106e820264d3632c676cc9b6c2fff">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sort&#160;</td>
          <td class="paramname"><em>algo</em> = <code>Sort{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort all elements according to the given comparison function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classentt_1_1basic__sparse__set.html#a69b7b5e9f1da7e1b887125c6f88b4b9a" title="Sort the first count elements according to the given comparison function.">sort_n</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Compare</td><td>Type of comparison function object. </td></tr>
    <tr><td class="paramname">Sort</td><td>Type of sort function object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to forward to the sort function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>A valid comparison function object. </td></tr>
    <tr><td class="paramname">algo</td><td>A valid sort function object. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the sort function object, if any. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00802">802</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a69b7b5e9f1da7e1b887125c6f88b4b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b7b5e9f1da7e1b887125c6f88b4b9a">&#9670;&nbsp;</a></span>sort_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename Compare , typename Sort  = std_sort, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::sort_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a2ec9530d8aa9ac94d421b27eb6998edb">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sort&#160;</td>
          <td class="paramname"><em>algo</em> = <code>Sort{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the first count elements according to the given comparison function. </p>
<p>The comparison function object must return <code>true</code> if the first element is <em>less</em> than the second one, <code>false</code> otherwise. The signature of the comparison function should be equivalent to the following:</p>
<div class="fragment"><div class="line">bool(<span class="keyword">const</span> Entity, <span class="keyword">const</span> Entity);</div>
</div><!-- fragment --><p>Moreover, the comparison function object shall induce a <em>strict weak ordering</em> on the values.</p>
<p>The sort function object must offer a member function template <code>operator()</code> that accepts three arguments:</p>
<ul>
<li>An iterator to the first element of the range to sort.</li>
<li>An iterator past the last element of the range to sort.</li>
<li>A comparison function to use to compare the elements.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Compare</td><td>Type of comparison function object. </td></tr>
    <tr><td class="paramname">Sort</td><td>Type of sort function object. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments to forward to the sort function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Number of elements to sort. </td></tr>
    <tr><td class="paramname">compare</td><td>A valid comparison function object. </td></tr>
    <tr><td class="paramname">algo</td><td>A valid sort function object. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to the sort function object, if any. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00767">767</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a8f188dbfbf2dc3d85df9776578d6e14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f188dbfbf2dc3d85df9776578d6e14b">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classentt_1_1basic__sparse__set.html#a91c6508fa13b0b3e27679c3c814e6148">entity_type</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two entities in the internal packed array. </p>
<p>For what it's worth, this function affects both the internal sparse array and the internal packed array. Users should not care of that anyway.</p>
<dl class="section warning"><dt>Warning</dt><dd>Attempting to swap entities that don't belong to the sparse set results in undefined behavior.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid entity identifier. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid entity identifier. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00720">720</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="a0215c705dc46b380e2eb50177380e71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0215c705dc46b380e2eb50177380e71d">&#9670;&nbsp;</a></span>swap_and_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::swap_and_pop </td>
          <td>(</td>
          <td class="paramtype">const Entity&#160;</td>
          <td class="paramname"><em>entt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] void *&#160;</td>
          <td class="paramname"><em>ud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to erase an entity from the internal packed array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entt</td><td>A valid entity identifier. </td></tr>
    <tr><td class="paramname">ud</td><td>Optional user data that are forwarded as-is to derived classes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00247">247</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<a id="af6702bf5e5e616eb732a864bebc3818b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6702bf5e5e616eb732a864bebc3818b">&#9670;&nbsp;</a></span>swap_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Entity , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classentt_1_1basic__sparse__set.html">entt::basic_sparse_set</a>&lt; Entity, Allocator &gt;::swap_at </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const std::size_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const std::size_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two entities in the internal packed array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A valid position of an entity within storage. </td></tr>
    <tr><td class="paramname">rhs</td><td>A valid position of an entity within storage. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparse__set_8hpp_source.html#l00233">233</a> of file <a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/entt/entity/<a class="el" href="entity_2fwd_8hpp_source.html">fwd.hpp</a></li>
<li>src/entt/entity/<a class="el" href="sparse__set_8hpp_source.html">sparse_set.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
